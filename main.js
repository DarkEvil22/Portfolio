/*! For license information please see main.js.LICENSE.txt */
(() => {
    var t = {
            69: function (t) {
                t.exports = function () {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }

                    function e(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }

                    function n() {
                        return (n = Object.assign || function (t) {
                            for (var e = 1; e < arguments.length; e++) {
                                var n = arguments[e];
                                for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                            }
                            return t
                        }).apply(this, arguments)
                    }

                    function i(t, e) {
                        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
                    }

                    function r(t) {
                        return (r = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                            return t.__proto__ || Object.getPrototypeOf(t)
                        })(t)
                    }

                    function s(t, e) {
                        return (s = Object.setPrototypeOf || function (t, e) {
                            return t.__proto__ = e, t
                        })(t, e)
                    }

                    function o(t, e, n) {
                        return (o = function () {
                            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                            if (Reflect.construct.sham) return !1;
                            if ("function" == typeof Proxy) return !0;
                            try {
                                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
                            } catch (t) {
                                return !1
                            }
                        }() ? Reflect.construct : function (t, e, n) {
                            var i = [null];
                            i.push.apply(i, e);
                            var r = new(Function.bind.apply(t, i));
                            return n && s(r, n.prototype), r
                        }).apply(null, arguments)
                    }

                    function a(t) {
                        var e = "function" == typeof Map ? new Map : void 0;
                        return (a = function (t) {
                            if (null === t || -1 === Function.toString.call(t).indexOf("[native code]")) return t;
                            if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                            if (void 0 !== e) {
                                if (e.has(t)) return e.get(t);
                                e.set(t, n)
                            }

                            function n() {
                                return o(t, arguments, r(this).constructor)
                            }
                            return n.prototype = Object.create(t.prototype, {
                                constructor: {
                                    value: n,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), s(n, t)
                        })(t)
                    }

                    function l(t, e) {
                        try {
                            var n = t()
                        } catch (t) {
                            return e(t)
                        }
                        return n && n.then ? n.then(void 0, e) : n
                    }
                    "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
                    var c, u = "2.9.7",
                        h = function () {};
                    ! function (t) {
                        t[t.off = 0] = "off", t[t.error = 1] = "error", t[t.warning = 2] = "warning", t[t.info = 3] = "info", t[t.debug = 4] = "debug"
                    }(c || (c = {}));
                    var d = c.off,
                        f = function () {
                            function t(t) {
                                this.t = t
                            }
                            t.getLevel = function () {
                                return d
                            }, t.setLevel = function (t) {
                                return d = c[t]
                            };
                            var e = t.prototype;
                            return e.error = function () {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                this.i(console.error, c.error, e)
                            }, e.warn = function () {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                this.i(console.warn, c.warning, e)
                            }, e.info = function () {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                this.i(console.info, c.info, e)
                            }, e.debug = function () {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                this.i(console.log, c.debug, e)
                            }, e.i = function (e, n, i) {
                                n <= t.getLevel() && e.apply(console, ["[" + this.t + "] "].concat(i))
                            }, t
                        }(),
                        p = P,
                        m = S,
                        g = b,
                        v = E,
                        _ = A,
                        y = "/",
                        x = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");

                    function b(t, e) {
                        for (var n, i = [], r = 0, s = 0, o = "", a = e && e.delimiter || y, l = e && e.whitelist || void 0, c = !1; null !== (n = x.exec(t));) {
                            var u = n[0],
                                h = n[1],
                                d = n.index;
                            if (o += t.slice(s, d), s = d + u.length, h) o += h[1], c = !0;
                            else {
                                var f = "",
                                    p = n[2],
                                    m = n[3],
                                    g = n[4],
                                    v = n[5];
                                if (!c && o.length) {
                                    var _ = o.length - 1,
                                        b = o[_];
                                    (!l || l.indexOf(b) > -1) && (f = b, o = o.slice(0, _))
                                }
                                o && (i.push(o), o = "", c = !1);
                                var S = m || g,
                                    E = f || a;
                                i.push({
                                    name: p || r++,
                                    prefix: f,
                                    delimiter: E,
                                    optional: "?" === v || "*" === v,
                                    repeat: "+" === v || "*" === v,
                                    pattern: S ? w(S) : "[^" + M(E === a ? E : E + a) + "]+?"
                                })
                            }
                        }
                        return (o || s < t.length) && i.push(o + t.substr(s)), i
                    }

                    function S(t, e) {
                        return function (n, i) {
                            var r = t.exec(n);
                            if (!r) return !1;
                            for (var s = r[0], o = r.index, a = {}, l = i && i.decode || decodeURIComponent, c = 1; c < r.length; c++)
                                if (void 0 !== r[c]) {
                                    var u = e[c - 1];
                                    a[u.name] = u.repeat ? r[c].split(u.delimiter).map((function (t) {
                                        return l(t, u)
                                    })) : l(r[c], u)
                                } return {
                                path: s,
                                index: o,
                                params: a
                            }
                        }
                    }

                    function E(t, e) {
                        for (var n = new Array(t.length), i = 0; i < t.length; i++) "object" == typeof t[i] && (n[i] = new RegExp("^(?:" + t[i].pattern + ")$", T(e)));
                        return function (e, i) {
                            for (var r = "", s = i && i.encode || encodeURIComponent, o = !i || !1 !== i.validate, a = 0; a < t.length; a++) {
                                var l = t[a];
                                if ("string" != typeof l) {
                                    var c, u = e ? e[l.name] : void 0;
                                    if (Array.isArray(u)) {
                                        if (!l.repeat) throw new TypeError('Expected "' + l.name + '" to not repeat, but got array');
                                        if (0 === u.length) {
                                            if (l.optional) continue;
                                            throw new TypeError('Expected "' + l.name + '" to not be empty')
                                        }
                                        for (var h = 0; h < u.length; h++) {
                                            if (c = s(u[h], l), o && !n[a].test(c)) throw new TypeError('Expected all "' + l.name + '" to match "' + l.pattern + '"');
                                            r += (0 === h ? l.prefix : l.delimiter) + c
                                        }
                                    } else if ("string" != typeof u && "number" != typeof u && "boolean" != typeof u) {
                                        if (!l.optional) throw new TypeError('Expected "' + l.name + '" to be ' + (l.repeat ? "an array" : "a string"))
                                    } else {
                                        if (c = s(String(u), l), o && !n[a].test(c)) throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern + '", but got "' + c + '"');
                                        r += l.prefix + c
                                    }
                                } else r += l
                            }
                            return r
                        }
                    }

                    function M(t) {
                        return t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
                    }

                    function w(t) {
                        return t.replace(/([=!:$/()])/g, "\\$1")
                    }

                    function T(t) {
                        return t && t.sensitive ? "" : "i"
                    }

                    function A(t, e, n) {
                        for (var i = (n = n || {}).strict, r = !1 !== n.start, s = !1 !== n.end, o = n.delimiter || y, a = [].concat(n.endsWith || []).map(M).concat("$").join("|"), l = r ? "^" : "", c = 0; c < t.length; c++) {
                            var u = t[c];
                            if ("string" == typeof u) l += M(u);
                            else {
                                var h = u.repeat ? "(?:" + u.pattern + ")(?:" + M(u.delimiter) + "(?:" + u.pattern + "))*" : u.pattern;
                                e && e.push(u), l += u.optional ? u.prefix ? "(?:" + M(u.prefix) + "(" + h + "))?" : "(" + h + ")?" : M(u.prefix) + "(" + h + ")"
                            }
                        }
                        if (s) i || (l += "(?:" + M(o) + ")?"), l += "$" === a ? "$" : "(?=" + a + ")";
                        else {
                            var d = t[t.length - 1],
                                f = "string" == typeof d ? d[d.length - 1] === o : void 0 === d;
                            i || (l += "(?:" + M(o) + "(?=" + a + "))?"), f || (l += "(?=" + M(o) + "|" + a + ")")
                        }
                        return new RegExp(l, T(n))
                    }

                    function P(t, e, n) {
                        return t instanceof RegExp ? function (t, e) {
                            if (!e) return t;
                            var n = t.source.match(/\((?!\?)/g);
                            if (n)
                                for (var i = 0; i < n.length; i++) e.push({
                                    name: i,
                                    prefix: null,
                                    delimiter: null,
                                    optional: !1,
                                    repeat: !1,
                                    pattern: null
                                });
                            return t
                        }(t, e) : Array.isArray(t) ? function (t, e, n) {
                            for (var i = [], r = 0; r < t.length; r++) i.push(P(t[r], e, n).source);
                            return new RegExp("(?:" + i.join("|") + ")", T(n))
                        }(t, e, n) : function (t, e, n) {
                            return A(b(t, n), e, n)
                        }(t, e, n)
                    }
                    p.match = function (t, e) {
                        var n = [];
                        return S(P(t, n, e), n)
                    }, p.regexpToFunction = m, p.parse = g, p.compile = function (t, e) {
                        return E(b(t, e), e)
                    }, p.tokensToFunction = v, p.tokensToRegExp = _;
                    var C = {
                            container: "container",
                            history: "history",
                            namespace: "namespace",
                            prefix: "data-barba",
                            prevent: "prevent",
                            wrapper: "wrapper"
                        },
                        R = new(function () {
                            function t() {
                                this.o = C, this.u = new DOMParser
                            }
                            var e = t.prototype;
                            return e.toString = function (t) {
                                return t.outerHTML
                            }, e.toDocument = function (t) {
                                return this.u.parseFromString(t, "text/html")
                            }, e.toElement = function (t) {
                                var e = document.createElement("div");
                                return e.innerHTML = t, e
                            }, e.getHtml = function (t) {
                                return void 0 === t && (t = document), this.toString(t.documentElement)
                            }, e.getWrapper = function (t) {
                                return void 0 === t && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]')
                            }, e.getContainer = function (t) {
                                return void 0 === t && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]')
                            }, e.removeContainer = function (t) {
                                document.body.contains(t) && t.parentNode.removeChild(t)
                            }, e.addContainer = function (t, e) {
                                var n = this.getContainer();
                                n ? this.s(t, n) : e.appendChild(t)
                            }, e.getNamespace = function (t) {
                                void 0 === t && (t = document);
                                var e = t.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
                                return e ? e.getAttribute(this.o.prefix + "-" + this.o.namespace) : null
                            }, e.getHref = function (t) {
                                if (t.tagName && "a" === t.tagName.toLowerCase()) {
                                    if ("string" == typeof t.href) return t.href;
                                    var e = t.getAttribute("href") || t.getAttribute("xlink:href");
                                    if (e) return this.resolveUrl(e.baseVal || e)
                                }
                                return null
                            }, e.resolveUrl = function () {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                var i = e.length;
                                if (0 === i) throw new Error("resolveUrl requires at least one argument; got none.");
                                var r = document.createElement("base");
                                if (r.href = arguments[0], 1 === i) return r.href;
                                var s = document.getElementsByTagName("head")[0];
                                s.insertBefore(r, s.firstChild);
                                for (var o, a = document.createElement("a"), l = 1; l < i; l++) a.href = arguments[l], r.href = o = a.href;
                                return s.removeChild(r), o
                            }, e.s = function (t, e) {
                                e.parentNode.insertBefore(t, e.nextSibling)
                            }, t
                        }()),
                        L = new(function () {
                            function t() {
                                this.h = [], this.v = -1
                            }
                            var i = t.prototype;
                            return i.init = function (t, e) {
                                this.l = "barba";
                                var n = {
                                    ns: e,
                                    scroll: {
                                        x: window.scrollX,
                                        y: window.scrollY
                                    },
                                    url: t
                                };
                                this.h.push(n), this.v = 0;
                                var i = {
                                    from: this.l,
                                    index: 0,
                                    states: [].concat(this.h)
                                };
                                window.history && window.history.replaceState(i, "", t)
                            }, i.change = function (t, e, n) {
                                if (n && n.state) {
                                    var i = n.state,
                                        r = i.index;
                                    e = this.m(this.v - r), this.replace(i.states), this.v = r
                                } else this.add(t, e);
                                return e
                            }, i.add = function (t, e) {
                                var n = this.size,
                                    i = this.p(e),
                                    r = {
                                        ns: "tmp",
                                        scroll: {
                                            x: window.scrollX,
                                            y: window.scrollY
                                        },
                                        url: t
                                    };
                                this.h.push(r), this.v = n;
                                var s = {
                                    from: this.l,
                                    index: n,
                                    states: [].concat(this.h)
                                };
                                switch (i) {
                                    case "push":
                                        window.history && window.history.pushState(s, "", t);
                                        break;
                                    case "replace":
                                        window.history && window.history.replaceState(s, "", t)
                                }
                            }, i.update = function (t, e) {
                                var i = e || this.v,
                                    r = n({}, this.get(i), {}, t);
                                this.set(i, r)
                            }, i.remove = function (t) {
                                t ? this.h.splice(t, 1) : this.h.pop(), this.v--
                            }, i.clear = function () {
                                this.h = [], this.v = -1
                            }, i.replace = function (t) {
                                this.h = t
                            }, i.get = function (t) {
                                return this.h[t]
                            }, i.set = function (t, e) {
                                return this.h[t] = e
                            }, i.p = function (t) {
                                var e = "push",
                                    n = t,
                                    i = C.prefix + "-" + C.history;
                                return n.hasAttribute && n.hasAttribute(i) && (e = n.getAttribute(i)), e
                            }, i.m = function (t) {
                                return Math.abs(t) > 1 ? t > 0 ? "forward" : "back" : 0 === t ? "popstate" : t > 0 ? "back" : "forward"
                            }, e(t, [{
                                key: "current",
                                get: function () {
                                    return this.h[this.v]
                                }
                            }, {
                                key: "state",
                                get: function () {
                                    return this.h[this.h.length - 1]
                                }
                            }, {
                                key: "previous",
                                get: function () {
                                    return this.v < 1 ? null : this.h[this.v - 1]
                                }
                            }, {
                                key: "size",
                                get: function () {
                                    return this.h.length
                                }
                            }]), t
                        }()),
                        O = function (t, e) {
                            try {
                                var n = function () {
                                    if (!e.next.html) return Promise.resolve(t).then((function (t) {
                                        var n = e.next;
                                        if (t) {
                                            var i = R.toElement(t);
                                            n.namespace = R.getNamespace(i), n.container = R.getContainer(i), n.html = t, L.update({
                                                ns: n.namespace
                                            });
                                            var r = R.toDocument(t);
                                            document.title = r.title
                                        }
                                    }))
                                }();
                                return Promise.resolve(n && n.then ? n.then((function () {})) : void 0)
                            } catch (t) {
                                return Promise.reject(t)
                            }
                        },
                        I = p,
                        D = {
                            __proto__: null,
                            update: O,
                            nextTick: function () {
                                return new Promise((function (t) {
                                    window.requestAnimationFrame(t)
                                }))
                            },
                            pathToRegexp: I
                        },
                        N = function () {
                            return window.location.origin
                        },
                        U = function (t) {
                            return void 0 === t && (t = window.location.href), k(t).port
                        },
                        k = function (t) {
                            var e, n = t.match(/:\d+/);
                            if (null === n) /^http/.test(t) && (e = 80), /^https/.test(t) && (e = 443);
                            else {
                                var i = n[0].substring(1);
                                e = parseInt(i, 10)
                            }
                            var r, s = t.replace(N(), ""),
                                o = {},
                                a = s.indexOf("#");
                            a >= 0 && (r = s.slice(a + 1), s = s.slice(0, a));
                            var l = s.indexOf("?");
                            return l >= 0 && (o = F(s.slice(l + 1)), s = s.slice(0, l)), {
                                hash: r,
                                path: s,
                                port: e,
                                query: o
                            }
                        },
                        F = function (t) {
                            return t.split("&").reduce((function (t, e) {
                                var n = e.split("=");
                                return t[n[0]] = n[1], t
                            }), {})
                        },
                        z = function (t) {
                            return void 0 === t && (t = window.location.href), t.replace(/(\/#.*|\/|#.*)$/, "")
                        },
                        B = {
                            __proto__: null,
                            getHref: function () {
                                return window.location.href
                            },
                            getOrigin: N,
                            getPort: U,
                            getPath: function (t) {
                                return void 0 === t && (t = window.location.href), k(t).path
                            },
                            parse: k,
                            parseQuery: F,
                            clean: z
                        };

                    function H(t, e, n) {
                        return void 0 === e && (e = 2e3), new Promise((function (i, r) {
                            var s = new XMLHttpRequest;
                            s.onreadystatechange = function () {
                                if (s.readyState === XMLHttpRequest.DONE)
                                    if (200 === s.status) i(s.responseText);
                                    else if (s.status) {
                                    var e = {
                                        status: s.status,
                                        statusText: s.statusText
                                    };
                                    n(t, e), r(e)
                                }
                            }, s.ontimeout = function () {
                                var i = new Error("Timeout error [" + e + "]");
                                n(t, i), r(i)
                            }, s.onerror = function () {
                                var e = new Error("Fetch error");
                                n(t, e), r(e)
                            }, s.open("GET", t), s.timeout = e, s.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), s.setRequestHeader("x-barba", "yes"), s.send()
                        }))
                    }
                    var V = function (t) {
                        return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then
                    };

                    function G(t, e) {
                        return void 0 === e && (e = {}),
                            function () {
                                for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                var s = !1,
                                    o = new Promise((function (n, r) {
                                        e.async = function () {
                                            return s = !0,
                                                function (t, e) {
                                                    t ? r(t) : n(e)
                                                }
                                        };
                                        var o = t.apply(e, i);
                                        s || (V(o) ? o.then(n, r) : n(o))
                                    }));
                                return o
                            }
                    }
                    var W = new(function (t) {
                            function e() {
                                var e;
                                return (e = t.call(this) || this).logger = new f("@barba/core"), e.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], e.registered = new Map, e.init(), e
                            }
                            i(e, t);
                            var n = e.prototype;
                            return n.init = function () {
                                var t = this;
                                this.registered.clear(), this.all.forEach((function (e) {
                                    t[e] || (t[e] = function (n, i) {
                                        t.registered.has(e) || t.registered.set(e, new Set), t.registered.get(e).add({
                                            ctx: i || {},
                                            fn: n
                                        })
                                    })
                                }))
                            }, n.do = function (t) {
                                for (var e = this, n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                                if (this.registered.has(t)) {
                                    var s = Promise.resolve();
                                    return this.registered.get(t).forEach((function (t) {
                                        s = s.then((function () {
                                            return G(t.fn, t.ctx).apply(void 0, i)
                                        }))
                                    })), s.catch((function (n) {
                                        e.logger.debug("Hook error [" + t + "]"), e.logger.error(n)
                                    }))
                                }
                                return Promise.resolve()
                            }, n.clear = function () {
                                var t = this;
                                this.all.forEach((function (e) {
                                    delete t[e]
                                })), this.init()
                            }, n.help = function () {
                                this.logger.info("Available hooks: " + this.all.join(","));
                                var t = [];
                                this.registered.forEach((function (e, n) {
                                    return t.push(n)
                                })), this.logger.info("Registered hooks: " + t.join(","))
                            }, e
                        }(h)),
                        j = function () {
                            function t(t) {
                                if (this.P = [], "boolean" == typeof t) this.g = t;
                                else {
                                    var e = Array.isArray(t) ? t : [t];
                                    this.P = e.map((function (t) {
                                        return I(t)
                                    }))
                                }
                            }
                            return t.prototype.checkHref = function (t) {
                                if ("boolean" == typeof this.g) return this.g;
                                var e = k(t).path;
                                return this.P.some((function (t) {
                                    return null !== t.exec(e)
                                }))
                            }, t
                        }(),
                        X = function (t) {
                            function e(e) {
                                var n;
                                return (n = t.call(this, e) || this).k = new Map, n
                            }
                            i(e, t);
                            var r = e.prototype;
                            return r.set = function (t, e, n) {
                                return this.k.set(t, {
                                    action: n,
                                    request: e
                                }), {
                                    action: n,
                                    request: e
                                }
                            }, r.get = function (t) {
                                return this.k.get(t)
                            }, r.getRequest = function (t) {
                                return this.k.get(t).request
                            }, r.getAction = function (t) {
                                return this.k.get(t).action
                            }, r.has = function (t) {
                                return !this.checkHref(t) && this.k.has(t)
                            }, r.delete = function (t) {
                                return this.k.delete(t)
                            }, r.update = function (t, e) {
                                var i = n({}, this.k.get(t), {}, e);
                                return this.k.set(t, i), i
                            }, e
                        }(j),
                        q = function () {
                            return !window.history.pushState
                        },
                        Y = function (t) {
                            return !t.el || !t.href
                        },
                        K = function (t) {
                            var e = t.event;
                            return e.which > 1 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey
                        },
                        Z = function (t) {
                            var e = t.el;
                            return e.hasAttribute("target") && "_blank" === e.target
                        },
                        J = function (t) {
                            var e = t.el;
                            return void 0 !== e.protocol && window.location.protocol !== e.protocol || void 0 !== e.hostname && window.location.hostname !== e.hostname
                        },
                        $ = function (t) {
                            var e = t.el;
                            return void 0 !== e.port && U() !== U(e.href)
                        },
                        Q = function (t) {
                            var e = t.el;
                            return e.getAttribute && "string" == typeof e.getAttribute("download")
                        },
                        tt = function (t) {
                            return t.el.hasAttribute(C.prefix + "-" + C.prevent)
                        },
                        et = function (t) {
                            return Boolean(t.el.closest("[" + C.prefix + "-" + C.prevent + '="all"]'))
                        },
                        nt = function (t) {
                            var e = t.href;
                            return z(e) === z() && U(e) === U()
                        },
                        it = function (t) {
                            function e(e) {
                                var n;
                                return (n = t.call(this, e) || this).suite = [], n.tests = new Map, n.init(), n
                            }
                            i(e, t);
                            var n = e.prototype;
                            return n.init = function () {
                                this.add("pushState", q), this.add("exists", Y), this.add("newTab", K), this.add("blank", Z), this.add("corsDomain", J), this.add("corsPort", $), this.add("download", Q), this.add("preventSelf", tt), this.add("preventAll", et), this.add("sameUrl", nt, !1)
                            }, n.add = function (t, e, n) {
                                void 0 === n && (n = !0), this.tests.set(t, e), n && this.suite.push(t)
                            }, n.run = function (t, e, n, i) {
                                return this.tests.get(t)({
                                    el: e,
                                    event: n,
                                    href: i
                                })
                            }, n.checkLink = function (t, e, n) {
                                var i = this;
                                return this.suite.some((function (r) {
                                    return i.run(r, t, e, n)
                                }))
                            }, e
                        }(j),
                        rt = function (t) {
                            function e(n, i) {
                                var r;
                                void 0 === i && (i = "Barba error");
                                for (var s = arguments.length, o = new Array(s > 2 ? s - 2 : 0), a = 2; a < s; a++) o[a - 2] = arguments[a];
                                return (r = t.call.apply(t, [this].concat(o)) || this).error = n, r.label = i, Error.captureStackTrace && Error.captureStackTrace(function (t) {
                                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                    return t
                                }(r), e), r.name = "BarbaError", r
                            }
                            return i(e, t), e
                        }(a(Error)),
                        st = function () {
                            function t(t) {
                                void 0 === t && (t = []), this.logger = new f("@barba/core"), this.all = [], this.page = [], this.once = [], this.A = [{
                                    name: "namespace",
                                    type: "strings"
                                }, {
                                    name: "custom",
                                    type: "function"
                                }], t && (this.all = this.all.concat(t)), this.update()
                            }
                            var e = t.prototype;
                            return e.add = function (t, e) {
                                "rule" === t ? this.A.splice(e.position || 0, 0, e.value) : this.all.push(e), this.update()
                            }, e.resolve = function (t, e) {
                                var n = this;
                                void 0 === e && (e = {});
                                var i = e.once ? this.once : this.page;
                                i = i.filter(e.self ? function (t) {
                                    return t.name && "self" === t.name
                                } : function (t) {
                                    return !t.name || "self" !== t.name
                                });
                                var r = new Map,
                                    s = i.find((function (i) {
                                        var s = !0,
                                            o = {};
                                        return !(!e.self || "self" !== i.name) || (n.A.reverse().forEach((function (e) {
                                            s && (s = n.R(i, e, t, o), i.from && i.to && (s = n.R(i, e, t, o, "from") && n.R(i, e, t, o, "to")), i.from && !i.to && (s = n.R(i, e, t, o, "from")), !i.from && i.to && (s = n.R(i, e, t, o, "to")))
                                        })), r.set(i, o), s)
                                    })),
                                    o = r.get(s),
                                    a = [];
                                if (a.push(e.once ? "once" : "page"), e.self && a.push("self"), o) {
                                    var l, c = [s];
                                    Object.keys(o).length > 0 && c.push(o), (l = this.logger).info.apply(l, ["Transition found [" + a.join(",") + "]"].concat(c))
                                } else this.logger.info("No transition found [" + a.join(",") + "]");
                                return s
                            }, e.update = function () {
                                var t = this;
                                this.all = this.all.map((function (e) {
                                    return t.T(e)
                                })).sort((function (t, e) {
                                    return t.priority - e.priority
                                })).reverse().map((function (t) {
                                    return delete t.priority, t
                                })), this.page = this.all.filter((function (t) {
                                    return void 0 !== t.leave || void 0 !== t.enter
                                })), this.once = this.all.filter((function (t) {
                                    return void 0 !== t.once
                                }))
                            }, e.R = function (t, e, n, i, r) {
                                var s = !0,
                                    o = !1,
                                    a = t,
                                    l = e.name,
                                    c = l,
                                    u = l,
                                    h = l,
                                    d = r ? a[r] : a,
                                    f = "to" === r ? n.next : n.current;
                                if (r ? d && d[l] : d[l]) {
                                    switch (e.type) {
                                        case "strings":
                                        default:
                                            var p = Array.isArray(d[c]) ? d[c] : [d[c]];
                                            f[c] && -1 !== p.indexOf(f[c]) && (o = !0), -1 === p.indexOf(f[c]) && (s = !1);
                                            break;
                                        case "object":
                                            var m = Array.isArray(d[u]) ? d[u] : [d[u]];
                                            f[u] ? (f[u].name && -1 !== m.indexOf(f[u].name) && (o = !0), -1 === m.indexOf(f[u].name) && (s = !1)) : s = !1;
                                            break;
                                        case "function":
                                            d[h](n) ? o = !0 : s = !1
                                    }
                                    o && (r ? (i[r] = i[r] || {}, i[r][l] = a[r][l]) : i[l] = a[l])
                                }
                                return s
                            }, e.O = function (t, e, n) {
                                var i = 0;
                                return (t[e] || t.from && t.from[e] || t.to && t.to[e]) && (i += Math.pow(10, n), t.from && t.from[e] && (i += 1), t.to && t.to[e] && (i += 2)), i
                            }, e.T = function (t) {
                                var e = this;
                                t.priority = 0;
                                var n = 0;
                                return this.A.forEach((function (i, r) {
                                    n += e.O(t, i.name, r + 1)
                                })), t.priority = n, t
                            }, t
                        }(),
                        ot = function () {
                            function t(t) {
                                void 0 === t && (t = []), this.logger = new f("@barba/core"), this.S = !1, this.store = new st(t)
                            }
                            var n = t.prototype;
                            return n.get = function (t, e) {
                                return this.store.resolve(t, e)
                            }, n.doOnce = function (t) {
                                var e = t.data,
                                    n = t.transition;
                                try {
                                    var i = function () {
                                            r.S = !1
                                        },
                                        r = this,
                                        s = n || {};
                                    r.S = !0;
                                    var o = l((function () {
                                        return Promise.resolve(r.j("beforeOnce", e, s)).then((function () {
                                            return Promise.resolve(r.once(e, s)).then((function () {
                                                return Promise.resolve(r.j("afterOnce", e, s)).then((function () {}))
                                            }))
                                        }))
                                    }), (function (t) {
                                        r.S = !1, r.logger.debug("Transition error [before/after/once]"), r.logger.error(t)
                                    }));
                                    return Promise.resolve(o && o.then ? o.then(i) : i())
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.doPage = function (t) {
                                var e = t.data,
                                    n = t.transition,
                                    i = t.page,
                                    r = t.wrapper;
                                try {
                                    var s = function (t) {
                                            if (o) return t;
                                            a.S = !1
                                        },
                                        o = !1,
                                        a = this,
                                        c = n || {},
                                        u = !0 === c.sync || !1;
                                    a.S = !0;
                                    var h = l((function () {
                                        function t() {
                                            return Promise.resolve(a.j("before", e, c)).then((function () {
                                                var t = !1;

                                                function n(n) {
                                                    return t ? n : Promise.resolve(a.remove(e)).then((function () {
                                                        return Promise.resolve(a.j("after", e, c)).then((function () {}))
                                                    }))
                                                }
                                                var s = function () {
                                                    if (u) return l((function () {
                                                        return Promise.resolve(a.add(e, r)).then((function () {
                                                            return Promise.resolve(a.j("beforeLeave", e, c)).then((function () {
                                                                return Promise.resolve(a.j("beforeEnter", e, c)).then((function () {
                                                                    return Promise.resolve(Promise.all([a.leave(e, c), a.enter(e, c)])).then((function () {
                                                                        return Promise.resolve(a.j("afterLeave", e, c)).then((function () {
                                                                            return Promise.resolve(a.j("afterEnter", e, c)).then((function () {}))
                                                                        }))
                                                                    }))
                                                                }))
                                                            }))
                                                        }))
                                                    }), (function (t) {
                                                        if (a.M(t)) throw new rt(t, "Transition error [sync]")
                                                    }));
                                                    var n = function (n) {
                                                            return t ? n : l((function () {
                                                                var t = function () {
                                                                    if (!1 !== s) return Promise.resolve(a.add(e, r)).then((function () {
                                                                        return Promise.resolve(a.j("beforeEnter", e, c)).then((function () {
                                                                            return Promise.resolve(a.enter(e, c, s)).then((function () {
                                                                                return Promise.resolve(a.j("afterEnter", e, c)).then((function () {}))
                                                                            }))
                                                                        }))
                                                                    }))
                                                                }();
                                                                if (t && t.then) return t.then((function () {}))
                                                            }), (function (t) {
                                                                if (a.M(t)) throw new rt(t, "Transition error [before/after/enter]")
                                                            }))
                                                        },
                                                        s = !1,
                                                        o = l((function () {
                                                            return Promise.resolve(a.j("beforeLeave", e, c)).then((function () {
                                                                return Promise.resolve(Promise.all([a.leave(e, c), O(i, e)]).then((function (t) {
                                                                    return t[0]
                                                                }))).then((function (t) {
                                                                    return s = t, Promise.resolve(a.j("afterLeave", e, c)).then((function () {}))
                                                                }))
                                                            }))
                                                        }), (function (t) {
                                                            if (a.M(t)) throw new rt(t, "Transition error [before/after/leave]")
                                                        }));
                                                    return o && o.then ? o.then(n) : n(o)
                                                }();
                                                return s && s.then ? s.then(n) : n(s)
                                            }))
                                        }
                                        var n = function () {
                                            if (u) return Promise.resolve(O(i, e)).then((function () {}))
                                        }();
                                        return n && n.then ? n.then(t) : t()
                                    }), (function (t) {
                                        if (a.S = !1, t.name && "BarbaError" === t.name) throw a.logger.debug(t.label), a.logger.error(t.error), t;
                                        throw a.logger.debug("Transition error [page]"), a.logger.error(t), t
                                    }));
                                    return Promise.resolve(h && h.then ? h.then(s) : s(h))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.once = function (t, e) {
                                try {
                                    return Promise.resolve(W.do("once", t, e)).then((function () {
                                        return e.once ? G(e.once, e)(t) : Promise.resolve()
                                    }))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.leave = function (t, e) {
                                try {
                                    return Promise.resolve(W.do("leave", t, e)).then((function () {
                                        return e.leave ? G(e.leave, e)(t) : Promise.resolve()
                                    }))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.enter = function (t, e, n) {
                                try {
                                    return Promise.resolve(W.do("enter", t, e)).then((function () {
                                        return e.enter ? G(e.enter, e)(t, n) : Promise.resolve()
                                    }))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.add = function (t, e) {
                                try {
                                    return R.addContainer(t.next.container, e), W.do("nextAdded", t), Promise.resolve()
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.remove = function (t) {
                                try {
                                    return R.removeContainer(t.current.container), W.do("currentRemoved", t), Promise.resolve()
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.M = function (t) {
                                return t.message ? !/Timeout error|Fetch error/.test(t.message) : !t.status
                            }, n.j = function (t, e, n) {
                                try {
                                    return Promise.resolve(W.do(t, e, n)).then((function () {
                                        return n[t] ? G(n[t], n)(e) : Promise.resolve()
                                    }))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, e(t, [{
                                key: "isRunning",
                                get: function () {
                                    return this.S
                                },
                                set: function (t) {
                                    this.S = t
                                }
                            }, {
                                key: "hasOnce",
                                get: function () {
                                    return this.store.once.length > 0
                                }
                            }, {
                                key: "hasSelf",
                                get: function () {
                                    return this.store.all.some((function (t) {
                                        return "self" === t.name
                                    }))
                                }
                            }, {
                                key: "shouldWait",
                                get: function () {
                                    return this.store.all.some((function (t) {
                                        return t.to && !t.to.route || t.sync
                                    }))
                                }
                            }]), t
                        }(),
                        at = function () {
                            function t(t) {
                                var e = this;
                                this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = new Map, 0 !== t.length && (t.forEach((function (t) {
                                    e.byNamespace.set(t.namespace, t)
                                })), this.names.forEach((function (t) {
                                    W[t](e.L(t))
                                })))
                            }
                            return t.prototype.L = function (t) {
                                var e = this;
                                return function (n) {
                                    var i = t.match(/enter/i) ? n.next : n.current,
                                        r = e.byNamespace.get(i.namespace);
                                    return r && r[t] ? G(r[t], r)(n) : Promise.resolve()
                                }
                            }, t
                        }();
                    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (t) {
                        var e = this;
                        do {
                            if (e.matches(t)) return e;
                            e = e.parentElement || e.parentNode
                        } while (null !== e && 1 === e.nodeType);
                        return null
                    });
                    var lt = {
                        container: null,
                        html: "",
                        namespace: "",
                        url: {
                            hash: "",
                            href: "",
                            path: "",
                            port: null,
                            query: {}
                        }
                    };
                    return new(function () {
                        function t() {
                            this.version = u, this.schemaPage = lt, this.Logger = f, this.logger = new f("@barba/core"), this.plugins = [], this.hooks = W, this.dom = R, this.helpers = D, this.history = L, this.request = H, this.url = B
                        }
                        var i = t.prototype;
                        return i.use = function (t, e) {
                            var n = this.plugins;
                            n.indexOf(t) > -1 ? this.logger.warn("Plugin [" + t.name + "] already installed.") : "function" == typeof t.install ? (t.install(this, e), n.push(t)) : this.logger.warn("Plugin [" + t.name + '] has no "install" method.')
                        }, i.init = function (t) {
                            var e = void 0 === t ? {} : t,
                                i = e.transitions,
                                r = void 0 === i ? [] : i,
                                s = e.views,
                                o = void 0 === s ? [] : s,
                                a = e.schema,
                                l = void 0 === a ? C : a,
                                c = e.requestError,
                                u = e.timeout,
                                h = void 0 === u ? 2e3 : u,
                                d = e.cacheIgnore,
                                p = void 0 !== d && d,
                                m = e.prefetchIgnore,
                                g = void 0 !== m && m,
                                v = e.preventRunning,
                                _ = void 0 !== v && v,
                                y = e.prevent,
                                x = void 0 === y ? null : y,
                                b = e.debug,
                                S = e.logLevel;
                            if (f.setLevel(!0 === (void 0 !== b && b) ? "debug" : void 0 === S ? "off" : S), this.logger.info(this.version), Object.keys(l).forEach((function (t) {
                                    C[t] && (C[t] = l[t])
                                })), this.$ = c, this.timeout = h, this.cacheIgnore = p, this.prefetchIgnore = g, this.preventRunning = _, this._ = this.dom.getWrapper(), !this._) throw new Error("[@barba/core] No Barba wrapper found");
                            this._.setAttribute("aria-live", "polite"), this.q();
                            var E = this.data.current;
                            if (!E.container) throw new Error("[@barba/core] No Barba container found");
                            if (this.cache = new X(p), this.prevent = new it(g), this.transitions = new ot(r), this.views = new at(o), null !== x) {
                                if ("function" != typeof x) throw new Error("[@barba/core] Prevent should be a function");
                                this.prevent.add("preventCustom", x)
                            }
                            this.history.init(E.url.href, E.namespace), this.B = this.B.bind(this), this.U = this.U.bind(this), this.D = this.D.bind(this), this.F(), this.plugins.forEach((function (t) {
                                return t.init()
                            }));
                            var M = this.data;
                            M.trigger = "barba", M.next = M.current, M.current = n({}, this.schemaPage), this.hooks.do("ready", M), this.once(M), this.q()
                        }, i.destroy = function () {
                            this.q(), this.H(), this.history.clear(), this.hooks.clear(), this.plugins = []
                        }, i.force = function (t) {
                            window.location.assign(t)
                        }, i.go = function (t, e, n) {
                            var i;
                            if (void 0 === e && (e = "barba"), this.transitions.isRunning) this.force(t);
                            else if (!(i = "popstate" === e ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t) : this.prevent.run("sameUrl", null, null, t)) || this.transitions.hasSelf) return e = this.history.change(t, e, n), n && (n.stopPropagation(), n.preventDefault()), this.page(t, e, i)
                        }, i.once = function (t) {
                            try {
                                var e = this;
                                return Promise.resolve(e.hooks.do("beforeEnter", t)).then((function () {
                                    function n() {
                                        return Promise.resolve(e.hooks.do("afterEnter", t)).then((function () {}))
                                    }
                                    var i = function () {
                                        if (e.transitions.hasOnce) {
                                            var n = e.transitions.get(t, {
                                                once: !0
                                            });
                                            return Promise.resolve(e.transitions.doOnce({
                                                transition: n,
                                                data: t
                                            })).then((function () {}))
                                        }
                                    }();
                                    return i && i.then ? i.then(n) : n()
                                }))
                            } catch (t) {
                                return Promise.reject(t)
                            }
                        }, i.page = function (t, e, i) {
                            try {
                                var r = function () {
                                        var t = s.data;
                                        return Promise.resolve(s.hooks.do("page", t)).then((function () {
                                            var e = l((function () {
                                                var e = s.transitions.get(t, {
                                                    once: !1,
                                                    self: i
                                                });
                                                return Promise.resolve(s.transitions.doPage({
                                                    data: t,
                                                    page: o,
                                                    transition: e,
                                                    wrapper: s._
                                                })).then((function () {
                                                    s.q()
                                                }))
                                            }), (function () {
                                                0 === f.getLevel() && s.force(t.current.url.href)
                                            }));
                                            if (e && e.then) return e.then((function () {}))
                                        }))
                                    },
                                    s = this;
                                s.data.next.url = n({
                                    href: t
                                }, s.url.parse(t)), s.data.trigger = e;
                                var o = s.cache.has(t) ? s.cache.update(t, {
                                        action: "click"
                                    }).request : s.cache.set(t, s.request(t, s.timeout, s.onRequestError.bind(s, e)), "click").request,
                                    a = function () {
                                        if (s.transitions.shouldWait) return Promise.resolve(O(o, s.data)).then((function () {}))
                                    }();
                                return Promise.resolve(a && a.then ? a.then(r) : r())
                            } catch (t) {
                                return Promise.reject(t)
                            }
                        }, i.onRequestError = function (t) {
                            this.transitions.isRunning = !1;
                            for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
                            var r = n[0],
                                s = n[1],
                                o = this.cache.getAction(r);
                            return this.cache.delete(r), !(this.$ && !1 === this.$(t, o, r, s) || ("click" === o && this.force(r), 1))
                        }, i.prefetch = function (t) {
                            var e = this;
                            this.cache.has(t) || this.cache.set(t, this.request(t, this.timeout, this.onRequestError.bind(this, "barba")).catch((function (t) {
                                e.logger.error(t)
                            })), "prefetch")
                        }, i.F = function () {
                            !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.B), document.addEventListener("touchstart", this.B)), document.addEventListener("click", this.U), window.addEventListener("popstate", this.D)
                        }, i.H = function () {
                            !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.B), document.removeEventListener("touchstart", this.B)), document.removeEventListener("click", this.U), window.removeEventListener("popstate", this.D)
                        }, i.B = function (t) {
                            var e = this,
                                n = this.I(t);
                            if (n) {
                                var i = this.dom.getHref(n);
                                this.prevent.checkHref(i) || this.cache.has(i) || this.cache.set(i, this.request(i, this.timeout, this.onRequestError.bind(this, n)).catch((function (t) {
                                    e.logger.error(t)
                                })), "enter")
                            }
                        }, i.U = function (t) {
                            var e = this.I(t);
                            if (e) return this.transitions.isRunning && this.preventRunning ? (t.preventDefault(), void t.stopPropagation()) : void this.go(this.dom.getHref(e), e, t)
                        }, i.D = function (t) {
                            this.go(this.url.getHref(), "popstate", t)
                        }, i.I = function (t) {
                            for (var e = t.target; e && !this.dom.getHref(e);) e = e.parentNode;
                            if (e && !this.prevent.checkLink(e, t, this.dom.getHref(e))) return e
                        }, i.q = function () {
                            var t = this.url.getHref(),
                                e = {
                                    container: this.dom.getContainer(),
                                    html: this.dom.getHtml(),
                                    namespace: this.dom.getNamespace(),
                                    url: n({
                                        href: t
                                    }, this.url.parse(t))
                                };
                            this.C = {
                                current: e,
                                next: n({}, this.schemaPage),
                                trigger: void 0
                            }, this.hooks.do("reset", this.data)
                        }, e(t, [{
                            key: "data",
                            get: function () {
                                return this.C
                            }
                        }, {
                            key: "wrapper",
                            get: function () {
                                return this._
                            }
                        }]), t
                    }())
                }()
            },
            158: function (t) {
                var e, n;
                e = "undefined" != typeof window ? window : this, n = function () {
                    function t() {}
                    let e = t.prototype;
                    return e.on = function (t, e) {
                        if (!t || !e) return this;
                        let n = this._events = this._events || {},
                            i = n[t] = n[t] || [];
                        return i.includes(e) || i.push(e), this
                    }, e.once = function (t, e) {
                        if (!t || !e) return this;
                        this.on(t, e);
                        let n = this._onceEvents = this._onceEvents || {};
                        return (n[t] = n[t] || {})[e] = !0, this
                    }, e.off = function (t, e) {
                        let n = this._events && this._events[t];
                        if (!n || !n.length) return this;
                        let i = n.indexOf(e);
                        return -1 != i && n.splice(i, 1), this
                    }, e.emitEvent = function (t, e) {
                        let n = this._events && this._events[t];
                        if (!n || !n.length) return this;
                        n = n.slice(0), e = e || [];
                        let i = this._onceEvents && this._onceEvents[t];
                        for (let r of n) i && i[r] && (this.off(t, r), delete i[r]), r.apply(this, e);
                        return this
                    }, e.allOff = function () {
                        return delete this._events, delete this._onceEvents, this
                    }, t
                }, t.exports ? t.exports = n() : e.EvEmitter = n()
            },
            47: function (t) {
                var e, n;
                e = this, n = function (t) {
                    let e = {
                            extend: function (t, e) {
                                return Object.assign(t, e)
                            },
                            modulo: function (t, e) {
                                return (t % e + e) % e
                            },
                            makeArray: function (t) {
                                return Array.isArray(t) ? t : null == t ? [] : "object" == typeof t && "number" == typeof t.length ? [...t] : [t]
                            },
                            removeFrom: function (t, e) {
                                let n = t.indexOf(e); - 1 != n && t.splice(n, 1)
                            },
                            getParent: function (t, e) {
                                for (; t.parentNode && t != document.body;)
                                    if ((t = t.parentNode).matches(e)) return t
                            },
                            getQueryElement: function (t) {
                                return "string" == typeof t ? document.querySelector(t) : t
                            },
                            handleEvent: function (t) {
                                let e = "on" + t.type;
                                this[e] && this[e](t)
                            },
                            filterFindElements: function (t, n) {
                                return (t = e.makeArray(t)).filter((t => t instanceof HTMLElement)).reduce(((t, e) => {
                                    if (!n) return t.push(e), t;
                                    e.matches(n) && t.push(e);
                                    let i = e.querySelectorAll(n);
                                    return t = t.concat(...i)
                                }), [])
                            },
                            debounceMethod: function (t, e, n) {
                                n = n || 100;
                                let i = t.prototype[e],
                                    r = e + "Timeout";
                                t.prototype[e] = function () {
                                    clearTimeout(this[r]);
                                    let t = arguments;
                                    this[r] = setTimeout((() => {
                                        i.apply(this, t), delete this[r]
                                    }), n)
                                }
                            },
                            docReady: function (t) {
                                let e = document.readyState;
                                "complete" == e || "interactive" == e ? setTimeout(t) : document.addEventListener("DOMContentLoaded", t)
                            },
                            toDashed: function (t) {
                                return t.replace(/(.)([A-Z])/g, (function (t, e, n) {
                                    return e + "-" + n
                                })).toLowerCase()
                            }
                        },
                        n = t.console;
                    return e.htmlInit = function (i, r) {
                        e.docReady((function () {
                            let s = "data-" + e.toDashed(r),
                                o = document.querySelectorAll(`[${s}]`),
                                a = t.jQuery;
                            [...o].forEach((t => {
                                let e, o = t.getAttribute(s);
                                try {
                                    e = o && JSON.parse(o)
                                } catch (e) {
                                    return void(n && n.error(`Error parsing ${s} on ${t.className}: ${e}`))
                                }
                                let l = new i(t, e);
                                a && a.data(t, r, l)
                            }))
                        }))
                    }, e
                }, t.exports ? t.exports = n(e) : e.fizzyUIUtils = n(e)
            },
            597: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(n(680), n(47)) : i(e.Flickity, e.fizzyUIUtils)
                }("undefined" != typeof window ? window : this, (function (t, e) {
                    let n = t.prototype;
                    return n.insert = function (t, e) {
                        let n = this._makeCells(t);
                        if (!n || !n.length) return;
                        let i = this.cells.length;
                        e = void 0 === e ? i : e;
                        let r = function (t) {
                                let e = document.createDocumentFragment();
                                return t.forEach((t => e.appendChild(t.element))), e
                            }(n),
                            s = e === i;
                        if (s) this.slider.appendChild(r);
                        else {
                            let t = this.cells[e].element;
                            this.slider.insertBefore(r, t)
                        }
                        if (0 === e) this.cells = n.concat(this.cells);
                        else if (s) this.cells = this.cells.concat(n);
                        else {
                            let t = this.cells.splice(e, i - e);
                            this.cells = this.cells.concat(n).concat(t)
                        }
                        this._sizeCells(n), this.cellChange(e), this.positionSliderAtSelected()
                    }, n.append = function (t) {
                        this.insert(t, this.cells.length)
                    }, n.prepend = function (t) {
                        this.insert(t, 0)
                    }, n.remove = function (t) {
                        let n = this.getCells(t);
                        if (!n || !n.length) return;
                        let i = this.cells.length - 1;
                        n.forEach((t => {
                            t.remove();
                            let n = this.cells.indexOf(t);
                            i = Math.min(n, i), e.removeFrom(this.cells, t)
                        })), this.cellChange(i), this.positionSliderAtSelected()
                    }, n.cellSizeChange = function (t) {
                        let e = this.getCell(t);
                        if (!e) return;
                        e.getSize();
                        let n = this.cells.indexOf(e);
                        this.cellChange(n)
                    }, n.cellChange = function (t) {
                        let e = this.selectedElement;
                        this._positionCells(t), this._updateWrapShiftCells(), this.setGallerySize();
                        let n = this.getCell(e);
                        n && (this.selectedIndex = this.getCellSlideIndex(n)), this.selectedIndex = Math.min(this.slides.length - 1, this.selectedIndex), this.emitEvent("cellChange", [t]), this.select(this.selectedIndex)
                    }, t
                }))
            },
            880: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(n(47)) : (e.Flickity = e.Flickity || {}, e.Flickity.animatePrototype = i(e.fizzyUIUtils))
                }("undefined" != typeof window ? window : this, (function (t) {
                    let e = {
                        startAnimation: function () {
                            this.isAnimating || (this.isAnimating = !0, this.restingFrames = 0, this.animate())
                        },
                        animate: function () {
                            this.applyDragForce(), this.applySelectedAttraction();
                            let t = this.x;
                            this.integratePhysics(), this.positionSlider(), this.settle(t), this.isAnimating && requestAnimationFrame((() => this.animate()))
                        },
                        positionSlider: function () {
                            let e = this.x;
                            this.isWrapping && (e = t.modulo(e, this.slideableWidth) - this.slideableWidth, this.shiftWrapCells(e)), this.setTranslateX(e, this.isAnimating), this.dispatchScrollEvent()
                        },
                        setTranslateX: function (t, e) {
                            t += this.cursorPosition, this.options.rightToLeft && (t = -t);
                            let n = this.getPositionValue(t);
                            this.slider.style.transform = e ? `translate3d(${n},0,0)` : `translateX(${n})`
                        },
                        dispatchScrollEvent: function () {
                            let t = this.slides[0];
                            if (!t) return;
                            let e = -this.x - t.target,
                                n = e / this.slidesWidth;
                            this.dispatchEvent("scroll", null, [n, e])
                        },
                        positionSliderAtSelected: function () {
                            this.cells.length && (this.x = -this.selectedSlide.target, this.velocity = 0, this.positionSlider())
                        },
                        getPositionValue: function (t) {
                            return this.options.percentPosition ? .01 * Math.round(t / this.size.innerWidth * 1e4) + "%" : Math.round(t) + "px"
                        },
                        settle: function (t) {
                            !this.isPointerDown && Math.round(100 * this.x) === Math.round(100 * t) && this.restingFrames++, this.restingFrames > 2 && (this.isAnimating = !1, delete this.isFreeScrolling, this.positionSlider(), this.dispatchEvent("settle", null, [this.selectedIndex]))
                        },
                        shiftWrapCells: function (t) {
                            let e = this.cursorPosition + t;
                            this._shiftCells(this.beforeShiftCells, e, -1);
                            let n = this.size.innerWidth - (t + this.slideableWidth + this.cursorPosition);
                            this._shiftCells(this.afterShiftCells, n, 1)
                        },
                        _shiftCells: function (t, e, n) {
                            t.forEach((t => {
                                let i = e > 0 ? n : 0;
                                this._wrapShiftCell(t, i), e -= t.size.outerWidth
                            }))
                        },
                        _unshiftCells: function (t) {
                            t && t.length && t.forEach((t => this._wrapShiftCell(t, 0)))
                        },
                        _wrapShiftCell: function (t, e) {
                            this._renderCellPosition(t, t.x + this.slideableWidth * e)
                        },
                        integratePhysics: function () {
                            this.x += this.velocity, this.velocity *= this.getFrictionFactor()
                        },
                        applyForce: function (t) {
                            this.velocity += t
                        },
                        getFrictionFactor: function () {
                            return 1 - this.options[this.isFreeScrolling ? "freeScrollFriction" : "friction"]
                        },
                        getRestingPosition: function () {
                            return this.x + this.velocity / (1 - this.getFrictionFactor())
                        },
                        applyDragForce: function () {
                            if (!this.isDraggable || !this.isPointerDown) return;
                            let t = this.dragX - this.x - this.velocity;
                            this.applyForce(t)
                        },
                        applySelectedAttraction: function () {
                            if (this.isDraggable && this.isPointerDown || this.isFreeScrolling || !this.slides.length) return;
                            let t = (-1 * this.selectedSlide.target - this.x) * this.options.selectedAttraction;
                            this.applyForce(t)
                        }
                    };
                    return e
                }))
            },
            229: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(n(131)) : (e.Flickity = e.Flickity || {}, e.Flickity.Cell = i(e.getSize))
                }("undefined" != typeof window ? window : this, (function (t) {
                    const e = "flickity-cell";

                    function n(t) {
                        this.element = t, this.element.classList.add(e), this.x = 0, this.unselect()
                    }
                    let i = n.prototype;
                    return i.destroy = function () {
                        this.unselect(), this.element.classList.remove(e), this.element.style.transform = "", this.element.removeAttribute("aria-hidden")
                    }, i.getSize = function () {
                        this.size = t(this.element)
                    }, i.select = function () {
                        this.element.classList.add("is-selected"), this.element.removeAttribute("aria-hidden")
                    }, i.unselect = function () {
                        this.element.classList.remove("is-selected"), this.element.setAttribute("aria-hidden", "true")
                    }, i.remove = function () {
                        this.element.remove()
                    }, n
                }))
            },
            680: function (t, e, n) {
                ! function (e, i) {
                    if (t.exports) t.exports = i(e, n(158), n(131), n(47), n(229), n(714), n(880));
                    else {
                        let t = e.Flickity;
                        e.Flickity = i(e, e.EvEmitter, e.getSize, e.fizzyUIUtils, t.Cell, t.Slide, t.animatePrototype)
                    }
                }("undefined" != typeof window ? window : this, (function (t, e, n, i, r, s, o) {
                    const {
                        getComputedStyle: a,
                        console: l
                    } = t;
                    let {
                        jQuery: c
                    } = t, u = 0, h = {};

                    function d(t, e) {
                        let n = i.getQueryElement(t);
                        if (n) {
                            if (this.element = n, this.element.flickityGUID) {
                                let t = h[this.element.flickityGUID];
                                return t && t.option(e), t
                            }
                            c && (this.$element = c(this.element)), this.options = {
                                ...this.constructor.defaults
                            }, this.option(e), this._create()
                        } else l && l.error(`Bad element for Flickity: ${n||t}`)
                    }
                    d.defaults = {
                        accessibility: !0,
                        cellAlign: "center",
                        freeScrollFriction: .075,
                        friction: .28,
                        namespaceJQueryEvents: !0,
                        percentPosition: !0,
                        resize: !0,
                        selectedAttraction: .025,
                        setGallerySize: !0
                    }, d.create = {};
                    let f = d.prototype;
                    Object.assign(f, e.prototype), f._create = function () {
                        let {
                            resize: e,
                            watchCSS: n,
                            rightToLeft: i
                        } = this.options, r = this.guid = ++u;
                        this.element.flickityGUID = r, h[r] = this, this.selectedIndex = 0, this.restingFrames = 0, this.x = 0, this.velocity = 0, this.beginMargin = i ? "marginRight" : "marginLeft", this.endMargin = i ? "marginLeft" : "marginRight", this.viewport = document.createElement("div"), this.viewport.className = "flickity-viewport", this._createSlider(), this.focusableElems = [this.element], (e || n) && t.addEventListener("resize", this);
                        for (let t in this.options.on) {
                            let e = this.options.on[t];
                            this.on(t, e)
                        }
                        for (let t in d.create) d.create[t].call(this);
                        n ? this.watchCSS() : this.activate()
                    }, f.option = function (t) {
                        Object.assign(this.options, t)
                    }, f.activate = function () {
                        if (this.isActive) return;
                        this.isActive = !0, this.element.classList.add("flickity-enabled"), this.options.rightToLeft && this.element.classList.add("flickity-rtl"), this.getSize();
                        let t = this._filterFindCellElements(this.element.children);
                        this.slider.append(...t), this.viewport.append(this.slider), this.element.append(this.viewport), this.reloadCells(), this.options.accessibility && (this.element.tabIndex = 0, this.element.addEventListener("keydown", this)), this.emitEvent("activate"), this.selectInitialIndex(), this.isInitActivated = !0, this.dispatchEvent("ready")
                    }, f._createSlider = function () {
                        let t = document.createElement("div");
                        t.className = "flickity-slider", this.slider = t
                    }, f._filterFindCellElements = function (t) {
                        return i.filterFindElements(t, this.options.cellSelector)
                    }, f.reloadCells = function () {
                        this.cells = this._makeCells(this.slider.children), this.positionCells(), this._updateWrapShiftCells(), this.setGallerySize()
                    }, f._makeCells = function (t) {
                        return this._filterFindCellElements(t).map((t => new r(t)))
                    }, f.getLastCell = function () {
                        return this.cells[this.cells.length - 1]
                    }, f.getLastSlide = function () {
                        return this.slides[this.slides.length - 1]
                    }, f.positionCells = function () {
                        this._sizeCells(this.cells), this._positionCells(0)
                    }, f._positionCells = function (t) {
                        t = t || 0, this.maxCellHeight = t && this.maxCellHeight || 0;
                        let e = 0;
                        if (t > 0) {
                            let n = this.cells[t - 1];
                            e = n.x + n.size.outerWidth
                        }
                        this.cells.slice(t).forEach((t => {
                            t.x = e, this._renderCellPosition(t, e), e += t.size.outerWidth, this.maxCellHeight = Math.max(t.size.outerHeight, this.maxCellHeight)
                        })), this.slideableWidth = e, this.updateSlides(), this._containSlides(), this.slidesWidth = this.cells.length ? this.getLastSlide().target - this.slides[0].target : 0
                    }, f._renderCellPosition = function (t, e) {
                        let n = e * (this.options.rightToLeft ? -1 : 1);
                        this.options.percentPosition && (n *= this.size.innerWidth / t.size.width);
                        let i = this.getPositionValue(n);
                        t.element.style.transform = `translateX( ${i} )`
                    }, f._sizeCells = function (t) {
                        t.forEach((t => t.getSize()))
                    }, f.updateSlides = function () {
                        if (this.slides = [], !this.cells.length) return;
                        let {
                            beginMargin: t,
                            endMargin: e
                        } = this, n = new s(t, e, this.cellAlign);
                        this.slides.push(n);
                        let i = this._getCanCellFit();
                        this.cells.forEach(((r, o) => {
                            if (!n.cells.length) return void n.addCell(r);
                            let a = n.outerWidth - n.firstMargin + (r.size.outerWidth - r.size[e]);
                            i(o, a) || (n.updateTarget(), n = new s(t, e, this.cellAlign), this.slides.push(n)), n.addCell(r)
                        })), n.updateTarget(), this.updateSelectedSlide()
                    }, f._getCanCellFit = function () {
                        let {
                            groupCells: t
                        } = this.options;
                        if (!t) return () => !1;
                        if ("number" == typeof t) {
                            let e = parseInt(t, 10);
                            return t => t % e != 0
                        }
                        let e = 1,
                            n = "string" == typeof t && t.match(/^(\d+)%$/);
                        n && (e = parseInt(n[1], 10) / 100);
                        let i = (this.size.innerWidth + 1) * e;
                        return (t, e) => e <= i
                    }, f._init = f.reposition = function () {
                        this.positionCells(), this.positionSliderAtSelected()
                    }, f.getSize = function () {
                        this.size = n(this.element), this.setCellAlign(), this.cursorPosition = this.size.innerWidth * this.cellAlign
                    };
                    let p = {
                        left: 0,
                        center: .5,
                        right: 1
                    };
                    f.setCellAlign = function () {
                        let {
                            cellAlign: t,
                            rightToLeft: e
                        } = this.options, n = p[t];
                        this.cellAlign = void 0 !== n ? n : t, e && (this.cellAlign = 1 - this.cellAlign)
                    }, f.setGallerySize = function () {
                        if (!this.options.setGallerySize) return;
                        let t = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight;
                        this.viewport.style.height = `${t}px`
                    }, f._updateWrapShiftCells = function () {
                        if (this.isWrapping = this.getIsWrapping(), !this.isWrapping) return;
                        this._unshiftCells(this.beforeShiftCells), this._unshiftCells(this.afterShiftCells);
                        let t = this.cursorPosition,
                            e = this.cells.length - 1;
                        this.beforeShiftCells = this._getGapCells(t, e, -1);
                        let n = this.size.innerWidth - this.cursorPosition;
                        this.afterShiftCells = this._getGapCells(n, 0, 1)
                    }, f.getIsWrapping = function () {
                        let {
                            wrapAround: t
                        } = this.options;
                        if (!t || this.slides.length < 2) return !1;
                        if ("fill" !== t) return !0;
                        let e = this.slideableWidth - this.size.innerWidth;
                        if (e > this.size.innerWidth) return !0;
                        for (let t of this.cells)
                            if (t.size.outerWidth > e) return !1;
                        return !0
                    }, f._getGapCells = function (t, e, n) {
                        let i = [];
                        for (; t > 0;) {
                            let r = this.cells[e];
                            if (!r) break;
                            i.push(r), e += n, t -= r.size.outerWidth
                        }
                        return i
                    }, f._containSlides = function () {
                        if (!(this.options.contain && !this.isWrapping && this.cells.length)) return;
                        let t = this.slideableWidth - this.getLastCell().size[this.endMargin];
                        if (t < this.size.innerWidth) this.slides.forEach((e => {
                            e.target = t * this.cellAlign
                        }));
                        else {
                            let e = this.cursorPosition + this.cells[0].size[this.beginMargin],
                                n = t - this.size.innerWidth * (1 - this.cellAlign);
                            this.slides.forEach((t => {
                                t.target = Math.max(t.target, e), t.target = Math.min(t.target, n)
                            }))
                        }
                    }, f.dispatchEvent = function (t, e, n) {
                        let i = e ? [e].concat(n) : n;
                        if (this.emitEvent(t, i), c && this.$element) {
                            let i = t += this.options.namespaceJQueryEvents ? ".flickity" : "";
                            if (e) {
                                let n = new c.Event(e);
                                n.type = t, i = n
                            }
                            this.$element.trigger(i, n)
                        }
                    };
                    const m = ["dragStart", "dragMove", "dragEnd", "pointerDown", "pointerMove", "pointerEnd", "staticClick"];
                    let g = f.emitEvent;
                    f.emitEvent = function (t, e) {
                        if ("staticClick" === t) {
                            let t = this.getParentCell(e[0].target),
                                n = t && t.element,
                                i = t && this.cells.indexOf(t);
                            e = e.concat(n, i)
                        }
                        if (g.call(this, t, e), !m.includes(t) || !c || !this.$element) return;
                        t += this.options.namespaceJQueryEvents ? ".flickity" : "";
                        let n = e.shift(0),
                            i = new c.Event(n);
                        i.type = t, this.$element.trigger(i, e)
                    }, f.select = function (t, e, n) {
                        if (!this.isActive) return;
                        if (t = parseInt(t, 10), this._wrapSelect(t), (this.isWrapping || e) && (t = i.modulo(t, this.slides.length)), !this.slides[t]) return;
                        let r = this.selectedIndex;
                        this.selectedIndex = t, this.updateSelectedSlide(), n ? this.positionSliderAtSelected() : this.startAnimation(), this.options.adaptiveHeight && this.setGallerySize(), this.dispatchEvent("select", null, [t]), t !== r && this.dispatchEvent("change", null, [t])
                    }, f._wrapSelect = function (t) {
                        if (!this.isWrapping) return;
                        const {
                            selectedIndex: e,
                            slideableWidth: n,
                            slides: {
                                length: r
                            }
                        } = this;
                        if (!this.isDragSelect) {
                            let n = i.modulo(t, r),
                                s = Math.abs(n - e),
                                o = Math.abs(n + r - e),
                                a = Math.abs(n - r - e);
                            o < s ? t += r : a < s && (t -= r)
                        }
                        t < 0 ? this.x -= n : t >= r && (this.x += n)
                    }, f.previous = function (t, e) {
                        this.select(this.selectedIndex - 1, t, e)
                    }, f.next = function (t, e) {
                        this.select(this.selectedIndex + 1, t, e)
                    }, f.updateSelectedSlide = function () {
                        let t = this.slides[this.selectedIndex];
                        t && (this.unselectSelectedSlide(), this.selectedSlide = t, t.select(), this.selectedCells = t.cells, this.selectedElements = t.getCellElements(), this.selectedCell = t.cells[0], this.selectedElement = this.selectedElements[0])
                    }, f.unselectSelectedSlide = function () {
                        this.selectedSlide && this.selectedSlide.unselect()
                    }, f.selectInitialIndex = function () {
                        let t = this.options.initialIndex;
                        if (this.isInitActivated) return void this.select(this.selectedIndex, !1, !0);
                        if (t && "string" == typeof t) {
                            if (this.queryCell(t)) return void this.selectCell(t, !1, !0)
                        }
                        let e = 0;
                        t && this.slides[t] && (e = t), this.select(e, !1, !0)
                    }, f.selectCell = function (t, e, n) {
                        let i = this.queryCell(t);
                        if (!i) return;
                        let r = this.getCellSlideIndex(i);
                        this.select(r, e, n)
                    }, f.getCellSlideIndex = function (t) {
                        let e = this.slides.find((e => e.cells.includes(t)));
                        return this.slides.indexOf(e)
                    }, f.getCell = function (t) {
                        for (let e of this.cells)
                            if (e.element === t) return e
                    }, f.getCells = function (t) {
                        return (t = i.makeArray(t)).map((t => this.getCell(t))).filter(Boolean)
                    }, f.getCellElements = function () {
                        return this.cells.map((t => t.element))
                    }, f.getParentCell = function (t) {
                        let e = this.getCell(t);
                        if (e) return e;
                        let n = t.closest(".flickity-slider > *");
                        return this.getCell(n)
                    }, f.getAdjacentCellElements = function (t, e) {
                        if (!t) return this.selectedSlide.getCellElements();
                        e = void 0 === e ? this.selectedIndex : e;
                        let n = this.slides.length;
                        if (1 + 2 * t >= n) return this.getCellElements();
                        let r = [];
                        for (let s = e - t; s <= e + t; s++) {
                            let t = this.isWrapping ? i.modulo(s, n) : s,
                                e = this.slides[t];
                            e && (r = r.concat(e.getCellElements()))
                        }
                        return r
                    }, f.queryCell = function (t) {
                        if ("number" == typeof t) return this.cells[t];
                        return "string" == typeof t && !t.match(/^[#.]?[\d/]/) && (t = this.element.querySelector(t)), this.getCell(t)
                    }, f.uiChange = function () {
                        this.emitEvent("uiChange")
                    }, f.onresize = function () {
                        this.watchCSS(), this.resize()
                    }, i.debounceMethod(d, "onresize", 150), f.resize = function () {
                        if (!this.isActive || this.isAnimating || this.isDragging) return;
                        this.getSize(), this.isWrapping && (this.x = i.modulo(this.x, this.slideableWidth)), this.positionCells(), this._updateWrapShiftCells(), this.setGallerySize(), this.emitEvent("resize");
                        let t = this.selectedElements && this.selectedElements[0];
                        this.selectCell(t, !1, !0)
                    }, f.watchCSS = function () {
                        if (!this.options.watchCSS) return;
                        a(this.element, ":after").content.includes("flickity") ? this.activate() : this.deactivate()
                    }, f.onkeydown = function (t) {
                        let {
                            activeElement: e
                        } = document, n = d.keyboardHandlers[t.key];
                        this.options.accessibility && e && n && this.focusableElems.some((t => e === t)) && n.call(this)
                    }, d.keyboardHandlers = {
                        ArrowLeft: function () {
                            this.uiChange(), this[this.options.rightToLeft ? "next" : "previous"]()
                        },
                        ArrowRight: function () {
                            this.uiChange(), this[this.options.rightToLeft ? "previous" : "next"]()
                        }
                    }, f.focus = function () {
                        this.element.focus({
                            preventScroll: !0
                        })
                    }, f.deactivate = function () {
                        this.isActive && (this.element.classList.remove("flickity-enabled"), this.element.classList.remove("flickity-rtl"), this.unselectSelectedSlide(), this.cells.forEach((t => t.destroy())), this.viewport.remove(), this.element.append(...this.slider.children), this.options.accessibility && (this.element.removeAttribute("tabIndex"), this.element.removeEventListener("keydown", this)), this.isActive = !1, this.emitEvent("deactivate"))
                    }, f.destroy = function () {
                        this.deactivate(), t.removeEventListener("resize", this), this.allOff(), this.emitEvent("destroy"), c && this.$element && c.removeData(this.element, "flickity"), delete this.element.flickityGUID, delete h[this.guid]
                    }, Object.assign(f, o), d.data = function (t) {
                        if (t = i.getQueryElement(t)) return h[t.flickityGUID]
                    }, i.htmlInit(d, "flickity");
                    let {
                        jQueryBridget: v
                    } = t;
                    return c && v && v("flickity", d, c), d.setJQuery = function (t) {
                        c = t
                    }, d.Cell = r, d.Slide = s, d
                }))
            },
            690: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(e, n(680), n(842), n(47)) : e.Flickity = i(e, e.Flickity, e.Unidragger, e.fizzyUIUtils)
                }("undefined" != typeof window ? window : this, (function (t, e, n, i) {
                    Object.assign(e.defaults, {
                        draggable: ">1",
                        dragThreshold: 3
                    });
                    let r = e.prototype;

                    function s() {
                        return {
                            x: t.pageXOffset,
                            y: t.pageYOffset
                        }
                    }
                    return Object.assign(r, n.prototype), r.touchActionValue = "", e.create.drag = function () {
                        this.on("activate", this.onActivateDrag), this.on("uiChange", this._uiChangeDrag), this.on("deactivate", this.onDeactivateDrag), this.on("cellChange", this.updateDraggable), this.on("pointerDown", this.handlePointerDown), this.on("pointerUp", this.handlePointerUp), this.on("pointerDown", this.handlePointerDone), this.on("dragStart", this.handleDragStart), this.on("dragMove", this.handleDragMove), this.on("dragEnd", this.handleDragEnd), this.on("staticClick", this.handleStaticClick)
                    }, r.onActivateDrag = function () {
                        this.handles = [this.viewport], this.bindHandles(), this.updateDraggable()
                    }, r.onDeactivateDrag = function () {
                        this.unbindHandles(), this.element.classList.remove("is-draggable")
                    }, r.updateDraggable = function () {
                        ">1" === this.options.draggable ? this.isDraggable = this.slides.length > 1 : this.isDraggable = this.options.draggable, this.element.classList.toggle("is-draggable", this.isDraggable)
                    }, r._uiChangeDrag = function () {
                        delete this.isFreeScrolling
                    }, r.handlePointerDown = function (e) {
                        if (!this.isDraggable) return void this.bindActivePointerEvents(e);
                        let n = "touchstart" === e.type,
                            i = "touch" === e.pointerType,
                            r = e.target.matches("input, textarea, select");
                        n || i || r || e.preventDefault(), r || this.focus(), document.activeElement !== this.element && document.activeElement.blur(), this.dragX = this.x, this.viewport.classList.add("is-pointer-down"), this.pointerDownScroll = s(), t.addEventListener("scroll", this), this.bindActivePointerEvents(e)
                    }, r.hasDragStarted = function (t) {
                        return Math.abs(t.x) > this.options.dragThreshold
                    }, r.handlePointerUp = function () {
                        delete this.isTouchScrolling, this.viewport.classList.remove("is-pointer-down")
                    }, r.handlePointerDone = function () {
                        t.removeEventListener("scroll", this), delete this.pointerDownScroll
                    }, r.handleDragStart = function () {
                        this.isDraggable && (this.dragStartPosition = this.x, this.startAnimation(), t.removeEventListener("scroll", this))
                    }, r.handleDragMove = function (t, e, n) {
                        if (!this.isDraggable) return;
                        t.preventDefault(), this.previousDragX = this.dragX;
                        let i = this.options.rightToLeft ? -1 : 1;
                        this.isWrapping && (n.x %= this.slideableWidth);
                        let r = this.dragStartPosition + n.x * i;
                        if (!this.isWrapping) {
                            let t = Math.max(-this.slides[0].target, this.dragStartPosition);
                            r = r > t ? .5 * (r + t) : r;
                            let e = Math.min(-this.getLastSlide().target, this.dragStartPosition);
                            r = r < e ? .5 * (r + e) : r
                        }
                        this.dragX = r, this.dragMoveTime = new Date
                    }, r.handleDragEnd = function () {
                        if (!this.isDraggable) return;
                        let {
                            freeScroll: t
                        } = this.options;
                        t && (this.isFreeScrolling = !0);
                        let e = this.dragEndRestingSelect();
                        if (t && !this.isWrapping) {
                            let t = this.getRestingPosition();
                            this.isFreeScrolling = -t > this.slides[0].target && -t < this.getLastSlide().target
                        } else t || e !== this.selectedIndex || (e += this.dragEndBoostSelect());
                        delete this.previousDragX, this.isDragSelect = this.isWrapping, this.select(e), delete this.isDragSelect
                    }, r.dragEndRestingSelect = function () {
                        let t = this.getRestingPosition(),
                            e = Math.abs(this.getSlideDistance(-t, this.selectedIndex)),
                            n = this._getClosestResting(t, e, 1),
                            i = this._getClosestResting(t, e, -1);
                        return n.distance < i.distance ? n.index : i.index
                    }, r._getClosestResting = function (t, e, n) {
                        let i = this.selectedIndex,
                            r = 1 / 0,
                            s = this.options.contain && !this.isWrapping ? (t, e) => t <= e : (t, e) => t < e;
                        for (; s(e, r) && (i += n, r = e, null !== (e = this.getSlideDistance(-t, i)));) e = Math.abs(e);
                        return {
                            distance: r,
                            index: i - n
                        }
                    }, r.getSlideDistance = function (t, e) {
                        let n = this.slides.length,
                            r = this.options.wrapAround && n > 1,
                            s = r ? i.modulo(e, n) : e,
                            o = this.slides[s];
                        if (!o) return null;
                        let a = r ? this.slideableWidth * Math.floor(e / n) : 0;
                        return t - (o.target + a)
                    }, r.dragEndBoostSelect = function () {
                        if (void 0 === this.previousDragX || !this.dragMoveTime || new Date - this.dragMoveTime > 100) return 0;
                        let t = this.getSlideDistance(-this.dragX, this.selectedIndex),
                            e = this.previousDragX - this.dragX;
                        return t > 0 && e > 0 ? 1 : t < 0 && e < 0 ? -1 : 0
                    }, r.onscroll = function () {
                        let t = s(),
                            e = this.pointerDownScroll.x - t.x,
                            n = this.pointerDownScroll.y - t.y;
                        (Math.abs(e) > 3 || Math.abs(n) > 3) && this.pointerDone()
                    }, e
                }))
            },
            835: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(n(680), n(564)) : i(e.Flickity, e.imagesLoaded)
                }("undefined" != typeof window ? window : this, (function (t, e) {
                    return t.create.imagesLoaded = function () {
                        this.on("activate", this.imagesLoaded)
                    }, t.prototype.imagesLoaded = function () {
                        if (!this.options.imagesLoaded) return;
                        e(this.slider).on("progress", ((t, e) => {
                            let n = this.getParentCell(e.img);
                            this.cellSizeChange(n && n.element), this.options.freeScroll || this.positionSliderAtSelected()
                        }))
                    }, t
                }))
            },
            442: (t, e, n) => {
                if (t.exports) {
                    const e = n(680);
                    n(690), n(410), n(573), n(516), n(597), n(227), n(835), t.exports = e
                }
            },
            227: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(n(680), n(47)) : i(e.Flickity, e.fizzyUIUtils)
                }("undefined" != typeof window ? window : this, (function (t, e) {
                    const n = "data-flickity-lazyload",
                        i = `${n}-src`,
                        r = `${n}-srcset`,
                        s = `img[${n}], img[${i}], img[${r}], source[${r}]`;
                    t.create.lazyLoad = function () {
                        this.on("select", this.lazyLoad), this.handleLazyLoadComplete = this.onLazyLoadComplete.bind(this)
                    };
                    let o = t.prototype;

                    function a(t) {
                        if (t.matches("img")) {
                            let e = t.getAttribute(n),
                                s = t.getAttribute(i),
                                o = t.getAttribute(r);
                            if (e || s || o) return t
                        }
                        return [...t.querySelectorAll(s)]
                    }

                    function l(t, e) {
                        this.img = t, this.onComplete = e, this.load()
                    }
                    return o.lazyLoad = function () {
                        let {
                            lazyLoad: t
                        } = this.options;
                        if (!t) return;
                        let e = "number" == typeof t ? t : 0;
                        this.getAdjacentCellElements(e).map(a).flat().forEach((t => new l(t, this.handleLazyLoadComplete)))
                    }, o.onLazyLoadComplete = function (t, e) {
                        let n = this.getParentCell(t),
                            i = n && n.element;
                        this.cellSizeChange(i), this.dispatchEvent("lazyLoad", e, i)
                    }, l.prototype.handleEvent = e.handleEvent, l.prototype.load = function () {
                        this.img.addEventListener("load", this), this.img.addEventListener("error", this);
                        let t = this.img.getAttribute(n) || this.img.getAttribute(i),
                            e = this.img.getAttribute(r);
                        this.img.src = t, e && this.img.setAttribute("srcset", e), this.img.removeAttribute(n), this.img.removeAttribute(i), this.img.removeAttribute(r)
                    }, l.prototype.onload = function (t) {
                        this.complete(t, "flickity-lazyloaded")
                    }, l.prototype.onerror = function (t) {
                        this.complete(t, "flickity-lazyerror")
                    }, l.prototype.complete = function (t, e) {
                        this.img.removeEventListener("load", this), this.img.removeEventListener("error", this), (this.img.parentNode.matches("picture") ? this.img.parentNode : this.img).classList.add(e), this.onComplete(this.img, t)
                    }, t.LazyLoader = l, t
                }))
            },
            573: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(n(680), n(47)) : i(e.Flickity, e.fizzyUIUtils)
                }("undefined" != typeof window ? window : this, (function (t, e) {
                    function n() {
                        this.holder = document.createElement("div"), this.holder.className = "flickity-page-dots", this.dots = []
                    }
                    n.prototype.setDots = function (t) {
                        let e = t - this.dots.length;
                        e > 0 ? this.addDots(e) : e < 0 && this.removeDots(-e)
                    }, n.prototype.addDots = function (t) {
                        let e = new Array(t).fill().map(((t, e) => {
                            let n = document.createElement("button");
                            n.setAttribute("type", "button");
                            let i = e + 1 + this.dots.length;
                            return n.className = "flickity-page-dot", n.textContent = `View slide ${i}`, n
                        }));
                        this.holder.append(...e), this.dots = this.dots.concat(e)
                    }, n.prototype.removeDots = function (t) {
                        this.dots.splice(this.dots.length - t, t).forEach((t => t.remove()))
                    }, n.prototype.updateSelected = function (t) {
                        this.selectedDot && (this.selectedDot.classList.remove("is-selected"), this.selectedDot.removeAttribute("aria-current")), this.dots.length && (this.selectedDot = this.dots[t], this.selectedDot.classList.add("is-selected"), this.selectedDot.setAttribute("aria-current", "step"))
                    }, t.PageDots = n, Object.assign(t.defaults, {
                        pageDots: !0
                    }), t.create.pageDots = function () {
                        this.options.pageDots && (this.pageDots = new n, this.handlePageDotsClick = this.onPageDotsClick.bind(this), this.on("activate", this.activatePageDots), this.on("select", this.updateSelectedPageDots), this.on("cellChange", this.updatePageDots), this.on("resize", this.updatePageDots), this.on("deactivate", this.deactivatePageDots))
                    };
                    let i = t.prototype;
                    return i.activatePageDots = function () {
                        this.pageDots.setDots(this.slides.length), this.focusableElems.push(...this.pageDots.dots), this.pageDots.holder.addEventListener("click", this.handlePageDotsClick), this.element.append(this.pageDots.holder)
                    }, i.onPageDotsClick = function (t) {
                        let e = this.pageDots.dots.indexOf(t.target); - 1 !== e && (this.uiChange(), this.select(e))
                    }, i.updateSelectedPageDots = function () {
                        this.pageDots.updateSelected(this.selectedIndex)
                    }, i.updatePageDots = function () {
                        this.pageDots.dots.forEach((t => {
                            e.removeFrom(this.focusableElems, t)
                        })), this.pageDots.setDots(this.slides.length), this.focusableElems.push(...this.pageDots.dots)
                    }, i.deactivatePageDots = function () {
                        this.pageDots.holder.remove(), this.pageDots.holder.removeEventListener("click", this.handlePageDotsClick)
                    }, t.PageDots = n, t
                }))
            },
            516: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(n(680)) : i(e.Flickity)
                }("undefined" != typeof window ? window : this, (function (t) {
                    function e(t, e) {
                        this.autoPlay = t, this.onTick = e, this.state = "stopped", this.onVisibilityChange = this.visibilityChange.bind(this), this.onVisibilityPlay = this.visibilityPlay.bind(this)
                    }
                    e.prototype.play = function () {
                        if ("playing" === this.state) return;
                        document.hidden ? document.addEventListener("visibilitychange", this.onVisibilityPlay) : (this.state = "playing", document.addEventListener("visibilitychange", this.onVisibilityChange), this.tick())
                    }, e.prototype.tick = function () {
                        if ("playing" !== this.state) return;
                        let t = "number" == typeof this.autoPlay ? this.autoPlay : 3e3;
                        this.clear(), this.timeout = setTimeout((() => {
                            this.onTick(), this.tick()
                        }), t)
                    }, e.prototype.stop = function () {
                        this.state = "stopped", this.clear(), document.removeEventListener("visibilitychange", this.onVisibilityChange)
                    }, e.prototype.clear = function () {
                        clearTimeout(this.timeout)
                    }, e.prototype.pause = function () {
                        "playing" === this.state && (this.state = "paused", this.clear())
                    }, e.prototype.unpause = function () {
                        "paused" === this.state && this.play()
                    }, e.prototype.visibilityChange = function () {
                        this[document.hidden ? "pause" : "unpause"]()
                    }, e.prototype.visibilityPlay = function () {
                        this.play(), document.removeEventListener("visibilitychange", this.onVisibilityPlay)
                    }, Object.assign(t.defaults, {
                        pauseAutoPlayOnHover: !0
                    }), t.create.player = function () {
                        this.player = new e(this.options.autoPlay, (() => {
                            this.next(!0)
                        })), this.on("activate", this.activatePlayer), this.on("uiChange", this.stopPlayer), this.on("pointerDown", this.stopPlayer), this.on("deactivate", this.deactivatePlayer)
                    };
                    let n = t.prototype;
                    return n.activatePlayer = function () {
                        this.options.autoPlay && (this.player.play(), this.element.addEventListener("mouseenter", this))
                    }, n.playPlayer = function () {
                        this.player.play()
                    }, n.stopPlayer = function () {
                        this.player.stop()
                    }, n.pausePlayer = function () {
                        this.player.pause()
                    }, n.unpausePlayer = function () {
                        this.player.unpause()
                    }, n.deactivatePlayer = function () {
                        this.player.stop(), this.element.removeEventListener("mouseenter", this)
                    }, n.onmouseenter = function () {
                        this.options.pauseAutoPlayOnHover && (this.player.pause(), this.element.addEventListener("mouseleave", this))
                    }, n.onmouseleave = function () {
                        this.player.unpause(), this.element.removeEventListener("mouseleave", this)
                    }, t.Player = e, t
                }))
            },
            410: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(n(680)) : i(e.Flickity)
                }("undefined" != typeof window ? window : this, (function (t) {
                    const e = "http://www.w3.org/2000/svg";

                    function n(t, e, n) {
                        this.increment = t, this.direction = e, this.isPrevious = "previous" === t, this.isLeft = "left" === e, this._create(n)
                    }
                    n.prototype._create = function (t) {
                        let e = this.element = document.createElement("button");
                        e.className = `flickity-button flickity-prev-next-button ${this.increment}`;
                        let n = this.isPrevious ? "Previous" : "Next";
                        e.setAttribute("type", "button"), e.setAttribute("aria-label", n), this.disable();
                        let i = this.createSVG(n, t);
                        e.append(i)
                    }, n.prototype.createSVG = function (t, n) {
                        let i = document.createElementNS(e, "svg");
                        i.setAttribute("class", "flickity-button-icon"), i.setAttribute("viewBox", "0 0 100 100");
                        let r = document.createElementNS(e, "title");
                        r.append(t);
                        let s = document.createElementNS(e, "path"),
                            o = function (t) {
                                if ("string" == typeof t) return t;
                                let {
                                    x0: e,
                                    x1: n,
                                    x2: i,
                                    x3: r,
                                    y1: s,
                                    y2: o
                                } = t;
                                return `M ${e}, 50\n    L ${n}, ${s+50}\n    L ${i}, ${o+50}\n    L ${r}, 50\n    L ${i}, ${50-o}\n    L ${n}, ${50-s}\n    Z`
                            }(n);
                        return s.setAttribute("d", o), s.setAttribute("class", "arrow"), this.isLeft || s.setAttribute("transform", "translate(100, 100) rotate(180)"), i.append(r, s), i
                    }, n.prototype.enable = function () {
                        this.element.removeAttribute("disabled")
                    }, n.prototype.disable = function () {
                        this.element.setAttribute("disabled", !0)
                    }, Object.assign(t.defaults, {
                        prevNextButtons: !0,
                        arrowShape: {
                            x0: 10,
                            x1: 60,
                            y1: 50,
                            x2: 70,
                            y2: 40,
                            x3: 30
                        }
                    }), t.create.prevNextButtons = function () {
                        if (!this.options.prevNextButtons) return;
                        let {
                            rightToLeft: t,
                            arrowShape: e
                        } = this.options, i = t ? "right" : "left", r = t ? "left" : "right";
                        this.prevButton = new n("previous", i, e), this.nextButton = new n("next", r, e), this.focusableElems.push(this.prevButton.element), this.focusableElems.push(this.nextButton.element), this.handlePrevButtonClick = () => {
                            this.uiChange(), this.previous()
                        }, this.handleNextButtonClick = () => {
                            this.uiChange(), this.next()
                        }, this.on("activate", this.activatePrevNextButtons), this.on("select", this.updatePrevNextButtons)
                    };
                    let i = t.prototype;
                    return i.updatePrevNextButtons = function () {
                        let t = this.slides.length ? this.slides.length - 1 : 0;
                        this.updatePrevNextButton(this.prevButton, 0), this.updatePrevNextButton(this.nextButton, t)
                    }, i.updatePrevNextButton = function (t, e) {
                        if (this.isWrapping && this.slides.length > 1) return void t.enable();
                        let n = this.selectedIndex !== e;
                        t[n ? "enable" : "disable"](), !n && document.activeElement === t.element && this.focus()
                    }, i.activatePrevNextButtons = function () {
                        this.prevButton.element.addEventListener("click", this.handlePrevButtonClick), this.nextButton.element.addEventListener("click", this.handleNextButtonClick), this.element.append(this.prevButton.element, this.nextButton.element), this.on("deactivate", this.deactivatePrevNextButtons)
                    }, i.deactivatePrevNextButtons = function () {
                        this.prevButton.element.remove(), this.nextButton.element.remove(), this.prevButton.element.removeEventListener("click", this.handlePrevButtonClick), this.nextButton.element.removeEventListener("click", this.handleNextButtonClick), this.off("deactivate", this.deactivatePrevNextButtons)
                    }, t.PrevNextButton = n, t
                }))
            },
            714: function (t) {
                ! function (e, n) {
                    t.exports ? t.exports = n() : (e.Flickity = e.Flickity || {}, e.Flickity.Slide = n())
                }("undefined" != typeof window ? window : this, (function () {
                    function t(t, e, n) {
                        this.beginMargin = t, this.endMargin = e, this.cellAlign = n, this.cells = [], this.outerWidth = 0, this.height = 0
                    }
                    let e = t.prototype;
                    return e.addCell = function (t) {
                        this.cells.push(t), this.outerWidth += t.size.outerWidth, this.height = Math.max(t.size.outerHeight, this.height), 1 === this.cells.length && (this.x = t.x, this.firstMargin = t.size[this.beginMargin])
                    }, e.updateTarget = function () {
                        let t = this.getLastCell(),
                            e = t ? t.size[this.endMargin] : 0,
                            n = this.outerWidth - (this.firstMargin + e);
                        this.target = this.x + this.firstMargin + n * this.cellAlign
                    }, e.getLastCell = function () {
                        return this.cells[this.cells.length - 1]
                    }, e.select = function () {
                        this.cells.forEach((t => t.select()))
                    }, e.unselect = function () {
                        this.cells.forEach((t => t.unselect()))
                    }, e.getCellElements = function () {
                        return this.cells.map((t => t.element))
                    }, t
                }))
            },
            131: t => {
                ! function (e, n) {
                    t.exports ? t.exports = n() : e.getSize = n()
                }(window, (function () {
                    function t(t) {
                        let e = parseFloat(t);
                        return -1 == t.indexOf("%") && !isNaN(e) && e
                    }
                    let e = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"];
                    e.length;
                    return function (n) {
                        if ("string" == typeof n && (n = document.querySelector(n)), !(n && "object" == typeof n && n.nodeType)) return;
                        let i = getComputedStyle(n);
                        if ("none" == i.display) return function () {
                            let t = {
                                width: 0,
                                height: 0,
                                innerWidth: 0,
                                innerHeight: 0,
                                outerWidth: 0,
                                outerHeight: 0
                            };
                            return e.forEach((e => {
                                t[e] = 0
                            })), t
                        }();
                        let r = {};
                        r.width = n.offsetWidth, r.height = n.offsetHeight;
                        let s = r.isBorderBox = "border-box" == i.boxSizing;
                        e.forEach((t => {
                            let e = i[t],
                                n = parseFloat(e);
                            r[t] = isNaN(n) ? 0 : n
                        }));
                        let o = r.paddingLeft + r.paddingRight,
                            a = r.paddingTop + r.paddingBottom,
                            l = r.marginLeft + r.marginRight,
                            c = r.marginTop + r.marginBottom,
                            u = r.borderLeftWidth + r.borderRightWidth,
                            h = r.borderTopWidth + r.borderBottomWidth,
                            d = t(i.width);
                        !1 !== d && (r.width = d + (s ? 0 : o + u));
                        let f = t(i.height);
                        return !1 !== f && (r.height = f + (s ? 0 : a + h)), r.innerWidth = r.width - (o + u), r.innerHeight = r.height - (a + h), r.outerWidth = r.width + l, r.outerHeight = r.height + c, r
                    }
                }))
            },
            564: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(e, n(158)) : e.imagesLoaded = i(e, e.EvEmitter)
                }("undefined" != typeof window ? window : this, (function (t, e) {
                    let n = t.jQuery,
                        i = t.console;

                    function r(t, e, s) {
                        if (!(this instanceof r)) return new r(t, e, s);
                        let o = t;
                        var a;
                        ("string" == typeof t && (o = document.querySelectorAll(t)), o) ? (this.elements = (a = o, Array.isArray(a) ? a : "object" == typeof a && "number" == typeof a.length ? [...a] : [a]), this.options = {}, "function" == typeof e ? s = e : Object.assign(this.options, e), s && this.on("always", s), this.getImages(), n && (this.jqDeferred = new n.Deferred), setTimeout(this.check.bind(this))) : i.error(`Bad element for imagesLoaded ${o||t}`)
                    }
                    r.prototype = Object.create(e.prototype), r.prototype.getImages = function () {
                        this.images = [], this.elements.forEach(this.addElementImages, this)
                    };
                    const s = [1, 9, 11];
                    r.prototype.addElementImages = function (t) {
                        "IMG" === t.nodeName && this.addImage(t), !0 === this.options.background && this.addElementBackgroundImages(t);
                        let {
                            nodeType: e
                        } = t;
                        if (!e || !s.includes(e)) return;
                        let n = t.querySelectorAll("img");
                        for (let t of n) this.addImage(t);
                        if ("string" == typeof this.options.background) {
                            let e = t.querySelectorAll(this.options.background);
                            for (let t of e) this.addElementBackgroundImages(t)
                        }
                    };
                    const o = /url\((['"])?(.*?)\1\)/gi;

                    function a(t) {
                        this.img = t
                    }

                    function l(t, e) {
                        this.url = t, this.element = e, this.img = new Image
                    }
                    return r.prototype.addElementBackgroundImages = function (t) {
                        let e = getComputedStyle(t);
                        if (!e) return;
                        let n = o.exec(e.backgroundImage);
                        for (; null !== n;) {
                            let i = n && n[2];
                            i && this.addBackground(i, t), n = o.exec(e.backgroundImage)
                        }
                    }, r.prototype.addImage = function (t) {
                        let e = new a(t);
                        this.images.push(e)
                    }, r.prototype.addBackground = function (t, e) {
                        let n = new l(t, e);
                        this.images.push(n)
                    }, r.prototype.check = function () {
                        if (this.progressedCount = 0, this.hasAnyBroken = !1, !this.images.length) return void this.complete();
                        let t = (t, e, n) => {
                            setTimeout((() => {
                                this.progress(t, e, n)
                            }))
                        };
                        this.images.forEach((function (e) {
                            e.once("progress", t), e.check()
                        }))
                    }, r.prototype.progress = function (t, e, n) {
                        this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded, this.emitEvent("progress", [this, t, e]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, t), this.progressedCount === this.images.length && this.complete(), this.options.debug && i && i.log(`progress: ${n}`, t, e)
                    }, r.prototype.complete = function () {
                        let t = this.hasAnyBroken ? "fail" : "done";
                        if (this.isComplete = !0, this.emitEvent(t, [this]), this.emitEvent("always", [this]), this.jqDeferred) {
                            let t = this.hasAnyBroken ? "reject" : "resolve";
                            this.jqDeferred[t](this)
                        }
                    }, a.prototype = Object.create(e.prototype), a.prototype.check = function () {
                        this.getIsImageComplete() ? this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.img.crossOrigin && (this.proxyImage.crossOrigin = this.img.crossOrigin), this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.proxyImage.src = this.img.currentSrc || this.img.src)
                    }, a.prototype.getIsImageComplete = function () {
                        return this.img.complete && this.img.naturalWidth
                    }, a.prototype.confirm = function (t, e) {
                        this.isLoaded = t;
                        let {
                            parentNode: n
                        } = this.img, i = "PICTURE" === n.nodeName ? n : this.img;
                        this.emitEvent("progress", [this, i, e])
                    }, a.prototype.handleEvent = function (t) {
                        let e = "on" + t.type;
                        this[e] && this[e](t)
                    }, a.prototype.onload = function () {
                        this.confirm(!0, "onload"), this.unbindEvents()
                    }, a.prototype.onerror = function () {
                        this.confirm(!1, "onerror"), this.unbindEvents()
                    }, a.prototype.unbindEvents = function () {
                        this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
                    }, l.prototype = Object.create(a.prototype), l.prototype.check = function () {
                        this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents())
                    }, l.prototype.unbindEvents = function () {
                        this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
                    }, l.prototype.confirm = function (t, e) {
                        this.isLoaded = t, this.emitEvent("progress", [this, this.element, e])
                    }, r.makeJQueryPlugin = function (e) {
                        (e = e || t.jQuery) && (n = e, n.fn.imagesLoaded = function (t, e) {
                            return new r(this, t, e).jqDeferred.promise(n(this))
                        })
                    }, r.makeJQueryPlugin(), r
                }))
            },
            842: function (t, e, n) {
                ! function (e, i) {
                    t.exports ? t.exports = i(e, n(158)) : e.Unidragger = i(e, e.EvEmitter)
                }("undefined" != typeof window ? window : this, (function (t, e) {
                    function n() {}
                    let i, r, s = n.prototype = Object.create(e.prototype);
                    s.handleEvent = function (t) {
                        let e = "on" + t.type;
                        this[e] && this[e](t)
                    }, "ontouchstart" in t ? (i = "touchstart", r = ["touchmove", "touchend", "touchcancel"]) : t.PointerEvent ? (i = "pointerdown", r = ["pointermove", "pointerup", "pointercancel"]) : (i = "mousedown", r = ["mousemove", "mouseup"]), s.touchActionValue = "none", s.bindHandles = function () {
                        this._bindHandles("addEventListener", this.touchActionValue)
                    }, s.unbindHandles = function () {
                        this._bindHandles("removeEventListener", "")
                    }, s._bindHandles = function (e, n) {
                        this.handles.forEach((r => {
                            r[e](i, this), r[e]("click", this), t.PointerEvent && (r.style.touchAction = n)
                        }))
                    }, s.bindActivePointerEvents = function () {
                        r.forEach((e => {
                            t.addEventListener(e, this)
                        }))
                    }, s.unbindActivePointerEvents = function () {
                        r.forEach((e => {
                            t.removeEventListener(e, this)
                        }))
                    }, s.withPointer = function (t, e) {
                        e.pointerId === this.pointerIdentifier && this[t](e, e)
                    }, s.withTouch = function (t, e) {
                        let n;
                        for (let t of e.changedTouches) t.identifier === this.pointerIdentifier && (n = t);
                        n && this[t](e, n)
                    }, s.onmousedown = function (t) {
                        this.pointerDown(t, t)
                    }, s.ontouchstart = function (t) {
                        this.pointerDown(t, t.changedTouches[0])
                    }, s.onpointerdown = function (t) {
                        this.pointerDown(t, t)
                    };
                    const o = ["TEXTAREA", "INPUT", "SELECT", "OPTION"],
                        a = ["radio", "checkbox", "button", "submit", "image", "file"];
                    return s.pointerDown = function (t, e) {
                        let n = o.includes(t.target.nodeName),
                            i = a.includes(t.target.type),
                            r = !n || i;
                        !this.isPointerDown && !t.button && r && (this.isPointerDown = !0, this.pointerIdentifier = void 0 !== e.pointerId ? e.pointerId : e.identifier, this.pointerDownPointer = {
                            pageX: e.pageX,
                            pageY: e.pageY
                        }, this.bindActivePointerEvents(), this.emitEvent("pointerDown", [t, e]))
                    }, s.onmousemove = function (t) {
                        this.pointerMove(t, t)
                    }, s.onpointermove = function (t) {
                        this.withPointer("pointerMove", t)
                    }, s.ontouchmove = function (t) {
                        this.withTouch("pointerMove", t)
                    }, s.pointerMove = function (t, e) {
                        let n = {
                            x: e.pageX - this.pointerDownPointer.pageX,
                            y: e.pageY - this.pointerDownPointer.pageY
                        };
                        this.emitEvent("pointerMove", [t, e, n]), !this.isDragging && this.hasDragStarted(n) && this.dragStart(t, e), this.isDragging && this.dragMove(t, e, n)
                    }, s.hasDragStarted = function (t) {
                        return Math.abs(t.x) > 3 || Math.abs(t.y) > 3
                    }, s.dragStart = function (t, e) {
                        this.isDragging = !0, this.isPreventingClicks = !0, this.emitEvent("dragStart", [t, e])
                    }, s.dragMove = function (t, e, n) {
                        this.emitEvent("dragMove", [t, e, n])
                    }, s.onmouseup = function (t) {
                        this.pointerUp(t, t)
                    }, s.onpointerup = function (t) {
                        this.withPointer("pointerUp", t)
                    }, s.ontouchend = function (t) {
                        this.withTouch("pointerUp", t)
                    }, s.pointerUp = function (t, e) {
                        this.pointerDone(), this.emitEvent("pointerUp", [t, e]), this.isDragging ? this.dragEnd(t, e) : this.staticClick(t, e)
                    }, s.dragEnd = function (t, e) {
                        this.isDragging = !1, setTimeout((() => delete this.isPreventingClicks)), this.emitEvent("dragEnd", [t, e])
                    }, s.pointerDone = function () {
                        this.isPointerDown = !1, delete this.pointerIdentifier, this.unbindActivePointerEvents(), this.emitEvent("pointerDone")
                    }, s.onpointercancel = function (t) {
                        this.withPointer("pointerCancel", t)
                    }, s.ontouchcancel = function (t) {
                        this.withTouch("pointerCancel", t)
                    }, s.pointerCancel = function (t, e) {
                        this.pointerDone(), this.emitEvent("pointerCancel", [t, e])
                    }, s.onclick = function (t) {
                        this.isPreventingClicks && t.preventDefault()
                    }, s.staticClick = function (t, e) {
                        let n = "mouseup" === t.type;
                        n && this.isIgnoringMouseUp || (this.emitEvent("staticClick", [t, e]), n && (this.isIgnoringMouseUp = !0, setTimeout((() => {
                            delete this.isIgnoringMouseUp
                        }), 400)))
                    }, n
                }))
            }
        },
        e = {};

    function n(i) {
        var r = e[i];
        if (void 0 !== r) return r.exports;
        var s = e[i] = {
            exports: {}
        };
        return t[i].call(s.exports, s, s.exports, n), s.exports
    }
    n.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return n.d(e, {
            a: e
        }), e
    }, n.d = (t, e) => {
        for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
            enumerable: !0,
            get: e[i]
        })
    }, n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), (() => {
        "use strict";
        var t = n(69),
            e = n.n(t);

        function i(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function r(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }
        var s, o, a, l, c, u, h, d, f, p, m, g, v, _, y, x = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
            b = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            S = 1e8,
            E = 1e-8,
            M = 2 * Math.PI,
            w = M / 4,
            T = 0,
            A = Math.sqrt,
            P = Math.cos,
            C = Math.sin,
            R = function (t) {
                return "string" == typeof t
            },
            L = function (t) {
                return "function" == typeof t
            },
            O = function (t) {
                return "number" == typeof t
            },
            I = function (t) {
                return void 0 === t
            },
            D = function (t) {
                return "object" == typeof t
            },
            N = function (t) {
                return !1 !== t
            },
            U = function () {
                return "undefined" != typeof window
            },
            k = function (t) {
                return L(t) || R(t)
            },
            F = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {},
            z = Array.isArray,
            B = /(?:-?\.?\d|\.)+/gi,
            H = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            V = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            G = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
            W = /[+-]=-?[.\d]+/,
            j = /[^,'"\[\]\s]+/gi,
            X = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
            q = {},
            Y = {},
            K = function (t) {
                return (Y = Et(t, q)) && wn
            },
            Z = function (t, e) {
                return !e && void 0
            },
            J = function (t, e) {
                return t && (q[t] = e) && Y && (Y[t] = e) || q
            },
            $ = function () {
                return 0
            },
            Q = {
                suppressEvents: !0,
                isStart: !0,
                kill: !1
            },
            tt = {
                suppressEvents: !0,
                kill: !1
            },
            et = {
                suppressEvents: !0
            },
            nt = {},
            it = [],
            rt = {},
            st = {},
            ot = {},
            at = 30,
            lt = [],
            ct = "",
            ut = function (t) {
                var e, n, i = t[0];
                if (D(i) || L(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                    for (n = lt.length; n-- && !lt[n].targetTest(i););
                    e = lt[n]
                }
                for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new Fe(t[n], e))) || t.splice(n, 1);
                return t
            },
            ht = function (t) {
                return t._gsap || ut(ee(t))[0]._gsap
            },
            dt = function (t, e, n) {
                return (n = t[e]) && L(n) ? t[e]() : I(n) && t.getAttribute && t.getAttribute(e) || n
            },
            ft = function (t, e) {
                return (t = t.split(",")).forEach(e) || t
            },
            pt = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            mt = function (t) {
                return Math.round(1e7 * t) / 1e7 || 0
            },
            gt = function (t, e) {
                var n = e.charAt(0),
                    i = parseFloat(e.substr(2));
                return t = parseFloat(t), "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
            },
            vt = function (t, e) {
                for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
                return i < n
            },
            _t = function () {
                var t, e, n = it.length,
                    i = it.slice(0);
                for (rt = {}, it.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            },
            yt = function (t, e, n, i) {
                it.length && !o && _t(), t.render(e, n, i || o && e < 0 && (t._initted || t._startAt)), it.length && !o && _t()
            },
            xt = function (t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(j).length < 2 ? e : R(t) ? t.trim() : t
            },
            bt = function (t) {
                return t
            },
            St = function (t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            Et = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            Mt = function t(e, n) {
                for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = D(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
                return e
            },
            wt = function (t, e) {
                var n, i = {};
                for (n in t) n in e || (i[n] = t[n]);
                return i
            },
            Tt = function (t) {
                var e, n = t.parent || l,
                    i = t.keyframes ? (e = z(t.keyframes), function (t, n) {
                        for (var i in n) i in t || "duration" === i && e || "ease" === i || (t[i] = n[i])
                    }) : St;
                if (N(t.inherit))
                    for (; n;) i(t, n.vars.defaults), n = n.parent || n._dp;
                return t
            },
            At = function (t, e, n, i, r) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var s, o = t[i];
                if (r)
                    for (s = e[r]; o && o[r] > s;) o = o._prev;
                return o ? (e._next = o._next, o._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = o, e.parent = e._dp = t, e
            },
            Pt = function (t, e, n, i) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var r = e._prev,
                    s = e._next;
                r ? r._next = s : t[n] === e && (t[n] = s), s ? s._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
            },
            Ct = function (t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0
            },
            Rt = function (t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0))
                    for (var n = t; n;) n._dirty = 1, n = n.parent;
                return t
            },
            Lt = function (t, e, n, i) {
                return t._startAt && (o ? t._startAt.revert(tt) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, i))
            },
            Ot = function t(e) {
                return !e || e._ts && t(e.parent)
            },
            It = function (t) {
                return t._repeat ? Dt(t._tTime, t = t.duration() + t._rDelay) * t : 0
            },
            Dt = function (t, e) {
                var n = Math.floor(t /= e);
                return t && n === t ? n - 1 : n
            },
            Nt = function (t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            },
            Ut = function (t) {
                return t._end = mt(t._start + (t._tDur / Math.abs(t._ts || t._rts || E) || 0))
            },
            kt = function (t, e) {
                var n = t._dp;
                return n && n.smoothChildTiming && t._ts && (t._start = mt(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Ut(t), n._dirty || Rt(n, t)), t
            },
            Ft = function (t, e) {
                var n;
                if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (n = Nt(t.rawTime(), e), (!e._dur || Zt(0, e.totalDuration(), n) - e._tTime > E) && e.render(n, !0)), Rt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration())
                        for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    t._zTime = -1e-8
                }
            },
            zt = function (t, e, n, i) {
                return e.parent && Ct(e), e._start = mt((O(n) ? n : n || t !== l ? qt(t, n, e) : t._time) + e._delay), e._end = mt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), At(t, e, "_first", "_last", t._sort ? "_start" : 0), Gt(e) || (t._recent = e), i || Ft(t, e), t._ts < 0 && kt(t, t._tTime), t
            },
            Bt = function (t, e) {
                return q.ScrollTrigger ? q.ScrollTrigger.create(e, t) : void 0
            },
            Ht = function (t, e, n, i, r) {
                return Xe(t, e, r), t._initted ? !n && t._pt && !o && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && f !== we.frame ? (it.push(t), t._lazy = [r, i], 1) : void 0 : 1
            },
            Vt = function t(e) {
                var n = e.parent;
                return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
            },
            Gt = function (t) {
                var e = t.data;
                return "isFromStart" === e || "isStart" === e
            },
            Wt = function (t, e, n, i) {
                var r = t._repeat,
                    s = mt(e) || 0,
                    o = t._tTime / t._tDur;
                return o && !i && (t._time *= s / t._dur), t._dur = s, t._tDur = r ? r < 0 ? 1e10 : mt(s * (r + 1) + t._rDelay * r) : s, o > 0 && !i && kt(t, t._tTime = t._tDur * o), t.parent && Ut(t), n || Rt(t.parent, t), t
            },
            jt = function (t) {
                return t instanceof Be ? Rt(t) : Wt(t, t._dur)
            },
            Xt = {
                _start: 0,
                endTime: $,
                totalDuration: $
            },
            qt = function t(e, n, i) {
                var r, s, o, a = e.labels,
                    l = e._recent || Xt,
                    c = e.duration() >= S ? l.endTime(!1) : e._dur;
                return R(n) && (isNaN(n) || n in a) ? (s = n.charAt(0), o = "%" === n.substr(-1), r = n.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in a || (a[n] = c), a[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), o && i && (s = s / 100 * (z(i) ? i[0] : i).totalDuration()), r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n
            },
            Yt = function (t, e, n) {
                var i, r, s = O(e[1]),
                    o = (s ? 2 : 1) + (t < 2 ? 0 : 1),
                    a = e[o];
                if (s && (a.duration = e[1]), a.parent = n, t) {
                    for (i = a, r = n; r && !("immediateRender" in i);) i = r.vars.defaults || {}, r = N(r.vars.inherit) && r.parent;
                    a.immediateRender = N(i.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[o - 1]
                }
                return new Je(e[0], a, e[o + 1])
            },
            Kt = function (t, e) {
                return t || 0 === t ? e(t) : e
            },
            Zt = function (t, e, n) {
                return n < t ? t : n > e ? e : n
            },
            Jt = function (t, e) {
                return R(t) && (e = X.exec(t)) ? e[1] : ""
            },
            $t = [].slice,
            Qt = function (t, e) {
                return t && D(t) && "length" in t && (!e && !t.length || t.length - 1 in t && D(t[0])) && !t.nodeType && t !== c
            },
            te = function (t, e, n) {
                return void 0 === n && (n = []), t.forEach((function (t) {
                    var i;
                    return R(t) && !e || Qt(t, 1) ? (i = n).push.apply(i, ee(t)) : n.push(t)
                })) || n
            },
            ee = function (t, e, n) {
                return a && !e && a.selector ? a.selector(t) : !R(t) || n || !u && Te() ? z(t) ? te(t, n) : Qt(t) ? $t.call(t, 0) : t ? [t] : [] : $t.call((e || h).querySelectorAll(t), 0)
            },
            ne = function (t) {
                return t = ee(t)[0] || Z() || {},
                    function (e) {
                        var n = t.current || t.nativeElement || t;
                        return ee(e, n.querySelectorAll ? n : n === t ? Z() || h.createElement("div") : t)
                    }
            },
            ie = function (t) {
                return t.sort((function () {
                    return .5 - Math.random()
                }))
            },
            re = function (t) {
                if (L(t)) return t;
                var e = D(t) ? t : {
                        each: t
                    },
                    n = Ie(e.ease),
                    i = e.from || 0,
                    r = parseFloat(e.base) || 0,
                    s = {},
                    o = i > 0 && i < 1,
                    a = isNaN(i) || o,
                    l = e.axis,
                    c = i,
                    u = i;
                return R(i) ? c = u = {
                        center: .5,
                        edges: .5,
                        end: 1
                    } [i] || 0 : !o && a && (c = i[0], u = i[1]),
                    function (t, o, h) {
                        var d, f, p, m, g, v, _, y, x, b = (h || e).length,
                            E = s[b];
                        if (!E) {
                            if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, S])[1])) {
                                for (_ = -S; _ < (_ = h[x++].getBoundingClientRect().left) && x < b;);
                                x < b && x--
                            }
                            for (E = s[b] = [], d = a ? Math.min(x, b) * c - .5 : i % x, f = x === S ? 0 : a ? b * u / x - .5 : i / x | 0, _ = 0, y = S, v = 0; v < b; v++) p = v % x - d, m = f - (v / x | 0), E[v] = g = l ? Math.abs("y" === l ? m : p) : A(p * p + m * m), g > _ && (_ = g), g < y && (y = g);
                            "random" === i && ie(E), E.max = _ - y, E.min = y, E.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === i ? -1 : 1), E.b = b < 0 ? r - b : r, E.u = Jt(e.amount || e.each) || 0, n = n && b < 0 ? Le(n) : n
                        }
                        return b = (E[t] - E.min) / E.max || 0, mt(E.b + (n ? n(b) : b) * E.v) + E.u
                    }
            },
            se = function (t) {
                var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
                return function (n) {
                    var i = mt(Math.round(parseFloat(n) / t) * t * e);
                    return (i - i % 1) / e + (O(n) ? 0 : Jt(n))
                }
            },
            oe = function (t, e) {
                var n, i, r = z(t);
                return !r && D(t) && (n = r = t.radius || S, t.values ? (t = ee(t.values), (i = !O(t[0])) && (n *= n)) : t = se(t.increment)), Kt(e, r ? L(t) ? function (e) {
                    return i = t(e), Math.abs(i - e) <= n ? i : e
                } : function (e) {
                    for (var r, s, o = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), l = S, c = 0, u = t.length; u--;)(r = i ? (r = t[u].x - o) * r + (s = t[u].y - a) * s : Math.abs(t[u] - o)) < l && (l = r, c = u);
                    return c = !n || l <= n ? t[c] : e, i || c === e || O(e) ? c : c + Jt(e)
                } : se(t))
            },
            ae = function (t, e, n, i) {
                return Kt(z(t) ? !e : !0 === n ? !!(n = 0) : !i, (function () {
                    return z(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * i) / i
                }))
            },
            le = function (t, e, n) {
                return Kt(n, (function (n) {
                    return t[~~e(n)]
                }))
            },
            ce = function (t) {
                for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? j : B), o += t.substr(s, e - s) + ae(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1;
                return o + t.substr(s, t.length - s)
            },
            ue = function (t, e, n, i, r) {
                var s = e - t,
                    o = i - n;
                return Kt(r, (function (e) {
                    return n + ((e - t) / s * o || 0)
                }))
            },
            he = function (t, e, n) {
                var i, r, s, o = t.labels,
                    a = S;
                for (i in o)(r = o[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i, a = r);
                return s
            },
            de = function (t, e, n) {
                var i, r, s, o = t.vars,
                    l = o[e],
                    c = a,
                    u = t._ctx;
                if (l) return i = o[e + "Params"], r = o.callbackScope || t, n && it.length && _t(), u && (a = u), s = i ? l.apply(r, i) : l.call(r), a = c, s
            },
            fe = function (t) {
                return Ct(t), t.scrollTrigger && t.scrollTrigger.kill(!!o), t.progress() < 1 && de(t, "onInterrupt"), t
            },
            pe = [],
            me = function (t) {
                if (t)
                    if (t = !t.name && t.default || t, U() || t.headless) {
                        var e = t.name,
                            n = L(t),
                            i = e && !n && t.init ? function () {
                                this._props = []
                            } : t,
                            r = {
                                init: $,
                                render: an,
                                add: We,
                                kill: cn,
                                modifier: ln,
                                rawVars: 0
                            },
                            s = {
                                targetTest: 0,
                                get: 0,
                                getSetter: nn,
                                aliases: {},
                                register: 0
                            };
                        if (Te(), t !== i) {
                            if (st[e]) return;
                            St(i, St(wt(t, r), s)), Et(i.prototype, Et(r, wt(t, s))), st[i.prop = e] = i, t.targetTest && (lt.push(i), nt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                        }
                        J(e, i), t.register && t.register(wn, i, dn)
                    } else pe.push(t)
            },
            ge = 255,
            ve = {
                aqua: [0, ge, ge],
                lime: [0, ge, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, ge],
                navy: [0, 0, 128],
                white: [ge, ge, ge],
                olive: [128, 128, 0],
                yellow: [ge, ge, 0],
                orange: [ge, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [ge, 0, 0],
                pink: [ge, 192, 203],
                cyan: [0, ge, ge],
                transparent: [ge, ge, ge, 0]
            },
            _e = function (t, e, n) {
                return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * ge + .5 | 0
            },
            ye = function (t, e, n) {
                var i, r, s, o, a, l, c, u, h, d, f = t ? O(t) ? [t >> 16, t >> 8 & ge, t & ge] : 0 : ve.black;
                if (!f) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), ve[t]) f = ve[t];
                    else if ("#" === t.charAt(0)) {
                        if (t.length < 6 && (i = t.charAt(1), r = t.charAt(2), s = t.charAt(3), t = "#" + i + i + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(f = parseInt(t.substr(1, 6), 16)) >> 16, f >> 8 & ge, f & ge, parseInt(t.substr(7), 16) / 255];
                        f = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & ge, t & ge]
                    } else if ("hsl" === t.substr(0, 3))
                        if (f = d = t.match(B), e) {
                            if (~t.indexOf("=")) return f = t.match(H), n && f.length < 4 && (f[3] = 1), f
                        } else o = +f[0] % 360 / 360, a = +f[1] / 100, i = 2 * (l = +f[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a), f.length > 3 && (f[3] *= 1), f[0] = _e(o + 1 / 3, i, r), f[1] = _e(o, i, r), f[2] = _e(o - 1 / 3, i, r);
                    else f = t.match(B) || ve.transparent;
                    f = f.map(Number)
                }
                return e && !d && (i = f[0] / ge, r = f[1] / ge, s = f[2] / ge, l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2, c === u ? o = a = 0 : (h = c - u, a = l > .5 ? h / (2 - c - u) : h / (c + u), o = c === i ? (r - s) / h + (r < s ? 6 : 0) : c === r ? (s - i) / h + 2 : (i - r) / h + 4, o *= 60), f[0] = ~~(o + .5), f[1] = ~~(100 * a + .5), f[2] = ~~(100 * l + .5)), n && f.length < 4 && (f[3] = 1), f
            },
            xe = function (t) {
                var e = [],
                    n = [],
                    i = -1;
                return t.split(Se).forEach((function (t) {
                    var r = t.match(V) || [];
                    e.push.apply(e, r), n.push(i += r.length + 1)
                })), e.c = n, e
            },
            be = function (t, e, n) {
                var i, r, s, o, a = "",
                    l = (t + a).match(Se),
                    c = e ? "hsla(" : "rgba(",
                    u = 0;
                if (!l) return t;
                if (l = l.map((function (t) {
                        return (t = ye(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                    })), n && (s = xe(t), (i = n.c).join(a) !== s.c.join(a)))
                    for (o = (r = t.replace(Se, "1").split(V)).length - 1; u < o; u++) a += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
                if (!r)
                    for (o = (r = t.split(Se)).length - 1; u < o; u++) a += r[u] + l[u];
                return a + r[o]
            },
            Se = function () {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (t in ve) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(),
            Ee = /hsl[a]?\(/,
            Me = function (t) {
                var e, n = t.join(" ");
                if (Se.lastIndex = 0, Se.test(n)) return e = Ee.test(n), t[1] = be(t[1], e), t[0] = be(t[0], e, xe(t[1])), !0
            },
            we = function () {
                var t, e, n, i, r, s, o = Date.now,
                    a = 500,
                    l = 33,
                    f = o(),
                    p = f,
                    g = 1e3 / 240,
                    v = g,
                    _ = [],
                    y = function n(c) {
                        var u, h, d, m, y = o() - p,
                            x = !0 === c;
                        if ((y > a || y < 0) && (f += y - l), ((u = (d = (p += y) - f) - v) > 0 || x) && (m = ++i.frame, r = d - 1e3 * i.time, i.time = d /= 1e3, v += u + (u >= g ? 4 : g - u), h = 1), x || (t = e(n)), h)
                            for (s = 0; s < _.length; s++) _[s](d, r, m, c)
                    };
                return i = {
                    time: 0,
                    frame: 0,
                    tick: function () {
                        y(!0)
                    },
                    deltaRatio: function (t) {
                        return r / (1e3 / (t || 60))
                    },
                    wake: function () {
                        d && (!u && U() && (c = u = window, h = c.document || {}, q.gsap = wn, (c.gsapVersions || (c.gsapVersions = [])).push(wn.version), K(Y || c.GreenSockGlobals || !c.gsap && c || {}), pe.forEach(me)), n = "undefined" != typeof requestAnimationFrame && requestAnimationFrame, t && i.sleep(), e = n || function (t) {
                            return setTimeout(t, v - 1e3 * i.time + 1 | 0)
                        }, m = 1, y(2))
                    },
                    sleep: function () {
                        (n ? cancelAnimationFrame : clearTimeout)(t), m = 0, e = $
                    },
                    lagSmoothing: function (t, e) {
                        a = t || 1 / 0, l = Math.min(e || 33, a)
                    },
                    fps: function (t) {
                        g = 1e3 / (t || 240), v = 1e3 * i.time + g
                    },
                    add: function (t, e, n) {
                        var r = e ? function (e, n, s, o) {
                            t(e, n, s, o), i.remove(r)
                        } : t;
                        return i.remove(t), _[n ? "unshift" : "push"](r), Te(), r
                    },
                    remove: function (t, e) {
                        ~(e = _.indexOf(t)) && _.splice(e, 1) && s >= e && s--
                    },
                    _listeners: _
                }, i
            }(),
            Te = function () {
                return !m && we.wake()
            },
            Ae = {},
            Pe = /^[\d.\-M][\d.\-,\s]/,
            Ce = /["']/g,
            Re = function (t) {
                for (var e, n, i, r = {}, s = t.substr(1, t.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++) n = s[a], e = a !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[o] = isNaN(i) ? i.replace(Ce, "").trim() : +i, o = n.substr(e + 1).trim();
                return r
            },
            Le = function (t) {
                return function (e) {
                    return 1 - t(1 - e)
                }
            },
            Oe = function t(e, n) {
                for (var i, r = e._first; r;) r instanceof Be ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
            },
            Ie = function (t, e) {
                return t && (L(t) ? t : Ae[t] || function (t) {
                    var e, n, i, r, s = (t + "").split("("),
                        o = Ae[s[0]];
                    return o && s.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [Re(s[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(xt)) : Ae._CE && Pe.test(t) ? Ae._CE("", t) : o
                }(t)) || e
            },
            De = function (t, e, n, i) {
                void 0 === n && (n = function (t) {
                    return 1 - e(1 - t)
                }), void 0 === i && (i = function (t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var r, s = {
                    easeIn: e,
                    easeOut: n,
                    easeInOut: i
                };
                return ft(t, (function (t) {
                    for (var e in Ae[t] = q[t] = s, Ae[r = t.toLowerCase()] = n, s) Ae[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Ae[t + "." + e] = s[e]
                })), s
            },
            Ne = function (t) {
                return function (e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            },
            Ue = function t(e, n, i) {
                var r = n >= 1 ? n : 1,
                    s = (i || (e ? .3 : .45)) / (n < 1 ? n : 1),
                    o = s / M * (Math.asin(1 / r) || 0),
                    a = function (t) {
                        return 1 === t ? 1 : r * Math.pow(2, -10 * t) * C((t - o) * s) + 1
                    },
                    l = "out" === e ? a : "in" === e ? function (t) {
                        return 1 - a(1 - t)
                    } : Ne(a);
                return s = M / s, l.config = function (n, i) {
                    return t(e, n, i)
                }, l
            },
            ke = function t(e, n) {
                void 0 === n && (n = 1.70158);
                var i = function (t) {
                        return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                    },
                    r = "out" === e ? i : "in" === e ? function (t) {
                        return 1 - i(1 - t)
                    } : Ne(i);
                return r.config = function (n) {
                    return t(e, n)
                }, r
            };
        ft("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
            var n = e < 5 ? e + 1 : e;
            De(t + ",Power" + (n - 1), e ? function (t) {
                return Math.pow(t, n)
            } : function (t) {
                return t
            }, (function (t) {
                return 1 - Math.pow(1 - t, n)
            }), (function (t) {
                return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
            }))
        })), Ae.Linear.easeNone = Ae.none = Ae.Linear.easeIn, De("Elastic", Ue("in"), Ue("out"), Ue()), g = 7.5625, _ = 1 / (v = 2.75), De("Bounce", (function (t) {
            return 1 - y(1 - t)
        }), y = function (t) {
            return t < _ ? g * t * t : t < .7272727272727273 ? g * Math.pow(t - 1.5 / v, 2) + .75 : t < .9090909090909092 ? g * (t -= 2.25 / v) * t + .9375 : g * Math.pow(t - 2.625 / v, 2) + .984375
        }), De("Expo", (function (t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        })), De("Circ", (function (t) {
            return -(A(1 - t * t) - 1)
        })), De("Sine", (function (t) {
            return 1 === t ? 1 : 1 - P(t * w)
        })), De("Back", ke("in"), ke("out"), ke()), Ae.SteppedEase = Ae.steps = q.SteppedEase = {
            config: function (t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t,
                    i = t + (e ? 0 : 1),
                    r = e ? 1 : 0;
                return function (t) {
                    return ((i * Zt(0, .99999999, t) | 0) + r) * n
                }
            }
        }, b.ease = Ae["quad.out"], ft("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
            return ct += t + "," + t + "Params,"
        }));
        var Fe = function (t, e) {
                this.id = T++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : dt, this.set = e ? e.getSetter : nn
            },
            ze = function () {
                function t(t) {
                    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Wt(this, +t.duration, 1, 1), this.data = t.data, a && (this._ctx = a, a.data.push(this)), m || we.wake()
                }
                var e = t.prototype;
                return e.delay = function (t) {
                    return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                }, e.duration = function (t) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                }, e.totalDuration = function (t) {
                    return arguments.length ? (this._dirty = 0, Wt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, e.totalTime = function (t, e) {
                    if (Te(), !arguments.length) return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (kt(this, t), !n._dp || n.parent || Ft(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && zt(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === E || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), yt(this, t, e)), this
                }, e.time = function (t, e) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + It(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
                }, e.totalProgress = function (t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
                }, e.progress = function (t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + It(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                }, e.iteration = function (t, e) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Dt(this._tTime, n) + 1 : 1
                }, e.timeScale = function (t, e) {
                    if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === t) return this;
                    var n = this.parent && this._ts ? Nt(this.parent._time, this) : this._tTime;
                    return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, this.totalTime(Zt(-Math.abs(this._delay), this._tDur, n), !1 !== e), Ut(this),
                        function (t) {
                            for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                            return t
                        }(this)
                }, e.paused = function (t) {
                    return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Te(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== E && (this._tTime -= E)))), this) : this._ps
                }, e.startTime = function (t) {
                    if (arguments.length) {
                        this._start = t;
                        var e = this.parent || this._dp;
                        return e && (e._sort || !this.parent) && zt(e, this, t - this._delay), this
                    }
                    return this._start
                }, e.endTime = function (t) {
                    return this._start + (N(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                }, e.rawTime = function (t) {
                    var e = this.parent || this._dp;
                    return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Nt(e.rawTime(t), this) : this._tTime : this._tTime
                }, e.revert = function (t) {
                    void 0 === t && (t = et);
                    var e = o;
                    return o = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), o = e, this
                }, e.globalTime = function (t) {
                    for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (Math.abs(e._ts) || 1), e = e._dp;
                    return !this.parent && this._sat ? this._sat.globalTime(t) : n
                }, e.repeat = function (t) {
                    return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, jt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                }, e.repeatDelay = function (t) {
                    if (arguments.length) {
                        var e = this._time;
                        return this._rDelay = t, jt(this), e ? this.time(e) : this
                    }
                    return this._rDelay
                }, e.yoyo = function (t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, e.seek = function (t, e) {
                    return this.totalTime(qt(this, t), N(e))
                }, e.restart = function (t, e) {
                    return this.play().totalTime(t ? -this._delay : 0, N(e))
                }, e.play = function (t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, e.reverse = function (t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, e.pause = function (t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, e.resume = function () {
                    return this.paused(!1)
                }, e.reversed = function (t) {
                    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                }, e.invalidate = function () {
                    return this._initted = this._act = 0, this._zTime = -1e-8, this
                }, e.isActive = function () {
                    var t, e = this.parent || this._dp,
                        n = this._start;
                    return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - E))
                }, e.eventCallback = function (t, e, n) {
                    var i = this.vars;
                    return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
                }, e.then = function (t) {
                    var e = this;
                    return new Promise((function (n) {
                        var i = L(t) ? t : bt,
                            r = function () {
                                var t = e.then;
                                e.then = null, L(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                            };
                        e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                    }))
                }, e.kill = function () {
                    fe(this)
                }, t
            }();
        St(ze.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Be = function (t) {
            function e(e, n) {
                var r;
                return void 0 === e && (e = {}), (r = t.call(this, e) || this).labels = {}, r.smoothChildTiming = !!e.smoothChildTiming, r.autoRemoveChildren = !!e.autoRemoveChildren, r._sort = N(e.sortChildren), l && zt(e.parent || l, i(r), n), e.reversed && r.reverse(), e.paused && r.paused(!0), e.scrollTrigger && Bt(i(r), e.scrollTrigger), r
            }
            r(e, t);
            var n = e.prototype;
            return n.to = function (t, e, n) {
                return Yt(0, arguments, this), this
            }, n.from = function (t, e, n) {
                return Yt(1, arguments, this), this
            }, n.fromTo = function (t, e, n, i) {
                return Yt(2, arguments, this), this
            }, n.set = function (t, e, n) {
                return e.duration = 0, e.parent = this, Tt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Je(t, e, qt(this, n), 1), this
            }, n.call = function (t, e, n) {
                return zt(this, Je.delayedCall(0, t, e), n)
            }, n.staggerTo = function (t, e, n, i, r, s, o) {
                return n.duration = e, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = o, n.parent = this, new Je(t, n, qt(this, r)), this
            }, n.staggerFrom = function (t, e, n, i, r, s, o) {
                return n.runBackwards = 1, Tt(n).immediateRender = N(n.immediateRender), this.staggerTo(t, e, n, i, r, s, o)
            }, n.staggerFromTo = function (t, e, n, i, r, s, o, a) {
                return i.startAt = n, Tt(i).immediateRender = N(i.immediateRender), this.staggerTo(t, e, i, r, s, o, a)
            }, n.render = function (t, e, n) {
                var i, r, s, a, c, u, h, d, f, p, m, g, v = this._time,
                    _ = this._dirty ? this.totalDuration() : this._tDur,
                    y = this._dur,
                    x = t <= 0 ? 0 : mt(t),
                    b = this._zTime < 0 != t < 0 && (this._initted || !y);
                if (this !== l && x > _ && t >= 0 && (x = _), x !== this._tTime || n || b) {
                    if (v !== this._time && y && (x += this._time - v, t += this._time - v), i = x, f = this._start, u = !(d = this._ts), b && (y || (v = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                        if (m = this._yoyo, c = y + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * c + t, e, n);
                        if (i = mt(x % c), x === _ ? (a = this._repeat, i = y) : ((a = ~~(x / c)) && a === x / c && (i = y, a--), i > y && (i = y)), p = Dt(this._tTime, c), !v && this._tTime && p !== a && this._tTime - p * c - this._dur <= 0 && (p = a), m && 1 & a && (i = y - i, g = 1), a !== p && !this._lock) {
                            var S = m && 1 & p,
                                M = S === (m && 1 & a);
                            if (a < p && (S = !S), v = S ? 0 : x % y ? y : x, this._lock = 1, this.render(v || (g ? 0 : mt(a * c)), e, !y)._lock = 0, this._tTime = x, !e && this.parent && de(this, "onRepeat"), this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1), v && v !== this._time || u !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (y = this._dur, _ = this._tDur, M && (this._lock = 2, v = S ? y : -1e-4, this.render(v, !0), this.vars.repeatRefresh && !g && this.invalidate()), this._lock = 0, !this._ts && !u) return this;
                            Oe(this, g)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (h = function (t, e, n) {
                            var i;
                            if (n > e)
                                for (i = t._first; i && i._start <= n;) {
                                    if ("isPause" === i.data && i._start > e) return i;
                                    i = i._next
                                } else
                                    for (i = t._last; i && i._start >= n;) {
                                        if ("isPause" === i.data && i._start < e) return i;
                                        i = i._prev
                                    }
                        }(this, mt(v), mt(i)), h && (x -= i - (i = h._start))), this._tTime = x, this._time = i, this._act = !d, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, v = 0), !v && i && !e && !a && (de(this, "onStart"), this._tTime !== x)) return this;
                    if (i >= v && t >= 0)
                        for (r = this._first; r;) {
                            if (s = r._next, (r._act || i >= r._start) && r._ts && h !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !u) {
                                    h = 0, s && (x += this._zTime = -1e-8);
                                    break
                                }
                            }
                            r = s
                        } else {
                            r = this._last;
                            for (var w = t < 0 ? t : i; r;) {
                                if (s = r._prev, (r._act || w <= r._end) && r._ts && h !== r) {
                                    if (r.parent !== this) return this.render(t, e, n);
                                    if (r.render(r._ts > 0 ? (w - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (w - r._start) * r._ts, e, n || o && (r._initted || r._startAt)), i !== this._time || !this._ts && !u) {
                                        h = 0, s && (x += this._zTime = w ? -1e-8 : E);
                                        break
                                    }
                                }
                                r = s
                            }
                        }
                    if (h && !e && (this.pause(), h.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1, this._ts)) return this._start = f, Ut(this), this.render(t, e, n);
                    this._onUpdate && !e && de(this, "onUpdate", !0), (x === _ && this._tTime >= this.totalDuration() || !x && v) && (f !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((t || !y) && (x === _ && this._ts > 0 || !x && this._ts < 0) && Ct(this, 1), e || t < 0 && !v || !x && !v && _ || (de(this, x === _ && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(x < _ && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function (t, e) {
                var n = this;
                if (O(e) || (e = qt(this, e, t)), !(t instanceof ze)) {
                    if (z(t)) return t.forEach((function (t) {
                        return n.add(t, e)
                    })), this;
                    if (R(t)) return this.addLabel(t, e);
                    if (!L(t)) return this;
                    t = Je.delayedCall(0, t)
                }
                return this !== t ? zt(this, t, e) : this
            }, n.getChildren = function (t, e, n, i) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -S);
                for (var r = [], s = this._first; s;) s._start >= i && (s instanceof Je ? e && r.push(s) : (n && r.push(s), t && r.push.apply(r, s.getChildren(!0, e, n)))), s = s._next;
                return r
            }, n.getById = function (t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                    if (e[n].vars.id === t) return e[n]
            }, n.remove = function (t) {
                return R(t) ? this.removeLabel(t) : L(t) ? this.killTweensOf(t) : (Pt(this, t), t === this._recent && (this._recent = this._last), Rt(this))
            }, n.totalTime = function (e, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = mt(we.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function (t, e) {
                return this.labels[t] = qt(this, e), this
            }, n.removeLabel = function (t) {
                return delete this.labels[t], this
            }, n.addPause = function (t, e, n) {
                var i = Je.delayedCall(0, e || $, n);
                return i.data = "isPause", this._hasPause = 1, zt(this, i, qt(this, t))
            }, n.removePause = function (t) {
                var e = this._first;
                for (t = qt(this, t); e;) e._start === t && "isPause" === e.data && Ct(e), e = e._next
            }, n.killTweensOf = function (t, e, n) {
                for (var i = this.getTweensOf(t, n), r = i.length; r--;) He !== i[r] && i[r].kill(t, e);
                return this
            }, n.getTweensOf = function (t, e) {
                for (var n, i = [], r = ee(t), s = this._first, o = O(e); s;) s instanceof Je ? vt(s._targets, r) && (o ? (!He || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n), s = s._next;
                return i
            }, n.tweenTo = function (t, e) {
                e = e || {};
                var n, i = this,
                    r = qt(i, t),
                    s = e,
                    o = s.startAt,
                    a = s.onStart,
                    l = s.onStartParams,
                    c = s.immediateRender,
                    u = Je.to(i, St({
                        ease: e.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: r,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale()) || E,
                        onStart: function () {
                            if (i.pause(), !n) {
                                var t = e.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale());
                                u._dur !== t && Wt(u, t, 0, 1).render(u._time, !0, !0), n = 1
                            }
                            a && a.apply(u, l || [])
                        }
                    }, e));
                return c ? u.render(0) : u
            }, n.tweenFromTo = function (t, e, n) {
                return this.tweenTo(e, St({
                    startAt: {
                        time: qt(this, t)
                    }
                }, n))
            }, n.recent = function () {
                return this._recent
            }, n.nextLabel = function (t) {
                return void 0 === t && (t = this._time), he(this, qt(this, t))
            }, n.previousLabel = function (t) {
                return void 0 === t && (t = this._time), he(this, qt(this, t), 1)
            }, n.currentLabel = function (t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + E)
            }, n.shiftChildren = function (t, e, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, s = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
                if (e)
                    for (i in s) s[i] >= n && (s[i] += t);
                return Rt(this)
            }, n.invalidate = function (e) {
                var n = this._first;
                for (this._lock = 0; n;) n.invalidate(e), n = n._next;
                return t.prototype.invalidate.call(this, e)
            }, n.clear = function (t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Rt(this)
            }, n.totalDuration = function (t) {
                var e, n, i, r = 0,
                    s = this,
                    o = s._last,
                    a = S;
                if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t));
                if (s._dirty) {
                    for (i = s.parent; o;) e = o._prev, o._dirty && o.totalDuration(), (n = o._start) > a && s._sort && o._ts && !s._lock ? (s._lock = 1, zt(s, o, n - o._delay, 1)._lock = 0) : a = n, n < 0 && o._ts && (r -= n, (!i && !s._dp || i && i.smoothChildTiming) && (s._start += n / s._ts, s._time -= n, s._tTime -= n), s.shiftChildren(-n, !1, -Infinity), a = 0), o._end > r && o._ts && (r = o._end), o = e;
                    Wt(s, s === l && s._time > r ? s._time : r, 1, 1), s._dirty = 0
                }
                return s._tDur
            }, e.updateRoot = function (t) {
                if (l._ts && (yt(l, Nt(t, l)), f = we.frame), we.frame >= at) {
                    at += x.autoSleep || 120;
                    var e = l._first;
                    if ((!e || !e._ts) && x.autoSleep && we._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || we.sleep()
                    }
                }
            }, e
        }(ze);
        St(Be.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var He, Ve, Ge = function (t, e, n, i, r, s, o) {
                var a, l, c, u, h, d, f, p, m = new dn(this._pt, t, e, 0, 1, on, null, r),
                    g = 0,
                    v = 0;
                for (m.b = n, m.e = i, n += "", (f = ~(i += "").indexOf("random(")) && (i = ce(i)), s && (s(p = [n, i], t, e), n = p[0], i = p[1]), l = n.match(G) || []; a = G.exec(i);) u = a[0], h = i.substring(g, a.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: h || 1 === v ? h : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? gt(d, u) - d : parseFloat(u) - d,
                    m: c && c < 4 ? Math.round : 0
                }, g = G.lastIndex);
                return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = o, (W.test(i) || f) && (m.e = 0), this._pt = m, m
            },
            We = function (t, e, n, i, r, s, o, a, l, c) {
                L(i) && (i = i(r || 0, t, s));
                var u, h = t[e],
                    d = "get" !== n ? n : L(h) ? l ? t[e.indexOf("set") || !L(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : h,
                    f = L(h) ? l ? tn : Qe : $e;
                if (R(i) && (~i.indexOf("random(") && (i = ce(i)), "=" === i.charAt(1) && ((u = gt(d, i) + (Jt(d) || 0)) || 0 === u) && (i = u)), !c || d !== i || Ve) return isNaN(d * i) || "" === i ? Ge.call(this, t, e, d, i, f, a || x.stringFilter, l) : (u = new dn(this._pt, t, e, +d || 0, i - (d || 0), "boolean" == typeof h ? sn : rn, 0, f), l && (u.fp = l), o && u.modifier(o, this, t), this._pt = u)
            },
            je = function (t, e, n, i, r, s) {
                var o, a, l, c;
                if (st[t] && !1 !== (o = new st[t]).init(r, o.rawVars ? e[t] : function (t, e, n, i, r) {
                        if (L(t) && (t = Ye(t, r, e, n, i)), !D(t) || t.style && t.nodeType || z(t) || F(t)) return R(t) ? Ye(t, r, e, n, i) : t;
                        var s, o = {};
                        for (s in t) o[s] = Ye(t[s], r, e, n, i);
                        return o
                    }(e[t], i, r, s, n), n, i, s) && (n._pt = a = new dn(n._pt, r, t, 0, 1, o.render, o, 0, o.priority), n !== p))
                    for (l = n._ptLookup[n._targets.indexOf(r)], c = o._props.length; c--;) l[o._props[c]] = a;
                return o
            },
            Xe = function t(e, n, i) {
                var r, a, c, u, h, d, f, p, m, g, v, _, y, x = e.vars,
                    M = x.ease,
                    w = x.startAt,
                    T = x.immediateRender,
                    A = x.lazy,
                    P = x.onUpdate,
                    C = x.runBackwards,
                    R = x.yoyoEase,
                    L = x.keyframes,
                    O = x.autoRevert,
                    I = e._dur,
                    D = e._startAt,
                    U = e._targets,
                    k = e.parent,
                    F = k && "nested" === k.data ? k.vars.targets : U,
                    z = "auto" === e._overwrite && !s,
                    B = e.timeline;
                if (B && (!L || !M) && (M = "none"), e._ease = Ie(M, b.ease), e._yEase = R ? Le(Ie(!0 === R ? M : R, b.ease)) : 0, R && e._yoyo && !e._repeat && (R = e._yEase, e._yEase = e._ease, e._ease = R), e._from = !B && !!x.runBackwards, !B || L && !x.stagger) {
                    if (_ = (p = U[0] ? ht(U[0]).harness : 0) && x[p.prop], r = wt(x, nt), D && (D._zTime < 0 && D.progress(1), n < 0 && C && T && !O ? D.render(-1, !0) : D.revert(C && I ? tt : Q), D._lazy = 0), w) {
                        if (Ct(e._startAt = Je.set(U, St({
                                data: "isStart",
                                overwrite: !1,
                                parent: k,
                                immediateRender: !0,
                                lazy: !D && N(A),
                                startAt: null,
                                delay: 0,
                                onUpdate: P && function () {
                                    return de(e, "onUpdate")
                                },
                                stagger: 0
                            }, w))), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (o || !T && !O) && e._startAt.revert(tt), T && I && n <= 0 && i <= 0) return void(n && (e._zTime = n))
                    } else if (C && I && !D)
                        if (n && (T = !1), c = St({
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: T && !D && N(A),
                                immediateRender: T,
                                stagger: 0,
                                parent: k
                            }, r), _ && (c[p.prop] = _), Ct(e._startAt = Je.set(U, c)), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (o ? e._startAt.revert(tt) : e._startAt.render(-1, !0)), e._zTime = n, T) {
                            if (!n) return
                        } else t(e._startAt, E, E);
                    for (e._pt = e._ptCache = 0, A = I && N(A) || A && !I, a = 0; a < U.length; a++) {
                        if (f = (h = U[a])._gsap || ut(U)[a]._gsap, e._ptLookup[a] = g = {}, rt[f.id] && it.length && _t(), v = F === U ? a : F.indexOf(h), p && !1 !== (m = new p).init(h, _ || r, e, v, F) && (e._pt = u = new dn(e._pt, h, m.name, 0, 1, m.render, m, 0, m.priority), m._props.forEach((function (t) {
                                g[t] = u
                            })), m.priority && (d = 1)), !p || _)
                            for (c in r) st[c] && (m = je(c, r, e, v, h, F)) ? m.priority && (d = 1) : g[c] = u = We.call(e, h, c, "get", r[c], v, F, 0, x.stringFilter);
                        e._op && e._op[a] && e.kill(h, e._op[a]), z && e._pt && (He = e, l.killTweensOf(h, g, e.globalTime(n)), y = !e.parent, He = 0), e._pt && A && (rt[f.id] = 1)
                    }
                    d && hn(e), e._onInit && e._onInit(e)
                }
                e._onUpdate = P, e._initted = (!e._op || e._pt) && !y, L && n <= 0 && B.render(S, !0, !0)
            },
            qe = function (t, e, n, i) {
                var r, s, o = e.ease || i || "power1.inOut";
                if (z(e)) s = n[t] || (n[t] = []), e.forEach((function (t, n) {
                    return s.push({
                        t: n / (e.length - 1) * 100,
                        v: t,
                        e: o
                    })
                }));
                else
                    for (r in e) s = n[r] || (n[r] = []), "ease" === r || s.push({
                        t: parseFloat(t),
                        v: e[r],
                        e: o
                    })
            },
            Ye = function (t, e, n, i, r) {
                return L(t) ? t.call(e, n, i, r) : R(t) && ~t.indexOf("random(") ? ce(t) : t
            },
            Ke = ct + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
            Ze = {};
        ft(Ke + ",id,stagger,delay,duration,paused,scrollTrigger", (function (t) {
            return Ze[t] = 1
        }));
        var Je = function (t) {
            function e(e, n, r, o) {
                var a;
                "number" == typeof n && (r.duration = n, n = r, r = null);
                var c, u, h, d, f, p, m, g, v = (a = t.call(this, o ? n : Tt(n)) || this).vars,
                    _ = v.duration,
                    y = v.delay,
                    b = v.immediateRender,
                    S = v.stagger,
                    E = v.overwrite,
                    M = v.keyframes,
                    w = v.defaults,
                    T = v.scrollTrigger,
                    A = v.yoyoEase,
                    P = n.parent || l,
                    C = (z(e) || F(e) ? O(e[0]) : "length" in n) ? [e] : ee(e);
                if (a._targets = C.length ? ut(C) : Z(0, !x.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = E, M || S || k(_) || k(y)) {
                    if (n = a.vars, (c = a.timeline = new Be({
                            data: "nested",
                            defaults: w || {},
                            targets: P && "nested" === P.data ? P.vars.targets : C
                        })).kill(), c.parent = c._dp = i(a), c._start = 0, S || k(_) || k(y)) {
                        if (d = C.length, m = S && re(S), D(S))
                            for (f in S) ~Ke.indexOf(f) && (g || (g = {}), g[f] = S[f]);
                        for (u = 0; u < d; u++)(h = wt(n, Ze)).stagger = 0, A && (h.yoyoEase = A), g && Et(h, g), p = C[u], h.duration = +Ye(_, i(a), u, p, C), h.delay = (+Ye(y, i(a), u, p, C) || 0) - a._delay, !S && 1 === d && h.delay && (a._delay = y = h.delay, a._start += y, h.delay = 0), c.to(p, h, m ? m(u, p, C) : 0), c._ease = Ae.none;
                        c.duration() ? _ = y = 0 : a.timeline = 0
                    } else if (M) {
                        Tt(St(c.vars.defaults, {
                            ease: "none"
                        })), c._ease = Ie(M.ease || n.ease || "none");
                        var R, L, I, U = 0;
                        if (z(M)) M.forEach((function (t) {
                            return c.to(C, t, ">")
                        })), c.duration();
                        else {
                            for (f in h = {}, M) "ease" === f || "easeEach" === f || qe(f, M[f], h, M.easeEach);
                            for (f in h)
                                for (R = h[f].sort((function (t, e) {
                                        return t.t - e.t
                                    })), U = 0, u = 0; u < R.length; u++)(I = {
                                    ease: (L = R[u]).e,
                                    duration: (L.t - (u ? R[u - 1].t : 0)) / 100 * _
                                })[f] = L.v, c.to(C, I, U), U += I.duration;
                            c.duration() < _ && c.to({}, {
                                duration: _ - c.duration()
                            })
                        }
                    }
                    _ || a.duration(_ = c.duration())
                } else a.timeline = 0;
                return !0 !== E || s || (He = i(a), l.killTweensOf(C), He = 0), zt(P, i(a), r), n.reversed && a.reverse(), n.paused && a.paused(!0), (b || !_ && !M && a._start === mt(P._time) && N(b) && Ot(i(a)) && "nested" !== P.data) && (a._tTime = -1e-8, a.render(Math.max(0, -y) || 0)), T && Bt(i(a), T), a
            }
            r(e, t);
            var n = e.prototype;
            return n.render = function (t, e, n) {
                var i, r, s, a, l, c, u, h, d, f = this._time,
                    p = this._tDur,
                    m = this._dur,
                    g = t < 0,
                    v = t > p - E && !g ? p : t < E ? 0 : t;
                if (m) {
                    if (v !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
                        if (i = v, h = this.timeline, this._repeat) {
                            if (a = m + this._rDelay, this._repeat < -1 && g) return this.totalTime(100 * a + t, e, n);
                            if (i = mt(v % a), v === p ? (s = this._repeat, i = m) : ((s = ~~(v / a)) && s === mt(v / a) && (i = m, s--), i > m && (i = m)), (c = this._yoyo && 1 & s) && (d = this._yEase, i = m - i), l = Dt(this._tTime, a), i === f && !n && this._initted && s === l) return this._tTime = v, this;
                            s !== l && (h && this._yEase && Oe(h, c), this.vars.repeatRefresh && !c && !this._lock && this._time !== a && this._initted && (this._lock = n = 1, this.render(mt(a * s), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (Ht(this, g ? t : i, n, e, v)) return this._tTime = 0, this;
                            if (!(f === this._time || n && this.vars.repeatRefresh && s !== l)) return this;
                            if (m !== this._dur) return this.render(t, e, n)
                        }
                        if (this._tTime = v, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = u = (d || this._ease)(i / m), this._from && (this.ratio = u = 1 - u), i && !f && !e && !s && (de(this, "onStart"), this._tTime !== v)) return this;
                        for (r = this._pt; r;) r.r(u, r.d), r = r._next;
                        h && h.render(t < 0 ? t : h._dur * h._ease(i / this._dur), e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (g && Lt(this, t, 0, n), de(this, "onUpdate")), this._repeat && s !== l && this.vars.onRepeat && !e && this.parent && de(this, "onRepeat"), v !== this._tDur && v || this._tTime !== v || (g && !this._onUpdate && Lt(this, t, 0, !0), (t || !m) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && Ct(this, 1), e || g && !f || !(v || f || c) || (de(this, v === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < p && this.timeScale() > 0) && this._prom()))
                    }
                } else ! function (t, e, n, i) {
                    var r, s, a, l = t.ratio,
                        c = e < 0 || !e && (!t._start && Vt(t) && (t._initted || !Gt(t)) || (t._ts < 0 || t._dp._ts < 0) && !Gt(t)) ? 0 : 1,
                        u = t._rDelay,
                        h = 0;
                    if (u && t._repeat && (h = Zt(0, t._tDur, e), s = Dt(h, u), t._yoyo && 1 & s && (c = 1 - c), s !== Dt(t._tTime, u) && (l = 1 - c, t.vars.repeatRefresh && t._initted && t.invalidate())), c !== l || o || i || t._zTime === E || !e && t._zTime) {
                        if (!t._initted && Ht(t, e, i, n, h)) return;
                        for (a = t._zTime, t._zTime = e || (n ? E : 0), n || (n = e && !a), t.ratio = c, t._from && (c = 1 - c), t._time = 0, t._tTime = h, r = t._pt; r;) r.r(c, r.d), r = r._next;
                        e < 0 && Lt(t, e, 0, !0), t._onUpdate && !n && de(t, "onUpdate"), h && t._repeat && !n && t.parent && de(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === c && (c && Ct(t, 1), n || o || (de(t, c ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                    } else t._zTime || (t._zTime = e)
                }(this, t, e, n);
                return this
            }, n.targets = function () {
                return this._targets
            }, n.invalidate = function (e) {
                return (!e || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(e), t.prototype.invalidate.call(this, e)
            }, n.resetTo = function (t, e, n, i, r) {
                m || we.wake(), this._ts || this.play();
                var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                return this._initted || Xe(this, s),
                    function (t, e, n, i, r, s, o, a) {
                        var l, c, u, h, d = (t._pt && t._ptCache || (t._ptCache = {}))[e];
                        if (!d)
                            for (d = t._ptCache[e] = [], u = t._ptLookup, h = t._targets.length; h--;) {
                                if ((l = u[h][e]) && l.d && l.d._pt)
                                    for (l = l.d._pt; l && l.p !== e && l.fp !== e;) l = l._next;
                                if (!l) return Ve = 1, t.vars[e] = "+=0", Xe(t, o), Ve = 0, a ? Z() : 1;
                                d.push(l)
                            }
                        for (h = d.length; h--;)(l = (c = d[h])._pt || c).s = !i && 0 !== i || r ? l.s + (i || 0) + s * l.c : i, l.c = n - l.s, c.e && (c.e = pt(n) + Jt(c.e)), c.b && (c.b = l.s + Jt(c.b))
                    }(this, t, e, n, i, this._ease(s / this._dur), s, r) ? this.resetTo(t, e, n, i, 1) : (kt(this, 0), this.parent || At(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
            }, n.kill = function (t, e) {
                if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? fe(this) : this;
                if (this.timeline) {
                    var n = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, He && !0 !== He.vars.overwrite)._first || fe(this), this.parent && n !== this.timeline.totalDuration() && Wt(this, this._dur * this.timeline._tDur / n, 0, 1), this
                }
                var i, r, s, o, a, l, c, u = this._targets,
                    h = t ? ee(t) : u,
                    d = this._ptLookup,
                    f = this._pt;
                if ((!e || "all" === e) && function (t, e) {
                        for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];);
                        return n < 0
                    }(u, h)) return "all" === e && (this._pt = 0), fe(this);
                for (i = this._op = this._op || [], "all" !== e && (R(e) && (a = {}, ft(e, (function (t) {
                        return a[t] = 1
                    })), e = a), e = function (t, e) {
                        var n, i, r, s, o = t[0] ? ht(t[0]).harness : 0,
                            a = o && o.aliases;
                        if (!a) return e;
                        for (i in n = Et({}, e), a)
                            if (i in n)
                                for (r = (s = a[i].split(",")).length; r--;) n[s[r]] = n[i];
                        return n
                    }(u, e)), c = u.length; c--;)
                    if (~h.indexOf(u[c]))
                        for (a in r = d[c], "all" === e ? (i[c] = e, o = r, s = {}) : (s = i[c] = i[c] || {}, o = e), o)(l = r && r[a]) && ("kill" in l.d && !0 !== l.d.kill(a) || Pt(this, l, "_pt"), delete r[a]), "all" !== s && (s[a] = 1);
                return this._initted && !this._pt && f && fe(this), this
            }, e.to = function (t, n) {
                return new e(t, n, arguments[2])
            }, e.from = function (t, e) {
                return Yt(1, arguments)
            }, e.delayedCall = function (t, n, i, r) {
                return new e(n, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: n,
                    onReverseComplete: n,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: r
                })
            }, e.fromTo = function (t, e, n) {
                return Yt(2, arguments)
            }, e.set = function (t, n) {
                return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
            }, e.killTweensOf = function (t, e, n) {
                return l.killTweensOf(t, e, n)
            }, e
        }(ze);
        St(Je.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), ft("staggerTo,staggerFrom,staggerFromTo", (function (t) {
            Je[t] = function () {
                var e = new Be,
                    n = $t.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        }));
        var $e = function (t, e, n) {
                return t[e] = n
            },
            Qe = function (t, e, n) {
                return t[e](n)
            },
            tn = function (t, e, n, i) {
                return t[e](i.fp, n)
            },
            en = function (t, e, n) {
                return t.setAttribute(e, n)
            },
            nn = function (t, e) {
                return L(t[e]) ? Qe : I(t[e]) && t.setAttribute ? en : $e
            },
            rn = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
            },
            sn = function (t, e) {
                return e.set(e.t, e.p, !!(e.s + e.c * t), e)
            },
            on = function (t, e) {
                var n = e._pt,
                    i = "";
                if (!t && e.b) i = e.b;
                else if (1 === t && e.e) i = e.e;
                else {
                    for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                    i += e.c
                }
                e.set(e.t, e.p, i, e)
            },
            an = function (t, e) {
                for (var n = e._pt; n;) n.r(t, n.d), n = n._next
            },
            ln = function (t, e, n, i) {
                for (var r, s = this._pt; s;) r = s._next, s.p === i && s.modifier(t, e, n), s = r
            },
            cn = function (t) {
                for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? Pt(this, i, "_pt") : i.dep || (e = 1), i = n;
                return !e
            },
            un = function (t, e, n, i) {
                i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
            },
            hn = function (t) {
                for (var e, n, i, r, s = t._pt; s;) {
                    for (e = s._next, n = i; n && n.pr > s.pr;) n = n._next;
                    (s._prev = n ? n._prev : r) ? s._prev._next = s: i = s, (s._next = n) ? n._prev = s : r = s, s = e
                }
                t._pt = i
            },
            dn = function () {
                function t(t, e, n, i, r, s, o, a, l) {
                    this.t = e, this.s = i, this.c = r, this.p = n, this.r = s || rn, this.d = o || this, this.set = a || $e, this.pr = l || 0, this._next = t, t && (t._prev = this)
                }
                return t.prototype.modifier = function (t, e, n) {
                    this.mSet = this.mSet || this.set, this.set = un, this.m = t, this.mt = n, this.tween = e
                }, t
            }();
        ft(ct + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
            return nt[t] = 1
        })), q.TweenMax = q.TweenLite = Je, q.TimelineLite = q.TimelineMax = Be, l = new Be({
            sortChildren: !1,
            defaults: b,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), x.stringFilter = Me;
        var fn = [],
            pn = {},
            mn = [],
            gn = 0,
            vn = 0,
            _n = function (t) {
                return (pn[t] || mn).map((function (t) {
                    return t()
                }))
            },
            yn = function () {
                var t = Date.now(),
                    e = [];
                t - gn > 2 && (_n("matchMediaInit"), fn.forEach((function (t) {
                    var n, i, r, s, o = t.queries,
                        a = t.conditions;
                    for (i in o)(n = c.matchMedia(o[i]).matches) && (r = 1), n !== a[i] && (a[i] = n, s = 1);
                    s && (t.revert(), r && e.push(t))
                })), _n("matchMediaRevert"), e.forEach((function (t) {
                    return t.onMatch(t, (function (e) {
                        return t.add(null, e)
                    }))
                })), gn = t, _n("matchMedia"))
            },
            xn = function () {
                function t(t, e) {
                    this.selector = e && ne(e), this.data = [], this._r = [], this.isReverted = !1, this.id = vn++, t && this.add(t)
                }
                var e = t.prototype;
                return e.add = function (t, e, n) {
                    L(t) && (n = e, e = t, t = L);
                    var i = this,
                        r = function () {
                            var t, r = a,
                                s = i.selector;
                            return r && r !== i && r.data.push(i), n && (i.selector = ne(n)), a = i, t = e.apply(i, arguments), L(t) && i._r.push(t), a = r, i.selector = s, i.isReverted = !1, t
                        };
                    return i.last = r, t === L ? r(i, (function (t) {
                        return i.add(null, t)
                    })) : t ? i[t] = r : r
                }, e.ignore = function (t) {
                    var e = a;
                    a = null, t(this), a = e
                }, e.getTweens = function () {
                    var e = [];
                    return this.data.forEach((function (n) {
                        return n instanceof t ? e.push.apply(e, n.getTweens()) : n instanceof Je && !(n.parent && "nested" === n.parent.data) && e.push(n)
                    })), e
                }, e.clear = function () {
                    this._r.length = this.data.length = 0
                }, e.kill = function (t, e) {
                    var n = this;
                    if (t ? function () {
                            for (var e, i = n.getTweens(), r = n.data.length; r--;) "isFlip" === (e = n.data[r]).data && (e.revert(), e.getChildren(!0, !0, !1).forEach((function (t) {
                                return i.splice(i.indexOf(t), 1)
                            })));
                            for (i.map((function (t) {
                                    return {
                                        g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -1 / 0,
                                        t
                                    }
                                })).sort((function (t, e) {
                                    return e.g - t.g || -1 / 0
                                })).forEach((function (e) {
                                    return e.t.revert(t)
                                })), r = n.data.length; r--;)(e = n.data[r]) instanceof Be ? "nested" !== e.data && (e.scrollTrigger && e.scrollTrigger.revert(), e.kill()) : !(e instanceof Je) && e.revert && e.revert(t);
                            n._r.forEach((function (e) {
                                return e(t, n)
                            })), n.isReverted = !0
                        }() : this.data.forEach((function (t) {
                            return t.kill && t.kill()
                        })), this.clear(), e)
                        for (var i = fn.length; i--;) fn[i].id === this.id && fn.splice(i, 1)
                }, e.revert = function (t) {
                    this.kill(t || {})
                }, t
            }(),
            bn = function () {
                function t(t) {
                    this.contexts = [], this.scope = t, a && a.data.push(this)
                }
                var e = t.prototype;
                return e.add = function (t, e, n) {
                    D(t) || (t = {
                        matches: t
                    });
                    var i, r, s, o = new xn(0, n || this.scope),
                        l = o.conditions = {};
                    for (r in a && !o.selector && (o.selector = a.selector), this.contexts.push(o), e = o.add("onMatch", e), o.queries = t, t) "all" === r ? s = 1 : (i = c.matchMedia(t[r])) && (fn.indexOf(o) < 0 && fn.push(o), (l[r] = i.matches) && (s = 1), i.addListener ? i.addListener(yn) : i.addEventListener("change", yn));
                    return s && e(o, (function (t) {
                        return o.add(null, t)
                    })), this
                }, e.revert = function (t) {
                    this.kill(t || {})
                }, e.kill = function (t) {
                    this.contexts.forEach((function (e) {
                        return e.kill(t, !0)
                    }))
                }, t
            }(),
            Sn = {
                registerPlugin: function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    e.forEach((function (t) {
                        return me(t)
                    }))
                },
                timeline: function (t) {
                    return new Be(t)
                },
                getTweensOf: function (t, e) {
                    return l.getTweensOf(t, e)
                },
                getProperty: function (t, e, n, i) {
                    R(t) && (t = ee(t)[0]);
                    var r = ht(t || {}).get,
                        s = n ? bt : xt;
                    return "native" === n && (n = ""), t ? e ? s((st[e] && st[e].get || r)(t, e, n, i)) : function (e, n, i) {
                        return s((st[e] && st[e].get || r)(t, e, n, i))
                    } : t
                },
                quickSetter: function (t, e, n) {
                    if ((t = ee(t)).length > 1) {
                        var i = t.map((function (t) {
                                return wn.quickSetter(t, e, n)
                            })),
                            r = i.length;
                        return function (t) {
                            for (var e = r; e--;) i[e](t)
                        }
                    }
                    t = t[0] || {};
                    var s = st[e],
                        o = ht(t),
                        a = o.harness && (o.harness.aliases || {})[e] || e,
                        l = s ? function (e) {
                            var i = new s;
                            p._pt = 0, i.init(t, n ? e + n : e, p, 0, [t]), i.render(1, i), p._pt && an(1, p)
                        } : o.set(t, a);
                    return s ? l : function (e) {
                        return l(t, a, n ? e + n : e, o, 1)
                    }
                },
                quickTo: function (t, e, n) {
                    var i, r = wn.to(t, Et(((i = {})[e] = "+=0.1", i.paused = !0, i), n || {})),
                        s = function (t, n, i) {
                            return r.resetTo(e, t, n, i)
                        };
                    return s.tween = r, s
                },
                isTweening: function (t) {
                    return l.getTweensOf(t, !0).length > 0
                },
                defaults: function (t) {
                    return t && t.ease && (t.ease = Ie(t.ease, b.ease)), Mt(b, t || {})
                },
                config: function (t) {
                    return Mt(x, t || {})
                },
                registerEffect: function (t) {
                    var e = t.name,
                        n = t.effect,
                        i = t.plugins,
                        r = t.defaults,
                        s = t.extendTimeline;
                    (i || "").split(",").forEach((function (t) {
                        return t && !st[t] && !q[t] && Z()
                    })), ot[e] = function (t, e, i) {
                        return n(ee(t), St(e || {}, r), i)
                    }, s && (Be.prototype[e] = function (t, n, i) {
                        return this.add(ot[e](t, D(n) ? n : (i = n) && {}, this), i)
                    })
                },
                registerEase: function (t, e) {
                    Ae[t] = Ie(e)
                },
                parseEase: function (t, e) {
                    return arguments.length ? Ie(t, e) : Ae
                },
                getById: function (t) {
                    return l.getById(t)
                },
                exportRoot: function (t, e) {
                    void 0 === t && (t = {});
                    var n, i, r = new Be(t);
                    for (r.smoothChildTiming = N(t.smoothChildTiming), l.remove(r), r._dp = 0, r._time = r._tTime = l._time, n = l._first; n;) i = n._next, !e && !n._dur && n instanceof Je && n.vars.onComplete === n._targets[0] || zt(r, n, n._start - n._delay), n = i;
                    return zt(l, r, 0), r
                },
                context: function (t, e) {
                    return t ? new xn(t, e) : a
                },
                matchMedia: function (t) {
                    return new bn(t)
                },
                matchMediaRefresh: function () {
                    return fn.forEach((function (t) {
                        var e, n, i = t.conditions;
                        for (n in i) i[n] && (i[n] = !1, e = 1);
                        e && t.revert()
                    })) || yn()
                },
                addEventListener: function (t, e) {
                    var n = pn[t] || (pn[t] = []);
                    ~n.indexOf(e) || n.push(e)
                },
                removeEventListener: function (t, e) {
                    var n = pn[t],
                        i = n && n.indexOf(e);
                    i >= 0 && n.splice(i, 1)
                },
                utils: {
                    wrap: function t(e, n, i) {
                        var r = n - e;
                        return z(e) ? le(e, t(0, e.length), n) : Kt(i, (function (t) {
                            return (r + (t - e) % r) % r + e
                        }))
                    },
                    wrapYoyo: function t(e, n, i) {
                        var r = n - e,
                            s = 2 * r;
                        return z(e) ? le(e, t(0, e.length - 1), n) : Kt(i, (function (t) {
                            return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                        }))
                    },
                    distribute: re,
                    random: ae,
                    snap: oe,
                    normalize: function (t, e, n) {
                        return ue(t, e, 0, 1, n)
                    },
                    getUnit: Jt,
                    clamp: function (t, e, n) {
                        return Kt(n, (function (n) {
                            return Zt(t, e, n)
                        }))
                    },
                    splitColor: ye,
                    toArray: ee,
                    selector: ne,
                    mapRange: ue,
                    pipe: function () {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        return function (t) {
                            return e.reduce((function (t, e) {
                                return e(t)
                            }), t)
                        }
                    },
                    unitize: function (t, e) {
                        return function (n) {
                            return t(parseFloat(n)) + (e || Jt(n))
                        }
                    },
                    interpolate: function t(e, n, i, r) {
                        var s = isNaN(e + n) ? 0 : function (t) {
                            return (1 - t) * e + t * n
                        };
                        if (!s) {
                            var o, a, l, c, u, h = R(e),
                                d = {};
                            if (!0 === i && (r = 1) && (i = null), h) e = {
                                p: e
                            }, n = {
                                p: n
                            };
                            else if (z(e) && !z(n)) {
                                for (l = [], c = e.length, u = c - 2, a = 1; a < c; a++) l.push(t(e[a - 1], e[a]));
                                c--, s = function (t) {
                                    t *= c;
                                    var e = Math.min(u, ~~t);
                                    return l[e](t - e)
                                }, i = n
                            } else r || (e = Et(z(e) ? [] : {}, e));
                            if (!l) {
                                for (o in n) We.call(d, e, o, "get", n[o]);
                                s = function (t) {
                                    return an(t, d) || (h ? e.p : e)
                                }
                            }
                        }
                        return Kt(i, s)
                    },
                    shuffle: ie
                },
                install: K,
                effects: ot,
                ticker: we,
                updateRoot: Be.updateRoot,
                plugins: st,
                globalTimeline: l,
                core: {
                    PropTween: dn,
                    globals: J,
                    Tween: Je,
                    Timeline: Be,
                    Animation: ze,
                    getCache: ht,
                    _removeLinkedListItem: Pt,
                    reverting: function () {
                        return o
                    },
                    context: function (t) {
                        return t && a && (a.data.push(t), t._ctx = a), a
                    },
                    suppressOverwrites: function (t) {
                        return s = t
                    }
                }
            };
        ft("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
            return Sn[t] = Je[t]
        })), we.add(Be.updateRoot), p = Sn.to({}, {
            duration: 0
        });
        var En = function (t, e) {
                for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
                return n
            },
            Mn = function (t, e) {
                return {
                    name: t,
                    rawVars: 1,
                    init: function (t, n, i) {
                        i._onInit = function (t) {
                            var i, r;
                            if (R(n) && (i = {}, ft(n, (function (t) {
                                    return i[t] = 1
                                })), n = i), e) {
                                for (r in i = {}, n) i[r] = e(n[r]);
                                n = i
                            }! function (t, e) {
                                var n, i, r, s = t._targets;
                                for (n in e)
                                    for (i = s.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = En(r, n)), r && r.modifier && r.modifier(e[n], t, s[i], n))
                            }(t, n)
                        }
                    }
                }
            },
            wn = Sn.registerPlugin({
                name: "attr",
                init: function (t, e, n, i, r) {
                    var s, o, a;
                    for (s in this.tween = n, e) a = t.getAttribute(s) || "", (o = this.add(t, "setAttribute", (a || 0) + "", e[s], i, r, 0, 0, s)).op = s, o.b = a, this._props.push(s)
                },
                render: function (t, e) {
                    for (var n = e._pt; n;) o ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), n = n._next
                }
            }, {
                name: "endArray",
                init: function (t, e) {
                    for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
                }
            }, Mn("roundProps", se), Mn("modifiers"), Mn("snap", oe)) || Sn;
        Je.version = Be.version = wn.version = "3.12.5", d = 1, U() && Te();
        Ae.Power0, Ae.Power1, Ae.Power2, Ae.Power3, Ae.Power4, Ae.Linear, Ae.Quad, Ae.Cubic, Ae.Quart, Ae.Quint, Ae.Strong, Ae.Elastic, Ae.Back, Ae.SteppedEase, Ae.Bounce, Ae.Sine, Ae.Expo, Ae.Circ;
        var Tn, An, Pn, Cn, Rn, Ln, On, In, Dn = {},
            Nn = 180 / Math.PI,
            Un = Math.PI / 180,
            kn = Math.atan2,
            Fn = /([A-Z])/g,
            zn = /(left|right|width|margin|padding|x)/i,
            Bn = /[\s,\(]\S/,
            Hn = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            Vn = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            Gn = function (t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            Wn = function (t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            },
            jn = function (t, e) {
                var n = e.s + e.c * t;
                e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
            },
            Xn = function (t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            },
            qn = function (t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            },
            Yn = function (t, e, n) {
                return t.style[e] = n
            },
            Kn = function (t, e, n) {
                return t.style.setProperty(e, n)
            },
            Zn = function (t, e, n) {
                return t._gsap[e] = n
            },
            Jn = function (t, e, n) {
                return t._gsap.scaleX = t._gsap.scaleY = n
            },
            $n = function (t, e, n, i, r) {
                var s = t._gsap;
                s.scaleX = s.scaleY = n, s.renderTransform(r, s)
            },
            Qn = function (t, e, n, i, r) {
                var s = t._gsap;
                s[e] = n, s.renderTransform(r, s)
            },
            ti = "transform",
            ei = ti + "Origin",
            ni = function t(e, n) {
                var i = this,
                    r = this.target,
                    s = r.style,
                    o = r._gsap;
                if (e in Dn && s) {
                    if (this.tfm = this.tfm || {}, "transform" === e) return Hn.transform.split(",").forEach((function (e) {
                        return t.call(i, e, n)
                    }));
                    if (~(e = Hn[e] || e).indexOf(",") ? e.split(",").forEach((function (t) {
                            return i.tfm[t] = xi(r, t)
                        })) : this.tfm[e] = o.x ? o[e] : xi(r, e), e === ei && (this.tfm.zOrigin = o.zOrigin), this.props.indexOf(ti) >= 0) return;
                    o.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(ei, n, "")), e = ti
                }(s || n) && this.props.push(e, n, s[e])
            },
            ii = function (t) {
                t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"))
            },
            ri = function () {
                var t, e, n = this.props,
                    i = this.target,
                    r = i.style,
                    s = i._gsap;
                for (t = 0; t < n.length; t += 3) n[t + 1] ? i[n[t]] = n[t + 2] : n[t + 2] ? r[n[t]] = n[t + 2] : r.removeProperty("--" === n[t].substr(0, 2) ? n[t] : n[t].replace(Fn, "-$1").toLowerCase());
                if (this.tfm) {
                    for (e in this.tfm) s[e] = this.tfm[e];
                    s.svg && (s.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), (t = On()) && t.isStart || r[ti] || (ii(r), s.zOrigin && r[ei] && (r[ei] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1)
                }
            },
            si = function (t, e) {
                var n = {
                    target: t,
                    props: [],
                    revert: ri,
                    save: ni
                };
                return t._gsap || wn.core.getCache(t), e && e.split(",").forEach((function (t) {
                    return n.save(t)
                })), n
            },
            oi = function (t, e) {
                var n = An.createElementNS ? An.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : An.createElement(t);
                return n && n.style ? n : An.createElement(t)
            },
            ai = function t(e, n, i) {
                var r = getComputedStyle(e);
                return r[n] || r.getPropertyValue(n.replace(Fn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, ci(n) || n, 1) || ""
            },
            li = "O,Moz,ms,Ms,Webkit".split(","),
            ci = function (t, e, n) {
                var i = (e || Rn).style,
                    r = 5;
                if (t in i && !n) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(li[r] + t in i););
                return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? li[r] : "") + t
            },
            ui = function () {
                "undefined" != typeof window && window.document && (Tn = window, An = Tn.document, Pn = An.documentElement, Rn = oi("div") || {
                    style: {}
                }, oi("div"), ti = ci(ti), ei = ti + "Origin", Rn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", In = !!ci("perspective"), On = wn.core.reverting, Cn = 1)
            },
            hi = function t(e) {
                var n, i = oi("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode,
                    s = this.nextSibling,
                    o = this.style.cssText;
                if (Pn.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
                return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), Pn.removeChild(i), this.style.cssText = o, n
            },
            di = function (t, e) {
                for (var n = e.length; n--;)
                    if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
            },
            fi = function (t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (n) {
                    e = hi.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === hi || (e = hi.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +di(t, ["x", "cx", "x1"]) || 0,
                    y: +di(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            },
            pi = function (t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !fi(t))
            },
            mi = function (t, e) {
                if (e) {
                    var n, i = t.style;
                    e in Dn && e !== ei && (e = ti), i.removeProperty ? ("ms" !== (n = e.substr(0, 2)) && "webkit" !== e.substr(0, 6) || (e = "-" + e), i.removeProperty("--" === n ? e : e.replace(Fn, "-$1").toLowerCase())) : i.removeAttribute(e)
                }
            },
            gi = function (t, e, n, i, r, s) {
                var o = new dn(t._pt, e, n, 0, 1, s ? qn : Xn);
                return t._pt = o, o.b = i, o.e = r, t._props.push(n), o
            },
            vi = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            _i = {
                grid: 1,
                flex: 1
            },
            yi = function t(e, n, i, r) {
                var s, o, a, l, c = parseFloat(i) || 0,
                    u = (i + "").trim().substr((c + "").length) || "px",
                    h = Rn.style,
                    d = zn.test(n),
                    f = "svg" === e.tagName.toLowerCase(),
                    p = (f ? "client" : "offset") + (d ? "Width" : "Height"),
                    m = 100,
                    g = "px" === r,
                    v = "%" === r;
                if (r === u || !c || vi[r] || vi[u]) return c;
                if ("px" !== u && !g && (c = t(e, n, i, "px")), l = e.getCTM && pi(e), (v || "%" === u) && (Dn[n] || ~n.indexOf("adius"))) return s = l ? e.getBBox()[d ? "width" : "height"] : e[p], pt(v ? c / s * m : c / 100 * s);
                if (h[d ? "width" : "height"] = m + (g ? u : r), o = ~n.indexOf("adius") || "em" === r && e.appendChild && !f ? e : e.parentNode, l && (o = (e.ownerSVGElement || {}).parentNode), o && o !== An && o.appendChild || (o = An.body), (a = o._gsap) && v && a.width && d && a.time === we.time && !a.uncache) return pt(c / a.width * m);
                if (!v || "height" !== n && "width" !== n)(v || "%" === u) && !_i[ai(o, "display")] && (h.position = ai(e, "position")), o === e && (h.position = "static"), o.appendChild(Rn), s = Rn[p], o.removeChild(Rn), h.position = "absolute";
                else {
                    var _ = e.style[n];
                    e.style[n] = m + r, s = e[p], _ ? e.style[n] = _ : mi(e, n)
                }
                return d && v && ((a = ht(o)).time = we.time, a.width = o[p]), pt(g ? s * c / m : s && c ? m / s * c : 0)
            },
            xi = function (t, e, n, i) {
                var r;
                return Cn || ui(), e in Hn && "transform" !== e && ~(e = Hn[e]).indexOf(",") && (e = e.split(",")[0]), Dn[e] && "transform" !== e ? (r = Oi(t, i), r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : Ii(ai(t, ei)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = wi[e] && wi[e](t, e, n) || ai(t, e) || dt(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? yi(t, e, r, n) + n : r
            },
            bi = function (t, e, n, i) {
                if (!n || "none" === n) {
                    var r = ci(e, t, 1),
                        s = r && ai(t, r, 1);
                    s && s !== n ? (e = r, n = s) : "borderColor" === e && (n = ai(t, "borderTopColor"))
                }
                var o, a, l, c, u, h, d, f, p, m, g, v = new dn(this._pt, t.style, e, 0, 1, on),
                    _ = 0,
                    y = 0;
                if (v.b = n, v.e = i, n += "", "auto" === (i += "") && (h = t.style[e], t.style[e] = i, i = ai(t, e) || i, h ? t.style[e] = h : mi(t, e)), Me(o = [n, i]), i = o[1], l = (n = o[0]).match(V) || [], (i.match(V) || []).length) {
                    for (; a = V.exec(i);) d = a[0], p = i.substring(_, a.index), u ? u = (u + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (u = 1), d !== (h = l[y++] || "") && (c = parseFloat(h) || 0, g = h.substr((c + "").length), "=" === d.charAt(1) && (d = gt(c, d) + g), f = parseFloat(d), m = d.substr((f + "").length), _ = V.lastIndex - m.length, m || (m = m || x.units[e] || g, _ === i.length && (i += m, v.e += m)), g !== m && (c = yi(t, e, h, m) || 0), v._pt = {
                        _next: v._pt,
                        p: p || 1 === y ? p : ",",
                        s: c,
                        c: f - c,
                        m: u && u < 4 || "zIndex" === e ? Math.round : 0
                    });
                    v.c = _ < i.length ? i.substring(_, i.length) : ""
                } else v.r = "display" === e && "none" === i ? qn : Xn;
                return W.test(i) && (v.e = 0), this._pt = v, v
            },
            Si = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            Ei = function (t) {
                var e = t.split(" "),
                    n = e[0],
                    i = e[1] || "50%";
                return "top" !== n && "bottom" !== n && "left" !== i && "right" !== i || (t = n, n = i, i = t), e[0] = Si[n] || n, e[1] = Si[i] || i, e.join(" ")
            },
            Mi = function (t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var n, i, r, s = e.t,
                        o = s.style,
                        a = e.u,
                        l = s._gsap;
                    if ("all" === a || !0 === a) o.cssText = "", i = 1;
                    else
                        for (r = (a = a.split(",")).length; --r > -1;) n = a[r], Dn[n] && (i = 1, n = "transformOrigin" === n ? ei : ti), mi(s, n);
                    i && (mi(s, ti), l && (l.svg && s.removeAttribute("transform"), Oi(s, 1), l.uncache = 1, ii(o)))
                }
            },
            wi = {
                clearProps: function (t, e, n, i, r) {
                    if ("isFromStart" !== r.data) {
                        var s = t._pt = new dn(t._pt, e, n, 0, 0, Mi);
                        return s.u = i, s.pr = -10, s.tween = r, t._props.push(n), 1
                    }
                }
            },
            Ti = [1, 0, 0, 1, 0, 0],
            Ai = {},
            Pi = function (t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            },
            Ci = function (t) {
                var e = ai(t, ti);
                return Pi(e) ? Ti : e.substr(7).match(H).map(pt)
            },
            Ri = function (t, e) {
                var n, i, r, s, o = t._gsap || ht(t),
                    a = t.style,
                    l = Ci(t);
                return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Ti : l : (l !== Ti || t.offsetParent || t === Pn || o.svg || (r = a.display, a.display = "block", (n = t.parentNode) && t.offsetParent || (s = 1, i = t.nextElementSibling, Pn.appendChild(t)), l = Ci(t), r ? a.display = r : mi(t, "display"), s && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : Pn.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            },
            Li = function (t, e, n, i, r, s) {
                var o, a, l, c = t._gsap,
                    u = r || Ri(t, !0),
                    h = c.xOrigin || 0,
                    d = c.yOrigin || 0,
                    f = c.xOffset || 0,
                    p = c.yOffset || 0,
                    m = u[0],
                    g = u[1],
                    v = u[2],
                    _ = u[3],
                    y = u[4],
                    x = u[5],
                    b = e.split(" "),
                    S = parseFloat(b[0]) || 0,
                    E = parseFloat(b[1]) || 0;
                n ? u !== Ti && (a = m * _ - g * v) && (l = S * (-g / a) + E * (m / a) - (m * x - g * y) / a, S = S * (_ / a) + E * (-v / a) + (v * x - _ * y) / a, E = l) : (S = (o = fi(t)).x + (~b[0].indexOf("%") ? S / 100 * o.width : S), E = o.y + (~(b[1] || b[0]).indexOf("%") ? E / 100 * o.height : E)), i || !1 !== i && c.smooth ? (y = S - h, x = E - d, c.xOffset = f + (y * m + x * v) - y, c.yOffset = p + (y * g + x * _) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = S, c.yOrigin = E, c.smooth = !!i, c.origin = e, c.originIsAbsolute = !!n, t.style[ei] = "0px 0px", s && (gi(s, c, "xOrigin", h, S), gi(s, c, "yOrigin", d, E), gi(s, c, "xOffset", f, c.xOffset), gi(s, c, "yOffset", p, c.yOffset)), t.setAttribute("data-svg-origin", S + " " + E)
            },
            Oi = function (t, e) {
                var n = t._gsap || new Fe(t);
                if ("x" in n && !e && !n.uncache) return n;
                var i, r, s, o, a, l, c, u, h, d, f, p, m, g, v, _, y, b, S, E, M, w, T, A, P, C, R, L, O, I, D, N, U = t.style,
                    k = n.scaleX < 0,
                    F = "px",
                    z = "deg",
                    B = getComputedStyle(t),
                    H = ai(t, ei) || "0";
                return i = r = s = l = c = u = h = d = f = 0, o = a = 1, n.svg = !(!t.getCTM || !pi(t)), B.translate && ("none" === B.translate && "none" === B.scale && "none" === B.rotate || (U[ti] = ("none" !== B.translate ? "translate3d(" + (B.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== B.rotate ? "rotate(" + B.rotate + ") " : "") + ("none" !== B.scale ? "scale(" + B.scale.split(" ").join(",") + ") " : "") + ("none" !== B[ti] ? B[ti] : "")), U.scale = U.rotate = U.translate = "none"), g = Ri(t, n.svg), n.svg && (n.uncache ? (P = t.getBBox(), H = n.xOrigin - P.x + "px " + (n.yOrigin - P.y) + "px", A = "") : A = !e && t.getAttribute("data-svg-origin"), Li(t, A || H, !!A || n.originIsAbsolute, !1 !== n.smooth, g)), p = n.xOrigin || 0, m = n.yOrigin || 0, g !== Ti && (b = g[0], S = g[1], E = g[2], M = g[3], i = w = g[4], r = T = g[5], 6 === g.length ? (o = Math.sqrt(b * b + S * S), a = Math.sqrt(M * M + E * E), l = b || S ? kn(S, b) * Nn : 0, (h = E || M ? kn(E, M) * Nn + l : 0) && (a *= Math.abs(Math.cos(h * Un))), n.svg && (i -= p - (p * b + m * E), r -= m - (p * S + m * M))) : (N = g[6], I = g[7], R = g[8], L = g[9], O = g[10], D = g[11], i = g[12], r = g[13], s = g[14], c = (v = kn(N, O)) * Nn, v && (A = w * (_ = Math.cos(-v)) + R * (y = Math.sin(-v)), P = T * _ + L * y, C = N * _ + O * y, R = w * -y + R * _, L = T * -y + L * _, O = N * -y + O * _, D = I * -y + D * _, w = A, T = P, N = C), u = (v = kn(-E, O)) * Nn, v && (_ = Math.cos(-v), D = M * (y = Math.sin(-v)) + D * _, b = A = b * _ - R * y, S = P = S * _ - L * y, E = C = E * _ - O * y), l = (v = kn(S, b)) * Nn, v && (A = b * (_ = Math.cos(v)) + S * (y = Math.sin(v)), P = w * _ + T * y, S = S * _ - b * y, T = T * _ - w * y, b = A, w = P), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), o = pt(Math.sqrt(b * b + S * S + E * E)), a = pt(Math.sqrt(T * T + N * N)), v = kn(w, T), h = Math.abs(v) > 2e-4 ? v * Nn : 0, f = D ? 1 / (D < 0 ? -D : D) : 0), n.svg && (A = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !Pi(ai(t, ti)), A && t.setAttribute("transform", A))), Math.abs(h) > 90 && Math.abs(h) < 270 && (k ? (o *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), e = e || n.uncache, n.x = i - ((n.xPercent = i && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + F, n.y = r - ((n.yPercent = r && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + F, n.z = s + F, n.scaleX = pt(o), n.scaleY = pt(a), n.rotation = pt(l) + z, n.rotationX = pt(c) + z, n.rotationY = pt(u) + z, n.skewX = h + z, n.skewY = d + z, n.transformPerspective = f + F, (n.zOrigin = parseFloat(H.split(" ")[2]) || !e && n.zOrigin || 0) && (U[ei] = Ii(H)), n.xOffset = n.yOffset = 0, n.force3D = x.force3D, n.renderTransform = n.svg ? Bi : In ? zi : Ni, n.uncache = 0, n
            },
            Ii = function (t) {
                return (t = t.split(" "))[0] + " " + t[1]
            },
            Di = function (t, e, n) {
                var i = Jt(e);
                return pt(parseFloat(e) + parseFloat(yi(t, "x", n + "px", i))) + i
            },
            Ni = function (t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, zi(t, e)
            },
            Ui = "0deg",
            ki = "0px",
            Fi = ") ",
            zi = function (t, e) {
                var n = e || this,
                    i = n.xPercent,
                    r = n.yPercent,
                    s = n.x,
                    o = n.y,
                    a = n.z,
                    l = n.rotation,
                    c = n.rotationY,
                    u = n.rotationX,
                    h = n.skewX,
                    d = n.skewY,
                    f = n.scaleX,
                    p = n.scaleY,
                    m = n.transformPerspective,
                    g = n.force3D,
                    v = n.target,
                    _ = n.zOrigin,
                    y = "",
                    x = "auto" === g && t && 1 !== t || !0 === g;
                if (_ && (u !== Ui || c !== Ui)) {
                    var b, S = parseFloat(c) * Un,
                        E = Math.sin(S),
                        M = Math.cos(S);
                    S = parseFloat(u) * Un, b = Math.cos(S), s = Di(v, s, E * b * -_), o = Di(v, o, -Math.sin(S) * -_), a = Di(v, a, M * b * -_ + _)
                }
                m !== ki && (y += "perspective(" + m + Fi), (i || r) && (y += "translate(" + i + "%, " + r + "%) "), (x || s !== ki || o !== ki || a !== ki) && (y += a !== ki || x ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + Fi), l !== Ui && (y += "rotate(" + l + Fi), c !== Ui && (y += "rotateY(" + c + Fi), u !== Ui && (y += "rotateX(" + u + Fi), h === Ui && d === Ui || (y += "skew(" + h + ", " + d + Fi), 1 === f && 1 === p || (y += "scale(" + f + ", " + p + Fi), v.style[ti] = y || "translate(0, 0)"
            },
            Bi = function (t, e) {
                var n, i, r, s, o, a = e || this,
                    l = a.xPercent,
                    c = a.yPercent,
                    u = a.x,
                    h = a.y,
                    d = a.rotation,
                    f = a.skewX,
                    p = a.skewY,
                    m = a.scaleX,
                    g = a.scaleY,
                    v = a.target,
                    _ = a.xOrigin,
                    y = a.yOrigin,
                    x = a.xOffset,
                    b = a.yOffset,
                    S = a.forceCSS,
                    E = parseFloat(u),
                    M = parseFloat(h);
                d = parseFloat(d), f = parseFloat(f), (p = parseFloat(p)) && (f += p = parseFloat(p), d += p), d || f ? (d *= Un, f *= Un, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - f) * -g, s = Math.cos(d - f) * g, f && (p *= Un, o = Math.tan(f - p), r *= o = Math.sqrt(1 + o * o), s *= o, p && (o = Math.tan(p), n *= o = Math.sqrt(1 + o * o), i *= o)), n = pt(n), i = pt(i), r = pt(r), s = pt(s)) : (n = m, s = g, i = r = 0), (E && !~(u + "").indexOf("px") || M && !~(h + "").indexOf("px")) && (E = yi(v, "x", u, "px"), M = yi(v, "y", h, "px")), (_ || y || x || b) && (E = pt(E + _ - (_ * n + y * r) + x), M = pt(M + y - (_ * i + y * s) + b)), (l || c) && (o = v.getBBox(), E = pt(E + l / 100 * o.width), M = pt(M + c / 100 * o.height)), o = "matrix(" + n + "," + i + "," + r + "," + s + "," + E + "," + M + ")", v.setAttribute("transform", o), S && (v.style[ti] = o)
            },
            Hi = function (t, e, n, i, r) {
                var s, o, a = 360,
                    l = R(r),
                    c = parseFloat(r) * (l && ~r.indexOf("rad") ? Nn : 1) - i,
                    u = i + c + "deg";
                return l && ("short" === (s = r.split("_")[1]) && (c %= a) !== c % 180 && (c += c < 0 ? a : -360), "cw" === s && c < 0 ? c = (c + 36e9) % a - ~~(c / a) * a : "ccw" === s && c > 0 && (c = (c - 36e9) % a - ~~(c / a) * a)), t._pt = o = new dn(t._pt, e, n, i, c, Gn), o.e = u, o.u = "deg", t._props.push(n), o
            },
            Vi = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            Gi = function (t, e, n) {
                var i, r, s, o, a, l, c, u = Vi({}, n._gsap),
                    h = n.style;
                for (r in u.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), h[ti] = e, i = Oi(n, 1), mi(n, ti), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[ti], h[ti] = e, i = Oi(n, 1), h[ti] = s), Dn)(s = u[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Jt(s) !== (c = Jt(o)) ? yi(n, r, s, c) : parseFloat(s), l = parseFloat(o), t._pt = new dn(t._pt, i, r, a, l - a, Vn), t._pt.u = c || 0, t._props.push(r));
                Vi(i, u)
            };
        ft("padding,margin,Width,Radius", (function (t, e) {
            var n = "Top",
                i = "Right",
                r = "Bottom",
                s = "Left",
                o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function (n) {
                    return e < 2 ? t + n : "border" + n + t
                }));
            wi[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
                var s, a;
                if (arguments.length < 4) return s = o.map((function (e) {
                    return xi(t, e, n)
                })), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
                s = (i + "").split(" "), a = {}, o.forEach((function (t, e) {
                    return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
                })), t.init(e, a, r)
            }
        }));
        var Wi, ji, Xi, qi = {
            name: "css",
            register: ui,
            targetTest: function (t) {
                return t.style && t.nodeType
            },
            init: function (t, e, n, i, r) {
                var s, o, a, l, c, u, h, d, f, p, m, g, v, _, y, b, S = this._props,
                    E = t.style,
                    M = n.vars.startAt;
                for (h in Cn || ui(), this.styles = this.styles || si(t), b = this.styles.props, this.tween = n, e)
                    if ("autoRound" !== h && (o = e[h], !st[h] || !je(h, e, n, i, t, r)))
                        if (c = typeof o, u = wi[h], "function" === c && (c = typeof (o = o.call(n, i, t, r))), "string" === c && ~o.indexOf("random(") && (o = ce(o)), u) u(this, t, h, o, n) && (y = 1);
                        else if ("--" === h.substr(0, 2)) s = (getComputedStyle(t).getPropertyValue(h) + "").trim(), o += "", Se.lastIndex = 0, Se.test(s) || (d = Jt(s), f = Jt(o)), f ? d !== f && (s = yi(t, h, s, f) + f) : d && (o += d), this.add(E, "setProperty", s, o, i, r, 0, 0, h), S.push(h), b.push(h, 0, E[h]);
                else if ("undefined" !== c) {
                    if (M && h in M ? (s = "function" == typeof M[h] ? M[h].call(n, i, t, r) : M[h], R(s) && ~s.indexOf("random(") && (s = ce(s)), Jt(s + "") || "auto" === s || (s += x.units[h] || Jt(xi(t, h)) || ""), "=" === (s + "").charAt(1) && (s = xi(t, h))) : s = xi(t, h), l = parseFloat(s), (p = "string" === c && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)), a = parseFloat(o), h in Hn && ("autoAlpha" === h && (1 === l && "hidden" === xi(t, "visibility") && a && (l = 0), b.push("visibility", 0, E.visibility), gi(this, E, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== h && "transform" !== h && ~(h = Hn[h]).indexOf(",") && (h = h.split(",")[0])), m = h in Dn)
                        if (this.styles.save(h), g || ((v = t._gsap).renderTransform && !e.parseTransform || Oi(t, e.parseTransform), _ = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new dn(this._pt, E, ti, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === h) this._pt = new dn(this._pt, v, "scaleY", v.scaleY, (p ? gt(v.scaleY, p + a) : a) - v.scaleY || 0, Vn), this._pt.u = 0, S.push("scaleY", h), h += "X";
                        else {
                            if ("transformOrigin" === h) {
                                b.push(ei, 0, E[ei]), o = Ei(o), v.svg ? Li(t, o, 0, _, 0, this) : ((f = parseFloat(o.split(" ")[2]) || 0) !== v.zOrigin && gi(this, v, "zOrigin", v.zOrigin, f), gi(this, E, h, Ii(s), Ii(o)));
                                continue
                            }
                            if ("svgOrigin" === h) {
                                Li(t, o, 1, _, 0, this);
                                continue
                            }
                            if (h in Ai) {
                                Hi(this, v, h, l, p ? gt(l, p + o) : o);
                                continue
                            }
                            if ("smoothOrigin" === h) {
                                gi(this, v, "smooth", v.smooth, o);
                                continue
                            }
                            if ("force3D" === h) {
                                v[h] = o;
                                continue
                            }
                            if ("transform" === h) {
                                Gi(this, o, t);
                                continue
                            }
                        }
                    else h in E || (h = ci(h) || h);
                    if (m || (a || 0 === a) && (l || 0 === l) && !Bn.test(o) && h in E) a || (a = 0), (d = (s + "").substr((l + "").length)) !== (f = Jt(o) || (h in x.units ? x.units[h] : d)) && (l = yi(t, h, s, f)), this._pt = new dn(this._pt, m ? v : E, h, l, (p ? gt(l, p + a) : a) - l, m || "px" !== f && "zIndex" !== h || !1 === e.autoRound ? Vn : jn), this._pt.u = f || 0, d !== f && "%" !== f && (this._pt.b = s, this._pt.r = Wn);
                    else if (h in E) bi.call(this, t, h, s, p ? p + o : o);
                    else if (h in t) this.add(t, h, s || t[h], p ? p + o : o, i, r);
                    else if ("parseTransform" !== h) continue;
                    m || (h in E ? b.push(h, 0, E[h]) : b.push(h, 1, s || t[h])), S.push(h)
                }
                y && hn(this)
            },
            render: function (t, e) {
                if (e.tween._time || !On())
                    for (var n = e._pt; n;) n.r(t, n.d), n = n._next;
                else e.styles.revert()
            },
            get: xi,
            aliases: Hn,
            getSetter: function (t, e, n) {
                var i = Hn[e];
                return i && i.indexOf(",") < 0 && (e = i), e in Dn && e !== ei && (t._gsap.x || xi(t, "x")) ? n && Ln === n ? "scale" === e ? Jn : Zn : (Ln = n || {}) && ("scale" === e ? $n : Qn) : t.style && !I(t.style[e]) ? Yn : ~e.indexOf("-") ? Kn : nn(t, e)
            },
            core: {
                _removeProperty: mi,
                _getMatrix: Ri
            }
        };
        wn.utils.checkPrefix = ci, wn.core.getStyleSaver = si, Xi = ft((Wi = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (ji = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
            Dn[t] = 1
        })), ft(ji, (function (t) {
            x.units[t] = "deg", Ai[t] = 1
        })), Hn[Xi[13]] = Wi + "," + ji, ft("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
            var e = t.split(":");
            Hn[e[1]] = Xi[e[0]]
        })), ft("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
            x.units[t] = "px"
        })), wn.registerPlugin(qi);
        var Yi = wn.registerPlugin(qi) || wn;
        Yi.core.Tween;

        function Ki(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        var Zi, Ji, $i, Qi, tr, er, nr, ir, rr, sr, or, ar, lr, cr = function () {
                return Zi || "undefined" != typeof window && (Zi = window.gsap) && Zi.registerPlugin && Zi
            },
            ur = 1,
            hr = [],
            dr = [],
            fr = [],
            pr = Date.now,
            mr = function (t, e) {
                return e
            },
            gr = function (t, e) {
                return ~fr.indexOf(t) && fr[fr.indexOf(t) + 1][e]
            },
            vr = function (t) {
                return !!~sr.indexOf(t)
            },
            _r = function (t, e, n, i, r) {
                return t.addEventListener(e, n, {
                    passive: !1 !== i,
                    capture: !!r
                })
            },
            yr = function (t, e, n, i) {
                return t.removeEventListener(e, n, !!i)
            },
            xr = "scrollLeft",
            br = "scrollTop",
            Sr = function () {
                return or && or.isPressed || dr.cache++
            },
            Er = function (t, e) {
                var n = function n(i) {
                    if (i || 0 === i) {
                        ur && ($i.history.scrollRestoration = "manual");
                        var r = or && or.isPressed;
                        i = n.v = Math.round(i) || (or && or.iOS ? 1 : 0), t(i), n.cacheID = dr.cache, r && mr("ss", i)
                    } else(e || dr.cache !== n.cacheID || mr("ref")) && (n.cacheID = dr.cache, n.v = t());
                    return n.v + n.offset
                };
                return n.offset = 0, t && n
            },
            Mr = {
                s: xr,
                p: "left",
                p2: "Left",
                os: "right",
                os2: "Right",
                d: "width",
                d2: "Width",
                a: "x",
                sc: Er((function (t) {
                    return arguments.length ? $i.scrollTo(t, wr.sc()) : $i.pageXOffset || Qi[xr] || tr[xr] || er[xr] || 0
                }))
            },
            wr = {
                s: br,
                p: "top",
                p2: "Top",
                os: "bottom",
                os2: "Bottom",
                d: "height",
                d2: "Height",
                a: "y",
                op: Mr,
                sc: Er((function (t) {
                    return arguments.length ? $i.scrollTo(Mr.sc(), t) : $i.pageYOffset || Qi[br] || tr[br] || er[br] || 0
                }))
            },
            Tr = function (t, e) {
                return (e && e._ctx && e._ctx.selector || Zi.utils.toArray)(t)[0] || ("string" == typeof t && !1 !== Zi.config().nullTargetWarn ? void 0 : null)
            },
            Ar = function (t, e) {
                var n = e.s,
                    i = e.sc;
                vr(t) && (t = Qi.scrollingElement || tr);
                var r = dr.indexOf(t),
                    s = i === wr.sc ? 1 : 2;
                !~r && (r = dr.push(t) - 1), dr[r + s] || _r(t, "scroll", Sr);
                var o = dr[r + s],
                    a = o || (dr[r + s] = Er(gr(t, n), !0) || (vr(t) ? i : Er((function (e) {
                        return arguments.length ? t[n] = e : t[n]
                    }))));
                return a.target = t, o || (a.smooth = "smooth" === Zi.getProperty(t, "scrollBehavior")), a
            },
            Pr = function (t, e, n) {
                var i = t,
                    r = t,
                    s = pr(),
                    o = s,
                    a = e || 50,
                    l = Math.max(500, 3 * a),
                    c = function (t, e) {
                        var l = pr();
                        e || l - s > a ? (r = i, i = t, o = s, s = l) : n ? i += t : i = r + (t - r) / (l - o) * (s - o)
                    };
                return {
                    update: c,
                    reset: function () {
                        r = i = n ? 0 : i, o = s = 0
                    },
                    getVelocity: function (t) {
                        var e = o,
                            a = r,
                            u = pr();
                        return (t || 0 === t) && t !== i && c(t), s === o || u - o > l ? 0 : (i + (n ? a : -a)) / ((n ? u : s) - e) * 1e3
                    }
                }
            },
            Cr = function (t, e) {
                return e && !t._gsapAllow && t.preventDefault(), t.changedTouches ? t.changedTouches[0] : t
            },
            Rr = function (t) {
                var e = Math.max.apply(Math, t),
                    n = Math.min.apply(Math, t);
                return Math.abs(e) >= Math.abs(n) ? e : n
            },
            Lr = function () {
                var t, e, n, i;
                (rr = Zi.core.globals().ScrollTrigger) && rr.core && (t = rr.core, e = t.bridge || {}, n = t._scrollers, i = t._proxies, n.push.apply(n, dr), i.push.apply(i, fr), dr = n, fr = i, mr = function (t, n) {
                    return e[t](n)
                })
            },
            Or = function (t) {
                return Zi = t || cr(), !Ji && Zi && "undefined" != typeof document && document.body && ($i = window, Qi = document, tr = Qi.documentElement, er = Qi.body, sr = [$i, Qi, tr, er], Zi.utils.clamp, lr = Zi.core.context || function () {}, ir = "onpointerenter" in er ? "pointer" : "mouse", nr = Ir.isTouch = $i.matchMedia && $i.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in $i || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, ar = Ir.eventTypes = ("ontouchstart" in tr ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in tr ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function () {
                    return ur = 0
                }), 500), Lr(), Ji = 1), Ji
            };
        Mr.op = wr, dr.cache = 0;
        var Ir = function () {
            function t(t) {
                this.init(t)
            }
            var e, n, i;
            return t.prototype.init = function (t) {
                Ji || Or(Zi), rr || Lr();
                var e = t.tolerance,
                    n = t.dragMinimum,
                    i = t.type,
                    r = t.target,
                    s = t.lineHeight,
                    o = t.debounce,
                    a = t.preventDefault,
                    l = t.onStop,
                    c = t.onStopDelay,
                    u = t.ignore,
                    h = t.wheelSpeed,
                    d = t.event,
                    f = t.onDragStart,
                    p = t.onDragEnd,
                    m = t.onDrag,
                    g = t.onPress,
                    v = t.onRelease,
                    _ = t.onRight,
                    y = t.onLeft,
                    x = t.onUp,
                    b = t.onDown,
                    S = t.onChangeX,
                    E = t.onChangeY,
                    M = t.onChange,
                    w = t.onToggleX,
                    T = t.onToggleY,
                    A = t.onHover,
                    P = t.onHoverEnd,
                    C = t.onMove,
                    R = t.ignoreCheck,
                    L = t.isNormalizer,
                    O = t.onGestureStart,
                    I = t.onGestureEnd,
                    D = t.onWheel,
                    N = t.onEnable,
                    U = t.onDisable,
                    k = t.onClick,
                    F = t.scrollSpeed,
                    z = t.capture,
                    B = t.allowClicks,
                    H = t.lockAxis,
                    V = t.onLockAxis;
                this.target = r = Tr(r) || tr, this.vars = t, u && (u = Zi.utils.toArray(u)), e = e || 1e-9, n = n || 0, h = h || 1, F = F || 1, i = i || "wheel,touch,pointer", o = !1 !== o, s || (s = parseFloat($i.getComputedStyle(er).lineHeight) || 22);
                var G, W, j, X, q, Y, K, Z = this,
                    J = 0,
                    $ = 0,
                    Q = t.passive || !a,
                    tt = Ar(r, Mr),
                    et = Ar(r, wr),
                    nt = tt(),
                    it = et(),
                    rt = ~i.indexOf("touch") && !~i.indexOf("pointer") && "pointerdown" === ar[0],
                    st = vr(r),
                    ot = r.ownerDocument || Qi,
                    at = [0, 0, 0],
                    lt = [0, 0, 0],
                    ct = 0,
                    ut = function () {
                        return ct = pr()
                    },
                    ht = function (t, e) {
                        return (Z.event = t) && u && ~u.indexOf(t.target) || e && rt && "touch" !== t.pointerType || R && R(t, e)
                    },
                    dt = function () {
                        var t = Z.deltaX = Rr(at),
                            n = Z.deltaY = Rr(lt),
                            i = Math.abs(t) >= e,
                            r = Math.abs(n) >= e;
                        M && (i || r) && M(Z, t, n, at, lt), i && (_ && Z.deltaX > 0 && _(Z), y && Z.deltaX < 0 && y(Z), S && S(Z), w && Z.deltaX < 0 != J < 0 && w(Z), J = Z.deltaX, at[0] = at[1] = at[2] = 0), r && (b && Z.deltaY > 0 && b(Z), x && Z.deltaY < 0 && x(Z), E && E(Z), T && Z.deltaY < 0 != $ < 0 && T(Z), $ = Z.deltaY, lt[0] = lt[1] = lt[2] = 0), (X || j) && (C && C(Z), j && (m(Z), j = !1), X = !1), Y && !(Y = !1) && V && V(Z), q && (D(Z), q = !1), G = 0
                    },
                    ft = function (t, e, n) {
                        at[n] += t, lt[n] += e, Z._vx.update(t), Z._vy.update(e), o ? G || (G = requestAnimationFrame(dt)) : dt()
                    },
                    pt = function (t, e) {
                        H && !K && (Z.axis = K = Math.abs(t) > Math.abs(e) ? "x" : "y", Y = !0), "y" !== K && (at[2] += t, Z._vx.update(t, !0)), "x" !== K && (lt[2] += e, Z._vy.update(e, !0)), o ? G || (G = requestAnimationFrame(dt)) : dt()
                    },
                    mt = function (t) {
                        if (!ht(t, 1)) {
                            var e = (t = Cr(t, a)).clientX,
                                i = t.clientY,
                                r = e - Z.x,
                                s = i - Z.y,
                                o = Z.isDragging;
                            Z.x = e, Z.y = i, (o || Math.abs(Z.startX - e) >= n || Math.abs(Z.startY - i) >= n) && (m && (j = !0), o || (Z.isDragging = !0), pt(r, s), o || f && f(Z))
                        }
                    },
                    gt = Z.onPress = function (t) {
                        ht(t, 1) || t && t.button || (Z.axis = K = null, W.pause(), Z.isPressed = !0, t = Cr(t), J = $ = 0, Z.startX = Z.x = t.clientX, Z.startY = Z.y = t.clientY, Z._vx.reset(), Z._vy.reset(), _r(L ? r : ot, ar[1], mt, Q, !0), Z.deltaX = Z.deltaY = 0, g && g(Z))
                    },
                    vt = Z.onRelease = function (t) {
                        if (!ht(t, 1)) {
                            yr(L ? r : ot, ar[1], mt, !0);
                            var e = !isNaN(Z.y - Z.startY),
                                n = Z.isDragging,
                                i = n && (Math.abs(Z.x - Z.startX) > 3 || Math.abs(Z.y - Z.startY) > 3),
                                s = Cr(t);
                            !i && e && (Z._vx.reset(), Z._vy.reset(), a && B && Zi.delayedCall(.08, (function () {
                                if (pr() - ct > 300 && !t.defaultPrevented)
                                    if (t.target.click) t.target.click();
                                    else if (ot.createEvent) {
                                    var e = ot.createEvent("MouseEvents");
                                    e.initMouseEvent("click", !0, !0, $i, 1, s.screenX, s.screenY, s.clientX, s.clientY, !1, !1, !1, !1, 0, null), t.target.dispatchEvent(e)
                                }
                            }))), Z.isDragging = Z.isGesturing = Z.isPressed = !1, l && n && !L && W.restart(!0), p && n && p(Z), v && v(Z, i)
                        }
                    },
                    _t = function (t) {
                        return t.touches && t.touches.length > 1 && (Z.isGesturing = !0) && O(t, Z.isDragging)
                    },
                    yt = function () {
                        return (Z.isGesturing = !1) || I(Z)
                    },
                    xt = function (t) {
                        if (!ht(t)) {
                            var e = tt(),
                                n = et();
                            ft((e - nt) * F, (n - it) * F, 1), nt = e, it = n, l && W.restart(!0)
                        }
                    },
                    bt = function (t) {
                        if (!ht(t)) {
                            t = Cr(t, a), D && (q = !0);
                            var e = (1 === t.deltaMode ? s : 2 === t.deltaMode ? $i.innerHeight : 1) * h;
                            ft(t.deltaX * e, t.deltaY * e, 0), l && !L && W.restart(!0)
                        }
                    },
                    St = function (t) {
                        if (!ht(t)) {
                            var e = t.clientX,
                                n = t.clientY,
                                i = e - Z.x,
                                r = n - Z.y;
                            Z.x = e, Z.y = n, X = !0, l && W.restart(!0), (i || r) && pt(i, r)
                        }
                    },
                    Et = function (t) {
                        Z.event = t, A(Z)
                    },
                    Mt = function (t) {
                        Z.event = t, P(Z)
                    },
                    wt = function (t) {
                        return ht(t) || Cr(t, a) && k(Z)
                    };
                W = Z._dc = Zi.delayedCall(c || .25, (function () {
                    Z._vx.reset(), Z._vy.reset(), W.pause(), l && l(Z)
                })).pause(), Z.deltaX = Z.deltaY = 0, Z._vx = Pr(0, 50, !0), Z._vy = Pr(0, 50, !0), Z.scrollX = tt, Z.scrollY = et, Z.isDragging = Z.isGesturing = Z.isPressed = !1, lr(this), Z.enable = function (t) {
                    return Z.isEnabled || (_r(st ? ot : r, "scroll", Sr), i.indexOf("scroll") >= 0 && _r(st ? ot : r, "scroll", xt, Q, z), i.indexOf("wheel") >= 0 && _r(r, "wheel", bt, Q, z), (i.indexOf("touch") >= 0 && nr || i.indexOf("pointer") >= 0) && (_r(r, ar[0], gt, Q, z), _r(ot, ar[2], vt), _r(ot, ar[3], vt), B && _r(r, "click", ut, !0, !0), k && _r(r, "click", wt), O && _r(ot, "gesturestart", _t), I && _r(ot, "gestureend", yt), A && _r(r, ir + "enter", Et), P && _r(r, ir + "leave", Mt), C && _r(r, ir + "move", St)), Z.isEnabled = !0, t && t.type && gt(t), N && N(Z)), Z
                }, Z.disable = function () {
                    Z.isEnabled && (hr.filter((function (t) {
                        return t !== Z && vr(t.target)
                    })).length || yr(st ? ot : r, "scroll", Sr), Z.isPressed && (Z._vx.reset(), Z._vy.reset(), yr(L ? r : ot, ar[1], mt, !0)), yr(st ? ot : r, "scroll", xt, z), yr(r, "wheel", bt, z), yr(r, ar[0], gt, z), yr(ot, ar[2], vt), yr(ot, ar[3], vt), yr(r, "click", ut, !0), yr(r, "click", wt), yr(ot, "gesturestart", _t), yr(ot, "gestureend", yt), yr(r, ir + "enter", Et), yr(r, ir + "leave", Mt), yr(r, ir + "move", St), Z.isEnabled = Z.isPressed = Z.isDragging = !1, U && U(Z))
                }, Z.kill = Z.revert = function () {
                    Z.disable();
                    var t = hr.indexOf(Z);
                    t >= 0 && hr.splice(t, 1), or === Z && (or = 0)
                }, hr.push(Z), L && vr(r) && (or = Z), Z.enable(d)
            }, e = t, (n = [{
                key: "velocityX",
                get: function () {
                    return this._vx.getVelocity()
                }
            }, {
                key: "velocityY",
                get: function () {
                    return this._vy.getVelocity()
                }
            }]) && Ki(e.prototype, n), i && Ki(e, i), t
        }();
        Ir.version = "3.12.5", Ir.create = function (t) {
            return new Ir(t)
        }, Ir.register = Or, Ir.getAll = function () {
            return hr.slice()
        }, Ir.getById = function (t) {
            return hr.filter((function (e) {
                return e.vars.id === t
            }))[0]
        }, cr() && Zi.registerPlugin(Ir);
        var Dr, Nr, Ur, kr, Fr, zr, Br, Hr, Vr, Gr, Wr, jr, Xr, qr, Yr, Kr, Zr, Jr, $r, Qr, ts, es, ns, is, rs, ss, os, as, ls, cs, us, hs, ds, fs, ps, ms, gs, vs, _s = 1,
            ys = Date.now,
            xs = ys(),
            bs = 0,
            Ss = 0,
            Es = function (t, e, n) {
                var i = ks(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
                return n["_" + e + "Clamp"] = i, i ? t.substr(6, t.length - 7) : t
            },
            Ms = function (t, e) {
                return !e || ks(t) && "clamp(" === t.substr(0, 6) ? t : "clamp(" + t + ")"
            },
            ws = function t() {
                return Ss && requestAnimationFrame(t)
            },
            Ts = function () {
                return qr = 1
            },
            As = function () {
                return qr = 0
            },
            Ps = function (t) {
                return t
            },
            Cs = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            Rs = function () {
                return "undefined" != typeof window
            },
            Ls = function () {
                return Dr || Rs() && (Dr = window.gsap) && Dr.registerPlugin && Dr
            },
            Os = function (t) {
                return !!~Br.indexOf(t)
            },
            Is = function (t) {
                return ("Height" === t ? us : Ur["inner" + t]) || Fr["client" + t] || zr["client" + t]
            },
            Ds = function (t) {
                return gr(t, "getBoundingClientRect") || (Os(t) ? function () {
                    return Yo.width = Ur.innerWidth, Yo.height = us, Yo
                } : function () {
                    return oo(t)
                })
            },
            Ns = function (t, e) {
                var n = e.s,
                    i = e.d2,
                    r = e.d,
                    s = e.a;
                return Math.max(0, (n = "scroll" + i) && (s = gr(t, n)) ? s() - Ds(t)()[r] : Os(t) ? (Fr[n] || zr[n]) - Is(i) : t[n] - t["offset" + i])
            },
            Us = function (t, e) {
                for (var n = 0; n < $r.length; n += 3)(!e || ~e.indexOf($r[n + 1])) && t($r[n], $r[n + 1], $r[n + 2])
            },
            ks = function (t) {
                return "string" == typeof t
            },
            Fs = function (t) {
                return "function" == typeof t
            },
            zs = function (t) {
                return "number" == typeof t
            },
            Bs = function (t) {
                return "object" == typeof t
            },
            Hs = function (t, e, n) {
                return t && t.progress(e ? 0 : 1) && n && t.pause()
            },
            Vs = function (t, e) {
                if (t.enabled) {
                    var n = t._ctx ? t._ctx.add((function () {
                        return e(t)
                    })) : e(t);
                    n && n.totalTime && (t.callbackAnimation = n)
                }
            },
            Gs = Math.abs,
            Ws = "left",
            js = "right",
            Xs = "bottom",
            qs = "width",
            Ys = "height",
            Ks = "Right",
            Zs = "Left",
            Js = "Top",
            $s = "Bottom",
            Qs = "padding",
            to = "margin",
            eo = "Width",
            no = "Height",
            io = "px",
            ro = function (t) {
                return Ur.getComputedStyle(t)
            },
            so = function (t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            oo = function (t, e) {
                var n = e && "matrix(1, 0, 0, 1, 0, 0)" !== ro(t)[Yr] && Dr.to(t, {
                        x: 0,
                        y: 0,
                        xPercent: 0,
                        yPercent: 0,
                        rotation: 0,
                        rotationX: 0,
                        rotationY: 0,
                        scale: 1,
                        skewX: 0,
                        skewY: 0
                    }).progress(1),
                    i = t.getBoundingClientRect();
                return n && n.progress(0).kill(), i
            },
            ao = function (t, e) {
                var n = e.d2;
                return t["offset" + n] || t["client" + n] || 0
            },
            lo = function (t) {
                var e, n = [],
                    i = t.labels,
                    r = t.duration();
                for (e in i) n.push(i[e] / r);
                return n
            },
            co = function (t) {
                var e = Dr.utils.snap(t),
                    n = Array.isArray(t) && t.slice(0).sort((function (t, e) {
                        return t - e
                    }));
                return n ? function (t, i, r) {
                    var s;
                    if (void 0 === r && (r = .001), !i) return e(t);
                    if (i > 0) {
                        for (t -= r, s = 0; s < n.length; s++)
                            if (n[s] >= t) return n[s];
                        return n[s - 1]
                    }
                    for (s = n.length, t += r; s--;)
                        if (n[s] <= t) return n[s];
                    return n[0]
                } : function (n, i, r) {
                    void 0 === r && (r = .001);
                    var s = e(n);
                    return !i || Math.abs(s - n) < r || s - n < 0 == i < 0 ? s : e(i < 0 ? n - t : n + t)
                }
            },
            uo = function (t, e, n, i) {
                return n.split(",").forEach((function (n) {
                    return t(e, n, i)
                }))
            },
            ho = function (t, e, n, i, r) {
                return t.addEventListener(e, n, {
                    passive: !i,
                    capture: !!r
                })
            },
            fo = function (t, e, n, i) {
                return t.removeEventListener(e, n, !!i)
            },
            po = function (t, e, n) {
                (n = n && n.wheelHandler) && (t(e, "wheel", n), t(e, "touchmove", n))
            },
            mo = {
                startColor: "green",
                endColor: "red",
                indent: 0,
                fontSize: "16px",
                fontWeight: "normal"
            },
            go = {
                toggleActions: "play",
                anticipatePin: 0
            },
            vo = {
                top: 0,
                left: 0,
                center: .5,
                bottom: 1,
                right: 1
            },
            _o = function (t, e) {
                if (ks(t)) {
                    var n = t.indexOf("="),
                        i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
                    ~n && (t.indexOf("%") > n && (i *= e / 100), t = t.substr(0, n - 1)), t = i + (t in vo ? vo[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
                }
                return t
            },
            yo = function (t, e, n, i, r, s, o, a) {
                var l = r.startColor,
                    c = r.endColor,
                    u = r.fontSize,
                    h = r.indent,
                    d = r.fontWeight,
                    f = kr.createElement("div"),
                    p = Os(n) || "fixed" === gr(n, "pinType"),
                    m = -1 !== t.indexOf("scroller"),
                    g = p ? zr : n,
                    v = -1 !== t.indexOf("start"),
                    _ = v ? l : c,
                    y = "border-color:" + _ + ";font-size:" + u + ";color:" + _ + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                return y += "position:" + ((m || a) && p ? "fixed;" : "absolute;"), (m || a || !p) && (y += (i === wr ? js : Xs) + ":" + (s + parseFloat(h)) + "px;"), o && (y += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), f._isStart = v, f.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")), f.style.cssText = y, f.innerText = e || 0 === e ? t + "-" + e : t, g.children[0] ? g.insertBefore(f, g.children[0]) : g.appendChild(f), f._offset = f["offset" + i.op.d2], xo(f, 0, i, v), f
            },
            xo = function (t, e, n, i) {
                var r = {
                        display: "block"
                    },
                    s = n[i ? "os2" : "p2"],
                    o = n[i ? "p2" : "os2"];
                t._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + s + eo] = 1, r["border" + o + eo] = 0, r[n.p] = e + "px", Dr.set(t, r)
            },
            bo = [],
            So = {},
            Eo = function () {
                return ys() - bs > 34 && (ps || (ps = requestAnimationFrame(Ho)))
            },
            Mo = function () {
                (!ns || !ns.isPressed || ns.startX > zr.clientWidth) && (dr.cache++, ns ? ps || (ps = requestAnimationFrame(Ho)) : Ho(), bs || Ro("scrollStart"), bs = ys())
            },
            wo = function () {
                ss = Ur.innerWidth, rs = Ur.innerHeight
            },
            To = function () {
                dr.cache++, !Xr && !es && !kr.fullscreenElement && !kr.webkitFullscreenElement && (!is || ss !== Ur.innerWidth || Math.abs(Ur.innerHeight - rs) > .25 * Ur.innerHeight) && Hr.restart(!0)
            },
            Ao = {},
            Po = [],
            Co = function t() {
                return fo(ea, "scrollEnd", t) || Fo(!0)
            },
            Ro = function (t) {
                return Ao[t] && Ao[t].map((function (t) {
                    return t()
                })) || Po
            },
            Lo = [],
            Oo = function (t) {
                for (var e = 0; e < Lo.length; e += 5)(!t || Lo[e + 4] && Lo[e + 4].query === t) && (Lo[e].style.cssText = Lo[e + 1], Lo[e].getBBox && Lo[e].setAttribute("transform", Lo[e + 2] || ""), Lo[e + 3].uncache = 1)
            },
            Io = function (t, e) {
                var n;
                for (Kr = 0; Kr < bo.length; Kr++) !(n = bo[Kr]) || e && n._ctx !== e || (t ? n.kill(1) : n.revert(!0, !0));
                hs = !0, e && Oo(e), e || Ro("revert")
            },
            Do = function (t, e) {
                dr.cache++, (e || !ms) && dr.forEach((function (t) {
                    return Fs(t) && t.cacheID++ && (t.rec = 0)
                })), ks(t) && (Ur.history.scrollRestoration = ls = t)
            },
            No = 0,
            Uo = function () {
                zr.appendChild(cs), us = !ns && cs.offsetHeight || Ur.innerHeight, zr.removeChild(cs)
            },
            ko = function (t) {
                return Vr(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach((function (e) {
                    return e.style.display = t ? "none" : "block"
                }))
            },
            Fo = function (t, e) {
                if (!bs || t || hs) {
                    Uo(), ms = ea.isRefreshing = !0, dr.forEach((function (t) {
                        return Fs(t) && ++t.cacheID && (t.rec = t())
                    }));
                    var n = Ro("refreshInit");
                    Qr && ea.sort(), e || Io(), dr.forEach((function (t) {
                        Fs(t) && (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0))
                    })), bo.slice(0).forEach((function (t) {
                        return t.refresh()
                    })), hs = !1, bo.forEach((function (t) {
                        if (t._subPinOffset && t.pin) {
                            var e = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                n = t.pin[e];
                            t.revert(!0, 1), t.adjustPinSpacing(t.pin[e] - n), t.refresh()
                        }
                    })), ds = 1, ko(!0), bo.forEach((function (t) {
                        var e = Ns(t.scroller, t._dir),
                            n = "max" === t.vars.end || t._endClamp && t.end > e,
                            i = t._startClamp && t.start >= e;
                        (n || i) && t.setPositions(i ? e - 1 : t.start, n ? Math.max(i ? e : t.start + 1, e) : t.end, !0)
                    })), ko(!1), ds = 0, n.forEach((function (t) {
                        return t && t.render && t.render(-1)
                    })), dr.forEach((function (t) {
                        Fs(t) && (t.smooth && requestAnimationFrame((function () {
                            return t.target.style.scrollBehavior = "smooth"
                        })), t.rec && t(t.rec))
                    })), Do(ls, 1), Hr.pause(), No++, ms = 2, Ho(2), bo.forEach((function (t) {
                        return Fs(t.vars.onRefresh) && t.vars.onRefresh(t)
                    })), ms = ea.isRefreshing = !1, Ro("refresh")
                } else ho(ea, "scrollEnd", Co)
            },
            zo = 0,
            Bo = 1,
            Ho = function (t) {
                if (2 === t || !ms && !hs) {
                    ea.isUpdating = !0, vs && vs.update(0);
                    var e = bo.length,
                        n = ys(),
                        i = n - xs >= 50,
                        r = e && bo[0].scroll();
                    if (Bo = zo > r ? -1 : 1, ms || (zo = r), i && (bs && !qr && n - bs > 200 && (bs = 0, Ro("scrollEnd")), Wr = xs, xs = n), Bo < 0) {
                        for (Kr = e; Kr-- > 0;) bo[Kr] && bo[Kr].update(0, i);
                        Bo = 1
                    } else
                        for (Kr = 0; Kr < e; Kr++) bo[Kr] && bo[Kr].update(0, i);
                    ea.isUpdating = !1
                }
                ps = 0
            },
            Vo = [Ws, "top", Xs, js, to + $s, to + Ks, to + Js, to + Zs, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
            Go = Vo.concat([qs, Ys, "boxSizing", "max" + eo, "max" + no, "position", to, Qs, Qs + Js, Qs + Ks, Qs + $s, Qs + Zs]),
            Wo = function (t, e, n, i) {
                if (!t._gsap.swappedIn) {
                    for (var r, s = Vo.length, o = e.style, a = t.style; s--;) o[r = Vo[s]] = n[r];
                    o.position = "absolute" === n.position ? "absolute" : "relative", "inline" === n.display && (o.display = "inline-block"), a[Xs] = a[js] = "auto", o.flexBasis = n.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[qs] = ao(t, Mr) + io, o[Ys] = ao(t, wr) + io, o[Qs] = a[to] = a.top = a[Ws] = "0", Xo(i), a[qs] = a["max" + eo] = n[qs], a[Ys] = a["max" + no] = n[Ys], a[Qs] = n[Qs], t.parentNode !== e && (t.parentNode.insertBefore(e, t), e.appendChild(t)), t._gsap.swappedIn = !0
                }
            },
            jo = /([A-Z])/g,
            Xo = function (t) {
                if (t) {
                    var e, n, i = t.t.style,
                        r = t.length,
                        s = 0;
                    for ((t.t._gsap || Dr.core.getCache(t.t)).uncache = 1; s < r; s += 2) n = t[s + 1], e = t[s], n ? i[e] = n : i[e] && i.removeProperty(e.replace(jo, "-$1").toLowerCase())
                }
            },
            qo = function (t) {
                for (var e = Go.length, n = t.style, i = [], r = 0; r < e; r++) i.push(Go[r], n[Go[r]]);
                return i.t = t, i
            },
            Yo = {
                left: 0,
                top: 0
            },
            Ko = function (t, e, n, i, r, s, o, a, l, c, u, h, d, f) {
                Fs(t) && (t = t(a)), ks(t) && "max" === t.substr(0, 3) && (t = h + ("=" === t.charAt(4) ? _o("0" + t.substr(3), n) : 0));
                var p, m, g, v = d ? d.time() : 0;
                if (d && d.seek(0), isNaN(t) || (t = +t), zs(t)) d && (t = Dr.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, h, t)), o && xo(o, n, i, !0);
                else {
                    Fs(e) && (e = e(a));
                    var _, y, x, b, S = (t || "0").split(" ");
                    g = Tr(e, a) || zr, (_ = oo(g) || {}) && (_.left || _.top) || "none" !== ro(g).display || (b = g.style.display, g.style.display = "block", _ = oo(g), b ? g.style.display = b : g.style.removeProperty("display")), y = _o(S[0], _[i.d]), x = _o(S[1] || "0", n), t = _[i.p] - l[i.p] - c + y + r - x, o && xo(o, x, i, n - x < 20 || o._isStart && x > 20), n -= n - x
                }
                if (f && (a[f] = t || -.001, t < 0 && (t = 0)), s) {
                    var E = t + n,
                        M = s._isStart;
                    p = "scroll" + i.d2, xo(s, E, i, M && E > 20 || !M && (u ? Math.max(zr[p], Fr[p]) : s.parentNode[p]) <= E + 1), u && (l = oo(o), u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + io))
                }
                return d && g && (p = oo(g), d.seek(h), m = oo(g), d._caScrollDist = p[i.p] - m[i.p], t = t / d._caScrollDist * h), d && d.seek(v), d ? t : Math.round(t)
            },
            Zo = /(webkit|moz|length|cssText|inset)/i,
            Jo = function (t, e, n, i) {
                if (t.parentNode !== e) {
                    var r, s, o = t.style;
                    if (e === zr) {
                        for (r in t._stOrig = o.cssText, s = ro(t)) + r || Zo.test(r) || !s[r] || "string" != typeof o[r] || "0" === r || (o[r] = s[r]);
                        o.top = n, o.left = i
                    } else o.cssText = t._stOrig;
                    Dr.core.getCache(t).uncache = 1, e.appendChild(t)
                }
            },
            $o = function (t, e, n) {
                var i = e,
                    r = i;
                return function (e) {
                    var s = Math.round(t());
                    return s !== i && s !== r && Math.abs(s - i) > 3 && Math.abs(s - r) > 3 && (e = s, n && n()), r = i, i = e, e
                }
            },
            Qo = function (t, e, n) {
                var i = {};
                i[e.p] = "+=" + n, Dr.set(t, i)
            },
            ta = function (t, e) {
                var n = Ar(t, e),
                    i = "_scroll" + e.p2,
                    r = function e(r, s, o, a, l) {
                        var c = e.tween,
                            u = s.onComplete,
                            h = {};
                        o = o || n();
                        var d = $o(n, o, (function () {
                            c.kill(), e.tween = 0
                        }));
                        return l = a && l || 0, a = a || r - o, c && c.kill(), s[i] = r, s.inherit = !1, s.modifiers = h, h[i] = function () {
                            return d(o + a * c.ratio + l * c.ratio * c.ratio)
                        }, s.onUpdate = function () {
                            dr.cache++, e.tween && Ho()
                        }, s.onComplete = function () {
                            e.tween = 0, u && u.call(c)
                        }, c = e.tween = Dr.to(t, s)
                    };
                return t[i] = n, n.wheelHandler = function () {
                    return r.tween && r.tween.kill() && (r.tween = 0)
                }, ho(t, "wheel", n.wheelHandler), ea.isTouch && ho(t, "touchmove", n.wheelHandler), r
            },
            ea = function () {
                function t(e, n) {
                    Nr || t.register(Dr), as(this), this.init(e, n)
                }
                return t.prototype.init = function (e, n) {
                    if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), Ss) {
                        var i, r, s, o, a, l, c, u, h, d, f, p, m, g, v, _, y, x, b, S, E, M, w, T, A, P, C, R, L, O, I, D, N, U, k, F, z, B, H, V, G, W, j = e = so(ks(e) || zs(e) || e.nodeType ? {
                                trigger: e
                            } : e, go),
                            X = j.onUpdate,
                            q = j.toggleClass,
                            Y = j.id,
                            K = j.onToggle,
                            Z = j.onRefresh,
                            J = j.scrub,
                            $ = j.trigger,
                            Q = j.pin,
                            tt = j.pinSpacing,
                            et = j.invalidateOnRefresh,
                            nt = j.anticipatePin,
                            it = j.onScrubComplete,
                            rt = j.onSnapComplete,
                            st = j.once,
                            ot = j.snap,
                            at = j.pinReparent,
                            lt = j.pinSpacer,
                            ct = j.containerAnimation,
                            ut = j.fastScrollEnd,
                            ht = j.preventOverlaps,
                            dt = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? Mr : wr,
                            ft = !J && 0 !== J,
                            pt = Tr(e.scroller || Ur),
                            mt = Dr.core.getCache(pt),
                            gt = Os(pt),
                            vt = "fixed" === ("pinType" in e ? e.pinType : gr(pt, "pinType") || gt && "fixed"),
                            _t = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                            yt = ft && e.toggleActions.split(" "),
                            xt = "markers" in e ? e.markers : go.markers,
                            bt = gt ? 0 : parseFloat(ro(pt)["border" + dt.p2 + eo]) || 0,
                            St = this,
                            Et = e.onRefreshInit && function () {
                                return e.onRefreshInit(St)
                            },
                            Mt = function (t, e, n) {
                                var i = n.d,
                                    r = n.d2,
                                    s = n.a;
                                return (s = gr(t, "getBoundingClientRect")) ? function () {
                                    return s()[i]
                                } : function () {
                                    return (e ? Is(r) : t["client" + r]) || 0
                                }
                            }(pt, gt, dt),
                            wt = function (t, e) {
                                return !e || ~fr.indexOf(t) ? Ds(t) : function () {
                                    return Yo
                                }
                            }(pt, gt),
                            Tt = 0,
                            At = 0,
                            Pt = 0,
                            Ct = Ar(pt, dt);
                        if (St._startClamp = St._endClamp = !1, St._dir = dt, nt *= 45, St.scroller = pt, St.scroll = ct ? ct.time.bind(ct) : Ct, o = Ct(), St.vars = e, n = n || e.animation, "refreshPriority" in e && (Qr = 1, -9999 === e.refreshPriority && (vs = St)), mt.tweenScroll = mt.tweenScroll || {
                                top: ta(pt, wr),
                                left: ta(pt, Mr)
                            }, St.tweenTo = i = mt.tweenScroll[dt.p], St.scrubDuration = function (t) {
                                (N = zs(t) && t) ? D ? D.duration(t) : D = Dr.to(n, {
                                    ease: "expo",
                                    totalProgress: "+=0",
                                    inherit: !1,
                                    duration: N,
                                    paused: !0,
                                    onComplete: function () {
                                        return it && it(St)
                                    }
                                }): (D && D.progress(1).kill(), D = 0)
                            }, n && (n.vars.lazy = !1, n._initted && !St.isReverted || !1 !== n.vars.immediateRender && !1 !== e.immediateRender && n.duration() && n.render(0, !0, !0), St.animation = n.pause(), n.scrollTrigger = St, St.scrubDuration(J), O = 0, Y || (Y = n.vars.id)), ot && (Bs(ot) && !ot.push || (ot = {
                                snapTo: ot
                            }), "scrollBehavior" in zr.style && Dr.set(gt ? [zr, Fr] : pt, {
                                scrollBehavior: "auto"
                            }), dr.forEach((function (t) {
                                return Fs(t) && t.target === (gt ? kr.scrollingElement || Fr : pt) && (t.smooth = !1)
                            })), s = Fs(ot.snapTo) ? ot.snapTo : "labels" === ot.snapTo ? function (t) {
                                return function (e) {
                                    return Dr.utils.snap(lo(t), e)
                                }
                            }(n) : "labelsDirectional" === ot.snapTo ? (V = n, function (t, e) {
                                return co(lo(V))(t, e.direction)
                            }) : !1 !== ot.directional ? function (t, e) {
                                return co(ot.snapTo)(t, ys() - At < 500 ? 0 : e.direction)
                            } : Dr.utils.snap(ot.snapTo), U = ot.duration || {
                                min: .1,
                                max: 2
                            }, U = Bs(U) ? Gr(U.min, U.max) : Gr(U, U), k = Dr.delayedCall(ot.delay || N / 2 || .1, (function () {
                                var t = Ct(),
                                    e = ys() - At < 500,
                                    r = i.tween;
                                if (!(e || Math.abs(St.getVelocity()) < 10) || r || qr || Tt === t) St.isActive && Tt !== t && k.restart(!0);
                                else {
                                    var o, a, u = (t - l) / g,
                                        h = n && !ft ? n.totalProgress() : u,
                                        d = e ? 0 : (h - I) / (ys() - Wr) * 1e3 || 0,
                                        f = Dr.utils.clamp(-u, 1 - u, Gs(d / 2) * d / .185),
                                        p = u + (!1 === ot.inertia ? 0 : f),
                                        m = ot,
                                        v = m.onStart,
                                        _ = m.onInterrupt,
                                        y = m.onComplete;
                                    if (o = s(p, St), zs(o) || (o = p), a = Math.round(l + o * g), t <= c && t >= l && a !== t) {
                                        if (r && !r._initted && r.data <= Gs(a - t)) return;
                                        !1 === ot.inertia && (f = o - u), i(a, {
                                            duration: U(Gs(.185 * Math.max(Gs(p - h), Gs(o - h)) / d / .05 || 0)),
                                            ease: ot.ease || "power3",
                                            data: Gs(a - t),
                                            onInterrupt: function () {
                                                return k.restart(!0) && _ && _(St)
                                            },
                                            onComplete: function () {
                                                St.update(), Tt = Ct(), n && (D ? D.resetTo("totalProgress", o, n._tTime / n._tDur) : n.progress(o)), O = I = n && !ft ? n.totalProgress() : St.progress, rt && rt(St), y && y(St)
                                            }
                                        }, t, f * g, a - t - f * g), v && v(St, i.tween)
                                    }
                                }
                            })).pause()), Y && (So[Y] = St), (H = ($ = St.trigger = Tr($ || !0 !== Q && Q)) && $._gsap && $._gsap.stRevert) && (H = H(St)), Q = !0 === Q ? $ : Tr(Q), ks(q) && (q = {
                                targets: $,
                                className: q
                            }), Q && (!1 === tt || tt === to || (tt = !(!tt && Q.parentNode && Q.parentNode.style && "flex" === ro(Q.parentNode).display) && Qs), St.pin = Q, (r = Dr.core.getCache(Q)).spacer ? v = r.pinState : (lt && ((lt = Tr(lt)) && !lt.nodeType && (lt = lt.current || lt.nativeElement), r.spacerIsNative = !!lt, lt && (r.spacerState = qo(lt))), r.spacer = x = lt || kr.createElement("div"), x.classList.add("pin-spacer"), Y && x.classList.add("pin-spacer-" + Y), r.pinState = v = qo(Q)), !1 !== e.force3D && Dr.set(Q, {
                                force3D: !0
                            }), St.spacer = x = r.spacer, L = ro(Q), T = L[tt + dt.os2], S = Dr.getProperty(Q), E = Dr.quickSetter(Q, dt.a, io), Wo(Q, x, L), y = qo(Q)), xt) {
                            p = Bs(xt) ? so(xt, mo) : mo, d = yo("scroller-start", Y, pt, dt, p, 0), f = yo("scroller-end", Y, pt, dt, p, 0, d), b = d["offset" + dt.op.d2];
                            var Rt = Tr(gr(pt, "content") || pt);
                            u = this.markerStart = yo("start", Y, Rt, dt, p, b, 0, ct), h = this.markerEnd = yo("end", Y, Rt, dt, p, b, 0, ct), ct && (B = Dr.quickSetter([u, h], dt.a, io)), vt || fr.length && !0 === gr(pt, "fixedMarkers") || (W = ro(G = gt ? zr : pt).position, G.style.position = "absolute" === W || "fixed" === W ? W : "relative", Dr.set([d, f], {
                                force3D: !0
                            }), P = Dr.quickSetter(d, dt.a, io), R = Dr.quickSetter(f, dt.a, io))
                        }
                        if (ct) {
                            var Lt = ct.vars.onUpdate,
                                Ot = ct.vars.onUpdateParams;
                            ct.eventCallback("onUpdate", (function () {
                                St.update(0, 0, 1), Lt && Lt.apply(ct, Ot || [])
                            }))
                        }
                        if (St.previous = function () {
                                return bo[bo.indexOf(St) - 1]
                            }, St.next = function () {
                                return bo[bo.indexOf(St) + 1]
                            }, St.revert = function (t, e) {
                                if (!e) return St.kill(!0);
                                var i = !1 !== t || !St.enabled,
                                    r = Xr;
                                i !== St.isReverted && (i && (F = Math.max(Ct(), St.scroll.rec || 0), Pt = St.progress, z = n && n.progress()), u && [u, h, d, f].forEach((function (t) {
                                    return t.style.display = i ? "none" : "block"
                                })), i && (Xr = St, St.update(i)), !Q || at && St.isActive || (i ? function (t, e, n) {
                                    Xo(n);
                                    var i = t._gsap;
                                    if (i.spacerIsNative) Xo(i.spacerState);
                                    else if (t._gsap.swappedIn) {
                                        var r = e.parentNode;
                                        r && (r.insertBefore(t, e), r.removeChild(e))
                                    }
                                    t._gsap.swappedIn = !1
                                }(Q, x, v) : Wo(Q, x, ro(Q), A)), i || St.update(i), Xr = r, St.isReverted = i)
                            }, St.refresh = function (r, s, p, b) {
                                if (!Xr && St.enabled || s)
                                    if (Q && r && bs) ho(t, "scrollEnd", Co);
                                    else {
                                        !ms && Et && Et(St), Xr = St, i.tween && !p && (i.tween.kill(), i.tween = 0), D && D.pause(), et && n && n.revert({
                                            kill: !1
                                        }).invalidate(), St.isReverted || St.revert(!0, !0), St._subPinOffset = !1;
                                        var E, T, P, R, L, O, I, N, U, B, H, V, G, W = Mt(),
                                            j = wt(),
                                            X = ct ? ct.duration() : Ns(pt, dt),
                                            q = g <= .01,
                                            Y = 0,
                                            K = b || 0,
                                            J = Bs(p) ? p.end : e.end,
                                            nt = e.endTrigger || $,
                                            it = Bs(p) ? p.start : e.start || (0 !== e.start && $ ? Q ? "0 0" : "0 100%" : 0),
                                            rt = St.pinnedContainer = e.pinnedContainer && Tr(e.pinnedContainer, St),
                                            st = $ && Math.max(0, bo.indexOf(St)) || 0,
                                            ot = st;
                                        for (xt && Bs(p) && (V = Dr.getProperty(d, dt.p), G = Dr.getProperty(f, dt.p)); ot--;)(O = bo[ot]).end || O.refresh(0, 1) || (Xr = St), !(I = O.pin) || I !== $ && I !== Q && I !== rt || O.isReverted || (B || (B = []), B.unshift(O), O.revert(!0, !0)), O !== bo[ot] && (st--, ot--);
                                        for (Fs(it) && (it = it(St)), it = Es(it, "start", St), l = Ko(it, $, W, dt, Ct(), u, d, St, j, bt, vt, X, ct, St._startClamp && "_startClamp") || (Q ? -.001 : 0), Fs(J) && (J = J(St)), ks(J) && !J.indexOf("+=") && (~J.indexOf(" ") ? J = (ks(it) ? it.split(" ")[0] : "") + J : (Y = _o(J.substr(2), W), J = ks(it) ? it : (ct ? Dr.utils.mapRange(0, ct.duration(), ct.scrollTrigger.start, ct.scrollTrigger.end, l) : l) + Y, nt = $)), J = Es(J, "end", St), c = Math.max(l, Ko(J || (nt ? "100% 0" : X), nt, W, dt, Ct() + Y, h, f, St, j, bt, vt, X, ct, St._endClamp && "_endClamp")) || -.001, Y = 0, ot = st; ot--;)(I = (O = bo[ot]).pin) && O.start - O._pinPush <= l && !ct && O.end > 0 && (E = O.end - (St._startClamp ? Math.max(0, O.start) : O.start), (I === $ && O.start - O._pinPush < l || I === rt) && isNaN(it) && (Y += E * (1 - O.progress)), I === Q && (K += E));
                                        if (l += Y, c += Y, St._startClamp && (St._startClamp += Y), St._endClamp && !ms && (St._endClamp = c || -.001, c = Math.min(c, Ns(pt, dt))), g = c - l || (l -= .01) && .001, q && (Pt = Dr.utils.clamp(0, 1, Dr.utils.normalize(l, c, F))), St._pinPush = K, u && Y && ((E = {})[dt.a] = "+=" + Y, rt && (E[dt.p] = "-=" + Ct()), Dr.set([u, h], E)), !Q || ds && St.end >= Ns(pt, dt)) {
                                            if ($ && Ct() && !ct)
                                                for (T = $.parentNode; T && T !== zr;) T._pinOffset && (l -= T._pinOffset, c -= T._pinOffset), T = T.parentNode
                                        } else E = ro(Q), R = dt === wr, P = Ct(), M = parseFloat(S(dt.a)) + K, !X && c > 1 && (H = {
                                            style: H = (gt ? kr.scrollingElement || Fr : pt).style,
                                            value: H["overflow" + dt.a.toUpperCase()]
                                        }, gt && "scroll" !== ro(zr)["overflow" + dt.a.toUpperCase()] && (H.style["overflow" + dt.a.toUpperCase()] = "scroll")), Wo(Q, x, E), y = qo(Q), T = oo(Q, !0), N = vt && Ar(pt, R ? Mr : wr)(), tt ? ((A = [tt + dt.os2, g + K + io]).t = x, (ot = tt === Qs ? ao(Q, dt) + g + K : 0) && (A.push(dt.d, ot + io), "auto" !== x.style.flexBasis && (x.style.flexBasis = ot + io)), Xo(A), rt && bo.forEach((function (t) {
                                            t.pin === rt && !1 !== t.vars.pinSpacing && (t._subPinOffset = !0)
                                        })), vt && Ct(F)) : (ot = ao(Q, dt)) && "auto" !== x.style.flexBasis && (x.style.flexBasis = ot + io), vt && ((L = {
                                            top: T.top + (R ? P - l : N) + io,
                                            left: T.left + (R ? N : P - l) + io,
                                            boxSizing: "border-box",
                                            position: "fixed"
                                        })[qs] = L["max" + eo] = Math.ceil(T.width) + io, L[Ys] = L["max" + no] = Math.ceil(T.height) + io, L[to] = L[to + Js] = L[to + Ks] = L[to + $s] = L[to + Zs] = "0", L[Qs] = E[Qs], L[Qs + Js] = E[Qs + Js], L[Qs + Ks] = E[Qs + Ks], L[Qs + $s] = E[Qs + $s], L[Qs + Zs] = E[Qs + Zs], _ = function (t, e, n) {
                                            for (var i, r = [], s = t.length, o = n ? 8 : 0; o < s; o += 2) i = t[o], r.push(i, i in e ? e[i] : t[o + 1]);
                                            return r.t = t.t, r
                                        }(v, L, at), ms && Ct(0)), n ? (U = n._initted, ts(1), n.render(n.duration(), !0, !0), w = S(dt.a) - M + g + K, C = Math.abs(g - w) > 1, vt && C && _.splice(_.length - 2, 2), n.render(0, !0, !0), U || n.invalidate(!0), n.parent || n.totalTime(n.totalTime()), ts(0)) : w = g, H && (H.value ? H.style["overflow" + dt.a.toUpperCase()] = H.value : H.style.removeProperty("overflow-" + dt.a));
                                        B && B.forEach((function (t) {
                                            return t.revert(!1, !0)
                                        })), St.start = l, St.end = c, o = a = ms ? F : Ct(), ct || ms || (o < F && Ct(F), St.scroll.rec = 0), St.revert(!1, !0), At = ys(), k && (Tt = -1, k.restart(!0)), Xr = 0, n && ft && (n._initted || z) && n.progress() !== z && n.progress(z || 0, !0).render(n.time(), !0, !0), (q || Pt !== St.progress || ct || et) && (n && !ft && n.totalProgress(ct && l < -.001 && !Pt ? Dr.utils.normalize(l, c, 0) : Pt, !0), St.progress = q || (o - l) / g === Pt ? 0 : Pt), Q && tt && (x._pinOffset = Math.round(St.progress * w)), D && D.invalidate(), isNaN(V) || (V -= Dr.getProperty(d, dt.p), G -= Dr.getProperty(f, dt.p), Qo(d, dt, V), Qo(u, dt, V - (b || 0)), Qo(f, dt, G), Qo(h, dt, G - (b || 0))), q && !ms && St.update(), !Z || ms || m || (m = !0, Z(St), m = !1)
                                    }
                            }, St.getVelocity = function () {
                                return (Ct() - a) / (ys() - Wr) * 1e3 || 0
                            }, St.endAnimation = function () {
                                Hs(St.callbackAnimation), n && (D ? D.progress(1) : n.paused() ? ft || Hs(n, St.direction < 0, 1) : Hs(n, n.reversed()))
                            }, St.labelToScroll = function (t) {
                                return n && n.labels && (l || St.refresh() || l) + n.labels[t] / n.duration() * g || 0
                            }, St.getTrailing = function (t) {
                                var e = bo.indexOf(St),
                                    n = St.direction > 0 ? bo.slice(0, e).reverse() : bo.slice(e + 1);
                                return (ks(t) ? n.filter((function (e) {
                                    return e.vars.preventOverlaps === t
                                })) : n).filter((function (t) {
                                    return St.direction > 0 ? t.end <= l : t.start >= c
                                }))
                            }, St.update = function (t, e, r) {
                                if (!ct || r || t) {
                                    var s, u, h, f, p, m, v, b = !0 === ms ? F : St.scroll(),
                                        S = t ? 0 : (b - l) / g,
                                        A = S < 0 ? 0 : S > 1 ? 1 : S || 0,
                                        L = St.progress;
                                    if (e && (a = o, o = ct ? Ct() : b, ot && (I = O, O = n && !ft ? n.totalProgress() : A)), nt && Q && !Xr && !_s && bs && (!A && l < b + (b - a) / (ys() - Wr) * nt ? A = 1e-4 : 1 === A && c > b + (b - a) / (ys() - Wr) * nt && (A = .9999)), A !== L && St.enabled) {
                                        if (f = (p = (s = St.isActive = !!A && A < 1) !== (!!L && L < 1)) || !!A != !!L, St.direction = A > L ? 1 : -1, St.progress = A, f && !Xr && (u = A && !L ? 0 : 1 === A ? 1 : 1 === L ? 2 : 3, ft && (h = !p && "none" !== yt[u + 1] && yt[u + 1] || yt[u], v = n && ("complete" === h || "reset" === h || h in n))), ht && (p || v) && (v || J || !n) && (Fs(ht) ? ht(St) : St.getTrailing(ht).forEach((function (t) {
                                                return t.endAnimation()
                                            }))), ft || (!D || Xr || _s ? n && n.totalProgress(A, !(!Xr || !At && !t)) : (D._dp._time - D._start !== D._time && D.render(D._dp._time - D._start), D.resetTo ? D.resetTo("totalProgress", A, n._tTime / n._tDur) : (D.vars.totalProgress = A, D.invalidate().restart()))), Q)
                                            if (t && tt && (x.style[tt + dt.os2] = T), vt) {
                                                if (f) {
                                                    if (m = !t && A > L && c + 1 > b && b + 1 >= Ns(pt, dt), at)
                                                        if (t || !s && !m) Jo(Q, x);
                                                        else {
                                                            var N = oo(Q, !0),
                                                                U = b - l;
                                                            Jo(Q, zr, N.top + (dt === wr ? U : 0) + io, N.left + (dt === wr ? 0 : U) + io)
                                                        } Xo(s || m ? _ : y), C && A < 1 && s || E(M + (1 !== A || m ? 0 : w))
                                                }
                                            } else E(Cs(M + w * A));
                                        ot && !i.tween && !Xr && !_s && k.restart(!0), q && (p || st && A && (A < 1 || !fs)) && Vr(q.targets).forEach((function (t) {
                                            return t.classList[s || st ? "add" : "remove"](q.className)
                                        })), X && !ft && !t && X(St), f && !Xr ? (ft && (v && ("complete" === h ? n.pause().totalProgress(1) : "reset" === h ? n.restart(!0).pause() : "restart" === h ? n.restart(!0) : n[h]()), X && X(St)), !p && fs || (K && p && Vs(St, K), _t[u] && Vs(St, _t[u]), st && (1 === A ? St.kill(!1, 1) : _t[u] = 0), p || _t[u = 1 === A ? 1 : 3] && Vs(St, _t[u])), ut && !s && Math.abs(St.getVelocity()) > (zs(ut) ? ut : 2500) && (Hs(St.callbackAnimation), D ? D.progress(1) : Hs(n, "reverse" === h ? 1 : !A, 1))) : ft && X && !Xr && X(St)
                                    }
                                    if (R) {
                                        var z = ct ? b / ct.duration() * (ct._caScrollDist || 0) : b;
                                        P(z + (d._isFlipped ? 1 : 0)), R(z)
                                    }
                                    B && B(-b / ct.duration() * (ct._caScrollDist || 0))
                                }
                            }, St.enable = function (e, n) {
                                St.enabled || (St.enabled = !0, ho(pt, "resize", To), gt || ho(pt, "scroll", Mo), Et && ho(t, "refreshInit", Et), !1 !== e && (St.progress = Pt = 0, o = a = Tt = Ct()), !1 !== n && St.refresh())
                            }, St.getTween = function (t) {
                                return t && i ? i.tween : D
                            }, St.setPositions = function (t, e, n, i) {
                                if (ct) {
                                    var r = ct.scrollTrigger,
                                        s = ct.duration(),
                                        o = r.end - r.start;
                                    t = r.start + o * t / s, e = r.start + o * e / s
                                }
                                St.refresh(!1, !1, {
                                    start: Ms(t, n && !!St._startClamp),
                                    end: Ms(e, n && !!St._endClamp)
                                }, i), St.update()
                            }, St.adjustPinSpacing = function (t) {
                                if (A && t) {
                                    var e = A.indexOf(dt.d) + 1;
                                    A[e] = parseFloat(A[e]) + t + io, A[1] = parseFloat(A[1]) + t + io, Xo(A)
                                }
                            }, St.disable = function (e, n) {
                                if (St.enabled && (!1 !== e && St.revert(!0, !0), St.enabled = St.isActive = !1, n || D && D.pause(), F = 0, r && (r.uncache = 1), Et && fo(t, "refreshInit", Et), k && (k.pause(), i.tween && i.tween.kill() && (i.tween = 0)), !gt)) {
                                    for (var s = bo.length; s--;)
                                        if (bo[s].scroller === pt && bo[s] !== St) return;
                                    fo(pt, "resize", To), gt || fo(pt, "scroll", Mo)
                                }
                            }, St.kill = function (t, i) {
                                St.disable(t, i), D && !i && D.kill(), Y && delete So[Y];
                                var s = bo.indexOf(St);
                                s >= 0 && bo.splice(s, 1), s === Kr && Bo > 0 && Kr--, s = 0, bo.forEach((function (t) {
                                    return t.scroller === St.scroller && (s = 1)
                                })), s || ms || (St.scroll.rec = 0), n && (n.scrollTrigger = null, t && n.revert({
                                    kill: !1
                                }), i || n.kill()), u && [u, h, d, f].forEach((function (t) {
                                    return t.parentNode && t.parentNode.removeChild(t)
                                })), vs === St && (vs = 0), Q && (r && (r.uncache = 1), s = 0, bo.forEach((function (t) {
                                    return t.pin === Q && s++
                                })), s || (r.spacer = 0)), e.onKill && e.onKill(St)
                            }, bo.push(St), St.enable(!1, !1), H && H(St), n && n.add && !g) {
                            var It = St.update;
                            St.update = function () {
                                St.update = It, l || c || St.refresh()
                            }, Dr.delayedCall(.01, St.update), g = .01, l = c = 0
                        } else St.refresh();
                        Q && function () {
                            if (gs !== No) {
                                var t = gs = No;
                                requestAnimationFrame((function () {
                                    return t === No && Fo(!0)
                                }))
                            }
                        }()
                    } else this.update = this.refresh = this.kill = Ps
                }, t.register = function (e) {
                    return Nr || (Dr = e || Ls(), Rs() && window.document && t.enable(), Nr = Ss), Nr
                }, t.defaults = function (t) {
                    if (t)
                        for (var e in t) go[e] = t[e];
                    return go
                }, t.disable = function (t, e) {
                    Ss = 0, bo.forEach((function (n) {
                        return n[e ? "kill" : "disable"](t)
                    })), fo(Ur, "wheel", Mo), fo(kr, "scroll", Mo), clearInterval(jr), fo(kr, "touchcancel", Ps), fo(zr, "touchstart", Ps), uo(fo, kr, "pointerdown,touchstart,mousedown", Ts), uo(fo, kr, "pointerup,touchend,mouseup", As), Hr.kill(), Us(fo);
                    for (var n = 0; n < dr.length; n += 3) po(fo, dr[n], dr[n + 1]), po(fo, dr[n], dr[n + 2])
                }, t.enable = function () {
                    if (Ur = window, kr = document, Fr = kr.documentElement, zr = kr.body, Dr && (Vr = Dr.utils.toArray, Gr = Dr.utils.clamp, as = Dr.core.context || Ps, ts = Dr.core.suppressOverwrites || Ps, ls = Ur.history.scrollRestoration || "auto", zo = Ur.pageYOffset, Dr.core.globals("ScrollTrigger", t), zr)) {
                        Ss = 1, (cs = document.createElement("div")).style.height = "100vh", cs.style.position = "absolute", Uo(), ws(), Ir.register(Dr), t.isTouch = Ir.isTouch, os = Ir.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), is = 1 === Ir.isTouch, ho(Ur, "wheel", Mo), Br = [Ur, kr, Fr, zr], Dr.matchMedia && (t.matchMedia = function (t) {
                            var e, n = Dr.matchMedia();
                            for (e in t) n.add(e, t[e]);
                            return n
                        }, Dr.addEventListener("matchMediaInit", (function () {
                            return Io()
                        })), Dr.addEventListener("matchMediaRevert", (function () {
                            return Oo()
                        })), Dr.addEventListener("matchMedia", (function () {
                            Fo(0, 1), Ro("matchMedia")
                        })), Dr.matchMedia("(orientation: portrait)", (function () {
                            return wo(), wo
                        }))), wo(), ho(kr, "scroll", Mo);
                        var e, n, i = zr.style,
                            r = i.borderTopStyle,
                            s = Dr.core.Animation.prototype;
                        for (s.revert || Object.defineProperty(s, "revert", {
                                value: function () {
                                    return this.time(-.01, !0)
                                }
                            }), i.borderTopStyle = "solid", e = oo(zr), wr.m = Math.round(e.top + wr.sc()) || 0, Mr.m = Math.round(e.left + Mr.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), jr = setInterval(Eo, 250), Dr.delayedCall(.5, (function () {
                                return _s = 0
                            })), ho(kr, "touchcancel", Ps), ho(zr, "touchstart", Ps), uo(ho, kr, "pointerdown,touchstart,mousedown", Ts), uo(ho, kr, "pointerup,touchend,mouseup", As), Yr = Dr.utils.checkPrefix("transform"), Go.push(Yr), Nr = ys(), Hr = Dr.delayedCall(.2, Fo).pause(), $r = [kr, "visibilitychange", function () {
                                var t = Ur.innerWidth,
                                    e = Ur.innerHeight;
                                kr.hidden ? (Zr = t, Jr = e) : Zr === t && Jr === e || To()
                            }, kr, "DOMContentLoaded", Fo, Ur, "load", Fo, Ur, "resize", To], Us(ho), bo.forEach((function (t) {
                                return t.enable(0, 1)
                            })), n = 0; n < dr.length; n += 3) po(fo, dr[n], dr[n + 1]), po(fo, dr[n], dr[n + 2])
                    }
                }, t.config = function (e) {
                    "limitCallbacks" in e && (fs = !!e.limitCallbacks);
                    var n = e.syncInterval;
                    n && clearInterval(jr) || (jr = n) && setInterval(Eo, n), "ignoreMobileResize" in e && (is = 1 === t.isTouch && e.ignoreMobileResize), "autoRefreshEvents" in e && (Us(fo) || Us(ho, e.autoRefreshEvents || "none"), es = -1 === (e.autoRefreshEvents + "").indexOf("resize"))
                }, t.scrollerProxy = function (t, e) {
                    var n = Tr(t),
                        i = dr.indexOf(n),
                        r = Os(n);
                    ~i && dr.splice(i, r ? 6 : 2), e && (r ? fr.unshift(Ur, e, zr, e, Fr, e) : fr.unshift(n, e))
                }, t.clearMatchMedia = function (t) {
                    bo.forEach((function (e) {
                        return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0)
                    }))
                }, t.isInViewport = function (t, e, n) {
                    var i = (ks(t) ? Tr(t) : t).getBoundingClientRect(),
                        r = i[n ? qs : Ys] * e || 0;
                    return n ? i.right - r > 0 && i.left + r < Ur.innerWidth : i.bottom - r > 0 && i.top + r < Ur.innerHeight
                }, t.positionInViewport = function (t, e, n) {
                    ks(t) && (t = Tr(t));
                    var i = t.getBoundingClientRect(),
                        r = i[n ? qs : Ys],
                        s = null == e ? r / 2 : e in vo ? vo[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0;
                    return n ? (i.left + s) / Ur.innerWidth : (i.top + s) / Ur.innerHeight
                }, t.killAll = function (t) {
                    if (bo.slice(0).forEach((function (t) {
                            return "ScrollSmoother" !== t.vars.id && t.kill()
                        })), !0 !== t) {
                        var e = Ao.killAll || [];
                        Ao = {}, e.forEach((function (t) {
                            return t()
                        }))
                    }
                }, t
            }();
        ea.version = "3.12.5", ea.saveStyles = function (t) {
            return t ? Vr(t).forEach((function (t) {
                if (t && t.style) {
                    var e = Lo.indexOf(t);
                    e >= 0 && Lo.splice(e, 5), Lo.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), Dr.core.getCache(t), as())
                }
            })) : Lo
        }, ea.revert = function (t, e) {
            return Io(!t, e)
        }, ea.create = function (t, e) {
            return new ea(t, e)
        }, ea.refresh = function (t) {
            return t ? To() : (Nr || ea.register()) && Fo(!0)
        }, ea.update = function (t) {
            return ++dr.cache && Ho(!0 === t ? 2 : 0)
        }, ea.clearScrollMemory = Do, ea.maxScroll = function (t, e) {
            return Ns(t, e ? Mr : wr)
        }, ea.getScrollFunc = function (t, e) {
            return Ar(Tr(t), e ? Mr : wr)
        }, ea.getById = function (t) {
            return So[t]
        }, ea.getAll = function () {
            return bo.filter((function (t) {
                return "ScrollSmoother" !== t.vars.id
            }))
        }, ea.isScrolling = function () {
            return !!bs
        }, ea.snapDirectional = co, ea.addEventListener = function (t, e) {
            var n = Ao[t] || (Ao[t] = []);
            ~n.indexOf(e) || n.push(e)
        }, ea.removeEventListener = function (t, e) {
            var n = Ao[t],
                i = n && n.indexOf(e);
            i >= 0 && n.splice(i, 1)
        }, ea.batch = function (t, e) {
            var n, i = [],
                r = {},
                s = e.interval || .016,
                o = e.batchMax || 1e9,
                a = function (t, e) {
                    var n = [],
                        i = [],
                        r = Dr.delayedCall(s, (function () {
                            e(n, i), n = [], i = []
                        })).pause();
                    return function (t) {
                        n.length || r.restart(!0), n.push(t.trigger), i.push(t), o <= n.length && r.progress(1)
                    }
                };
            for (n in e) r[n] = "on" === n.substr(0, 2) && Fs(e[n]) && "onRefreshInit" !== n ? a(0, e[n]) : e[n];
            return Fs(o) && (o = o(), ho(ea, "refresh", (function () {
                return o = e.batchMax()
            }))), Vr(t).forEach((function (t) {
                var e = {};
                for (n in r) e[n] = r[n];
                e.trigger = t, i.push(ea.create(e))
            })), i
        };
        var na, ia, ra, sa = function (t, e, n, i) {
                return e > i ? t(i) : e < 0 && t(0), n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
            },
            oa = function t(e, n) {
                !0 === n ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === n ? "auto" : n ? "pan-" + n + (Ir.isTouch ? " pinch-zoom" : "") : "none", e === Fr && t(zr, n)
            },
            aa = {
                auto: 1,
                scroll: 1
            },
            la = function (t) {
                var e, n = t.event,
                    i = t.target,
                    r = t.axis,
                    s = (n.changedTouches ? n.changedTouches[0] : n).target,
                    o = s._gsap || Dr.core.getCache(s),
                    a = ys();
                if (!o._isScrollT || a - o._isScrollT > 2e3) {
                    for (; s && s !== zr && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !aa[(e = ro(s)).overflowY] && !aa[e.overflowX]);) s = s.parentNode;
                    o._isScroll = s && s !== i && !Os(s) && (aa[(e = ro(s)).overflowY] || aa[e.overflowX]), o._isScrollT = a
                }(o._isScroll || "x" === r) && (n.stopPropagation(), n._gsapAllow = !0)
            },
            ca = function (t, e, n, i) {
                return Ir.create({
                    target: t,
                    capture: !0,
                    debounce: !1,
                    lockAxis: !0,
                    type: e,
                    onWheel: i = i && la,
                    onPress: i,
                    onDrag: i,
                    onScroll: i,
                    onEnable: function () {
                        return n && ho(kr, Ir.eventTypes[0], ha, !1, !0)
                    },
                    onDisable: function () {
                        return fo(kr, Ir.eventTypes[0], ha, !0)
                    }
                })
            },
            ua = /(input|label|select|textarea)/i,
            ha = function (t) {
                var e = ua.test(t.target.tagName);
                (e || na) && (t._gsapAllow = !0, na = e)
            },
            da = function (t) {
                Bs(t) || (t = {}), t.preventDefault = t.isNormalizer = t.allowClicks = !0, t.type || (t.type = "wheel,touch"), t.debounce = !!t.debounce, t.id = t.id || "normalizer";
                var e, n, i, r, s, o, a, l, c = t,
                    u = c.normalizeScrollX,
                    h = c.momentum,
                    d = c.allowNestedScroll,
                    f = c.onRelease,
                    p = Tr(t.target) || Fr,
                    m = Dr.core.globals().ScrollSmoother,
                    g = m && m.get(),
                    v = os && (t.content && Tr(t.content) || g && !1 !== t.content && !g.smooth() && g.content()),
                    _ = Ar(p, wr),
                    y = Ar(p, Mr),
                    x = 1,
                    b = (Ir.isTouch && Ur.visualViewport ? Ur.visualViewport.scale * Ur.visualViewport.width : Ur.outerWidth) / Ur.innerWidth,
                    S = 0,
                    E = Fs(h) ? function () {
                        return h(e)
                    } : function () {
                        return h || 2.8
                    },
                    M = ca(p, t.type, !0, d),
                    w = function () {
                        return r = !1
                    },
                    T = Ps,
                    A = Ps,
                    P = function () {
                        n = Ns(p, wr), A = Gr(os ? 1 : 0, n), u && (T = Gr(0, Ns(p, Mr))), i = No
                    },
                    C = function () {
                        v._gsap.y = Cs(parseFloat(v._gsap.y) + _.offset) + "px", v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)", _.offset = _.cacheID = 0
                    },
                    R = function () {
                        P(), s.isActive() && s.vars.scrollY > n && (_() > n ? s.progress(1) && _(n) : s.resetTo("scrollY", n))
                    };
                return v && Dr.set(v, {
                    y: "+=0"
                }), t.ignoreCheck = function (t) {
                    return os && "touchmove" === t.type && function () {
                        if (r) {
                            requestAnimationFrame(w);
                            var t = Cs(e.deltaY / 2),
                                n = A(_.v - t);
                            if (v && n !== _.v + _.offset) {
                                _.offset = n - _.v;
                                var i = Cs((parseFloat(v && v._gsap.y) || 0) - _.offset);
                                v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + i + ", 0, 1)", v._gsap.y = i + "px", _.cacheID = dr.cache, Ho()
                            }
                            return !0
                        }
                        _.offset && C(), r = !0
                    }() || x > 1.05 && "touchstart" !== t.type || e.isGesturing || t.touches && t.touches.length > 1
                }, t.onPress = function () {
                    r = !1;
                    var t = x;
                    x = Cs((Ur.visualViewport && Ur.visualViewport.scale || 1) / b), s.pause(), t !== x && oa(p, x > 1.01 || !u && "x"), o = y(), a = _(), P(), i = No
                }, t.onRelease = t.onGestureStart = function (t, e) {
                    if (_.offset && C(), e) {
                        dr.cache++;
                        var i, r, o = E();
                        u && (r = (i = y()) + .05 * o * -t.velocityX / .227, o *= sa(y, i, r, Ns(p, Mr)), s.vars.scrollX = T(r)), r = (i = _()) + .05 * o * -t.velocityY / .227, o *= sa(_, i, r, Ns(p, wr)), s.vars.scrollY = A(r), s.invalidate().duration(o).play(.01), (os && s.vars.scrollY >= n || i >= n - 1) && Dr.to({}, {
                            onUpdate: R,
                            duration: o
                        })
                    } else l.restart(!0);
                    f && f(t)
                }, t.onWheel = function () {
                    s._ts && s.pause(), ys() - S > 1e3 && (i = 0, S = ys())
                }, t.onChange = function (t, e, n, r, s) {
                    if (No !== i && P(), e && u && y(T(r[2] === e ? o + (t.startX - t.x) : y() + e - r[1])), n) {
                        _.offset && C();
                        var l = s[2] === n,
                            c = l ? a + t.startY - t.y : _() + n - s[1],
                            h = A(c);
                        l && c !== h && (a += h - c), _(h)
                    }(n || e) && Ho()
                }, t.onEnable = function () {
                    oa(p, !u && "x"), ea.addEventListener("refresh", R), ho(Ur, "resize", R), _.smooth && (_.target.style.scrollBehavior = "auto", _.smooth = y.smooth = !1), M.enable()
                }, t.onDisable = function () {
                    oa(p, !0), fo(Ur, "resize", R), ea.removeEventListener("refresh", R), M.kill()
                }, t.lockAxis = !1 !== t.lockAxis, (e = new Ir(t)).iOS = os, os && !_() && _(1), os && Dr.ticker.add(Ps), l = e._dc, s = Dr.to(e, {
                    ease: "power4",
                    paused: !0,
                    inherit: !1,
                    scrollX: u ? "+=0.1" : "+=0",
                    scrollY: "+=0.1",
                    modifiers: {
                        scrollY: $o(_, _(), (function () {
                            return s.pause()
                        }))
                    },
                    onUpdate: Ho,
                    onComplete: l.vars.onComplete
                }), e
            };

        function fa(t, e, n) {
            return Math.max(t, Math.min(e, n))
        }
        ea.sort = function (t) {
            return bo.sort(t || function (t, e) {
                return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
            })
        }, ea.observe = function (t) {
            return new Ir(t)
        }, ea.normalizeScroll = function (t) {
            if (void 0 === t) return ns;
            if (!0 === t && ns) return ns.enable();
            if (!1 === t) return ns && ns.kill(), void(ns = t);
            var e = t instanceof Ir ? t : da(t);
            return ns && ns.target === e.target && ns.kill(), Os(e.target) && (ns = e), e
        }, ea.core = {
            _getVelocityProp: Pr,
            _inputObserver: ca,
            _scrollers: dr,
            _proxies: fr,
            bridge: {
                ss: function () {
                    bs || Ro("scrollStart"), bs = ys()
                },
                ref: function () {
                    return Xr
                }
            }
        }, Ls() && Dr.registerPlugin(ea);
        class pa {
            advance(t) {
                if (!this.isRunning) return;
                let e = !1;
                if (this.lerp) this.value = (n = this.value, i = this.to, r = 60 * this.lerp, s = t, function (t, e, n) {
                    return (1 - n) * t + n * e
                }(n, i, 1 - Math.exp(-r * s))), Math.round(this.value) === this.to && (this.value = this.to, e = !0);
                else {
                    this.currentTime += t;
                    const n = fa(0, this.currentTime / this.duration, 1);
                    e = n >= 1;
                    const i = e ? 1 : this.easing(n);
                    this.value = this.from + (this.to - this.from) * i
                }
                var n, i, r, s;
                this.onUpdate?.(this.value, e), e && this.stop()
            }
            stop() {
                this.isRunning = !1
            }
            fromTo(t, e, {
                lerp: n = .1,
                duration: i = 1,
                easing: r = (t => t),
                onStart: s,
                onUpdate: o
            }) {
                this.from = this.value = t, this.to = e, this.lerp = n, this.duration = i, this.easing = r, this.currentTime = 0, this.isRunning = !0, s?.(), this.onUpdate = o
            }
        }
        class ma {
            constructor({
                wrapper: t,
                content: e,
                autoResize: n = !0,
                debounce: i = 250
            } = {}) {
                this.wrapper = t, this.content = e, n && (this.debouncedResize = function (t, e) {
                    let n;
                    return function () {
                        let i = arguments,
                            r = this;
                        clearTimeout(n), n = setTimeout((function () {
                            t.apply(r, i)
                        }), e)
                    }
                }(this.resize, i), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
            }
            destroy() {
                this.wrapperResizeObserver?.disconnect(), this.contentResizeObserver?.disconnect(), window.removeEventListener("resize", this.debouncedResize, !1)
            }
            resize = () => {
                this.onWrapperResize(), this.onContentResize()
            };
            onWrapperResize = () => {
                this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
            };
            onContentResize = () => {
                this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
            };
            get limit() {
                return {
                    x: this.scrollWidth - this.width,
                    y: this.scrollHeight - this.height
                }
            }
        }
        class ga {
            constructor() {
                this.events = {}
            }
            emit(t, ...e) {
                let n = this.events[t] || [];
                for (let t = 0, i = n.length; t < i; t++) n[t](...e)
            }
            on(t, e) {
                return this.events[t]?.push(e) || (this.events[t] = [e]), () => {
                    this.events[t] = this.events[t]?.filter((t => e !== t))
                }
            }
            off(t, e) {
                this.events[t] = this.events[t]?.filter((t => e !== t))
            }
            destroy() {
                this.events = {}
            }
        }
        class va {
            constructor(t, {
                wheelMultiplier: e = 1,
                touchMultiplier: n = 2,
                normalizeWheel: i = !1
            }) {
                this.element = t, this.wheelMultiplier = e, this.touchMultiplier = n, this.normalizeWheel = i, this.touchStart = {
                    x: null,
                    y: null
                }, this.emitter = new ga, this.element.addEventListener("wheel", this.onWheel, {
                    passive: !1
                }), this.element.addEventListener("touchstart", this.onTouchStart, {
                    passive: !1
                }), this.element.addEventListener("touchmove", this.onTouchMove, {
                    passive: !1
                }), this.element.addEventListener("touchend", this.onTouchEnd, {
                    passive: !1
                })
            }
            on(t, e) {
                return this.emitter.on(t, e)
            }
            destroy() {
                this.emitter.destroy(), this.element.removeEventListener("wheel", this.onWheel, {
                    passive: !1
                }), this.element.removeEventListener("touchstart", this.onTouchStart, {
                    passive: !1
                }), this.element.removeEventListener("touchmove", this.onTouchMove, {
                    passive: !1
                }), this.element.removeEventListener("touchend", this.onTouchEnd, {
                    passive: !1
                })
            }
            onTouchStart = t => {
                const {
                    clientX: e,
                    clientY: n
                } = t.targetTouches ? t.targetTouches[0] : t;
                this.touchStart.x = e, this.touchStart.y = n, this.lastDelta = {
                    x: 0,
                    y: 0
                }, this.emitter.emit("scroll", {
                    deltaX: 0,
                    deltaY: 0,
                    event: t
                })
            };
            onTouchMove = t => {
                const {
                    clientX: e,
                    clientY: n
                } = t.targetTouches ? t.targetTouches[0] : t, i = -(e - this.touchStart.x) * this.touchMultiplier, r = -(n - this.touchStart.y) * this.touchMultiplier;
                this.touchStart.x = e, this.touchStart.y = n, this.lastDelta = {
                    x: i,
                    y: r
                }, this.emitter.emit("scroll", {
                    deltaX: i,
                    deltaY: r,
                    event: t
                })
            };
            onTouchEnd = t => {
                this.emitter.emit("scroll", {
                    deltaX: this.lastDelta.x,
                    deltaY: this.lastDelta.y,
                    event: t
                })
            };
            onWheel = t => {
                let {
                    deltaX: e,
                    deltaY: n
                } = t;
                this.normalizeWheel && (e = fa(-100, e, 100), n = fa(-100, n, 100)), e *= this.wheelMultiplier, n *= this.wheelMultiplier, this.emitter.emit("scroll", {
                    deltaX: e,
                    deltaY: n,
                    event: t
                })
            }
        }
        class _a {
            constructor({
                wrapper: t = window,
                content: e = document.documentElement,
                wheelEventsTarget: n = t,
                eventsTarget: i = n,
                smoothWheel: r = !0,
                syncTouch: s = !1,
                syncTouchLerp: o = .075,
                touchInertiaMultiplier: a = 35,
                duration: l,
                easing: c = (t => Math.min(1, 1.001 - Math.pow(2, -10 * t))),
                lerp: u = !l && .1,
                infinite: h = !1,
                orientation: d = "vertical",
                gestureOrientation: f = "vertical",
                touchMultiplier: p = 1,
                wheelMultiplier: m = 1,
                normalizeWheel: g = !1,
                autoResize: v = !0,
                __experimental__naiveDimensions: _ = !1
            } = {}) {
                this.__isSmooth = !1, this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.onVirtualScroll = ({
                    deltaX: t,
                    deltaY: e,
                    event: n
                }) => {
                    if (n.ctrlKey) return;
                    const i = n.type.includes("touch"),
                        r = n.type.includes("wheel");
                    if (this.options.syncTouch && i && "touchstart" === n.type) return void this.reset();
                    const s = 0 === t && 0 === e,
                        o = "vertical" === this.options.gestureOrientation && 0 === e || "horizontal" === this.options.gestureOrientation && 0 === t;
                    if (s || o) return;
                    let a = n.composedPath();
                    if (a = a.slice(0, a.indexOf(this.rootElement)), a.find((t => {
                            var e, n, s, o, a;
                            return (null === (e = t.hasAttribute) || void 0 === e ? void 0 : e.call(t, "data-lenis-prevent")) || i && (null === (n = t.hasAttribute) || void 0 === n ? void 0 : n.call(t, "data-lenis-prevent-touch")) || r && (null === (s = t.hasAttribute) || void 0 === s ? void 0 : s.call(t, "data-lenis-prevent-wheel")) || (null === (o = t.classList) || void 0 === o ? void 0 : o.contains("lenis")) && !(null === (a = t.classList) || void 0 === a ? void 0 : a.contains("lenis-stopped"))
                        }))) return;
                    if (this.isStopped || this.isLocked) return void n.preventDefault();
                    if (this.isSmooth = this.options.syncTouch && i || this.options.smoothWheel && r, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
                    n.preventDefault();
                    let l = e;
                    "both" === this.options.gestureOrientation ? l = Math.abs(e) > Math.abs(t) ? e : t : "horizontal" === this.options.gestureOrientation && (l = t);
                    const c = i && this.options.syncTouch,
                        u = i && "touchend" === n.type && Math.abs(l) > 5;
                    u && (l = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + l, Object.assign({
                        programmatic: !1
                    }, c ? {
                        lerp: u ? this.options.syncTouchLerp : 1
                    } : {
                        lerp: this.options.lerp,
                        duration: this.options.duration,
                        easing: this.options.easing
                    }))
                }, this.onNativeScroll = () => {
                    if (!this.__preventNextScrollEvent && !this.isScrolling) {
                        const t = this.animatedScroll;
                        this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit()
                    }
                }, window.lenisVersion = "1.0.39", t !== document.documentElement && t !== document.body || (t = window), this.options = {
                    wrapper: t,
                    content: e,
                    wheelEventsTarget: n,
                    eventsTarget: i,
                    smoothWheel: r,
                    syncTouch: s,
                    syncTouchLerp: o,
                    touchInertiaMultiplier: a,
                    duration: l,
                    easing: c,
                    lerp: u,
                    infinite: h,
                    gestureOrientation: f,
                    orientation: d,
                    touchMultiplier: p,
                    wheelMultiplier: m,
                    normalizeWheel: g,
                    autoResize: v,
                    __experimental__naiveDimensions: _
                }, this.animate = new pa, this.emitter = new ga, this.dimensions = new ma({
                    wrapper: t,
                    content: e,
                    autoResize: v
                }), this.toggleClassName("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = s || r, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, {
                    passive: !1
                }), this.virtualScroll = new va(i, {
                    touchMultiplier: p,
                    wheelMultiplier: m,
                    normalizeWheel: g
                }), this.virtualScroll.on("scroll", this.onVirtualScroll)
            }
            destroy() {
                this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, {
                    passive: !1
                }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", !1), this.toggleClassName("lenis-smooth", !1), this.toggleClassName("lenis-scrolling", !1), this.toggleClassName("lenis-stopped", !1), this.toggleClassName("lenis-locked", !1)
            }
            on(t, e) {
                return this.emitter.on(t, e)
            }
            off(t, e) {
                return this.emitter.off(t, e)
            }
            setScroll(t) {
                this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
            }
            resize() {
                this.dimensions.resize()
            }
            emit() {
                this.emitter.emit("scroll", this)
            }
            reset() {
                this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
            }
            start() {
                this.isStopped && (this.isStopped = !1, this.reset())
            }
            stop() {
                this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
            }
            raf(t) {
                const e = t - (this.time || t);
                this.time = t, this.animate.advance(.001 * e)
            }
            scrollTo(t, {
                offset: e = 0,
                immediate: n = !1,
                lock: i = !1,
                duration: r = this.options.duration,
                easing: s = this.options.easing,
                lerp: o = !r && this.options.lerp,
                onComplete: a,
                force: l = !1,
                programmatic: c = !0
            } = {}) {
                if (!this.isStopped && !this.isLocked || l) {
                    if (["top", "left", "start"].includes(t)) t = 0;
                    else if (["bottom", "right", "end"].includes(t)) t = this.limit;
                    else {
                        let n;
                        if ("string" == typeof t ? n = document.querySelector(t) : (null == t ? void 0 : t.nodeType) && (n = t), n) {
                            if (this.options.wrapper !== window) {
                                const t = this.options.wrapper.getBoundingClientRect();
                                e -= this.isHorizontal ? t.left : t.top
                            }
                            const i = n.getBoundingClientRect();
                            t = (this.isHorizontal ? i.left : i.top) + this.animatedScroll
                        }
                    }
                    if ("number" == typeof t) {
                        if (t += e, t = Math.round(t), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = fa(0, t, this.limit), n) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), void(null == a || a(this));
                        if (!c) {
                            if (t === this.targetScroll) return;
                            this.targetScroll = t
                        }
                        this.animate.fromTo(this.animatedScroll, t, {
                            duration: r,
                            easing: s,
                            lerp: o,
                            onStart: () => {
                                i && (this.isLocked = !0), this.isScrolling = !0
                            },
                            onUpdate: (t, e) => {
                                this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), e || this.emit(), e && (this.reset(), this.emit(), null == a || a(this), this.__preventNextScrollEvent = !0, requestAnimationFrame((() => {
                                    delete this.__preventNextScrollEvent
                                })))
                            }
                        })
                    }
                }
            }
            get rootElement() {
                return this.options.wrapper === window ? document.documentElement : this.options.wrapper
            }
            get limit() {
                return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
            }
            get isHorizontal() {
                return "horizontal" === this.options.orientation
            }
            get actualScroll() {
                return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
            }
            get scroll() {
                return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;
                var t
            }
            get progress() {
                return 0 === this.limit ? 1 : this.scroll / this.limit
            }
            get isSmooth() {
                return this.__isSmooth
            }
            set isSmooth(t) {
                this.__isSmooth !== t && (this.__isSmooth = t, this.toggleClassName("lenis-smooth", t))
            }
            get isScrolling() {
                return this.__isScrolling
            }
            set isScrolling(t) {
                this.__isScrolling !== t && (this.__isScrolling = t, this.toggleClassName("lenis-scrolling", t))
            }
            get isStopped() {
                return this.__isStopped
            }
            set isStopped(t) {
                this.__isStopped !== t && (this.__isStopped = t, this.toggleClassName("lenis-stopped", t))
            }
            get isLocked() {
                return this.__isLocked
            }
            set isLocked(t) {
                this.__isLocked !== t && (this.__isLocked = t, this.toggleClassName("lenis-locked", t))
            }
            get className() {
                let t = "lenis";
                return this.isStopped && (t += " lenis-stopped"), this.isLocked && (t += " lenis-locked"), this.isScrolling && (t += " lenis-scrolling"), this.isSmooth && (t += " lenis-smooth"), t
            }
            toggleClassName(t, e) {
                this.rootElement.classList.toggle(t, e), this.emitter.emit("className change", this)
            }
        }

        function ya(t) {
            return ya = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ya(t)
        }

        function xa(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, ba(i.key), i)
            }
        }

        function ba(t) {
            var e = function (t, e) {
                if ("object" != ya(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" != ya(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == ya(e) ? e : String(e)
        }
        var Sa = function () {
            function t(e) {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this, e, Yi.registerPlugin(ea)
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    ia && Ea(), window, ea.isTouch || ((ra = new _a({})).on("scroll", ea.update), Yi.ticker.add((function (t) {
                        ra.raf(1e3 * t)
                    })), Yi.ticker.lagSmoothing(0))
                }
            }, {
                key: "delete",
                value: function () {
                    Ea()
                }
            }, {
                key: "resize",
                value: function () {}
            }, {
                key: "stopScrolling",
                value: function () {
                    ra && ra.stop()
                }
            }, {
                key: "resumeScrolling",
                value: function () {
                    ra && ra.start()
                }
            }, {
                key: "scrollTo",
                value: function (t) {
                    ! function (t) {
                        ia && ia.scrollTo(t)
                    }(t)
                }
            }, {
                key: "getSmootherInstance",
                value: function () {
                    return ia || !1
                }
            }]) && xa(e.prototype, n), i && xa(e, i), Object.defineProperty(e, "prototype", {
                writable: !1
            }), t
        }();

        function Ea() {
            ia && (ia.smooth = 0, ia.scrollTo(0, !1), ia.kill(), ia = null), window.scrollTo(0, 0)
        }

        function Ma(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function wa(t, e, n) {
            return e && Ma(t.prototype, e), n && Ma(t, n), t
        }

        function Ta(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function Aa(t, e) {
            var n = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                e && (i = i.filter((function (e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), n.push.apply(n, i)
            }
            return n
        }

        function Pa(t) {
            for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2 ? Aa(Object(n), !0).forEach((function (e) {
                    Ta(t, e, n[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Aa(Object(n)).forEach((function (e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                }))
            }
            return t
        }

        function Ca(t, e) {
            return function (t) {
                if (Array.isArray(t)) return t
            }(t) || function (t, e) {
                if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                var n = [],
                    i = !0,
                    r = !1,
                    s = void 0;
                try {
                    for (var o, a = t[Symbol.iterator](); !(i = (o = a.next()).done) && (n.push(o.value), !e || n.length !== e); i = !0);
                } catch (t) {
                    r = !0, s = t
                } finally {
                    try {
                        i || null == a.return || a.return()
                    } finally {
                        if (r) throw s
                    }
                }
                return n
            }(t, e) || La(t, e) || function () {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Ra(t) {
            return function (t) {
                if (Array.isArray(t)) return Oa(t)
            }(t) || function (t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || La(t) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function La(t, e) {
            if (t) {
                if ("string" == typeof t) return Oa(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Oa(t, e) : void 0
            }
        }

        function Oa(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Ia(t, e) {
            return Object.getOwnPropertyNames(Object(t)).reduce((function (n, i) {
                var r = Object.getOwnPropertyDescriptor(Object(t), i),
                    s = Object.getOwnPropertyDescriptor(Object(e), i);
                return Object.defineProperty(n, i, s || r)
            }), {})
        }

        function Da(t) {
            return "string" == typeof t
        }

        function Na(t) {
            return Array.isArray(t)
        }

        function Ua() {
            var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                n = Ia(e);
            return void 0 !== n.types ? t = n.types : void 0 !== n.split && (t = n.split), void 0 !== t && (n.types = (Da(t) || Na(t) ? String(t) : "").split(",").map((function (t) {
                return String(t).trim()
            })).filter((function (t) {
                return /((line)|(word)|(char))/i.test(t)
            }))), (n.absolute || n.position) && (n.absolute = n.absolute || /absolute/.test(e.position)), n
        }

        function ka(t) {
            var e = Da(t) || Na(t) ? String(t) : "";
            return {
                none: !e,
                lines: /line/i.test(e),
                words: /word/i.test(e),
                chars: /char/i.test(e)
            }
        }

        function Fa(t) {
            return null !== t && "object" == typeof t
        }

        function za(t) {
            return Fa(t) && /^(1|3|11)$/.test(t.nodeType)
        }

        function Ba(t) {
            return Na(t) ? t : null == t ? [] : function (t) {
                return Fa(t) && function (t) {
                    return "number" == typeof t && t > -1 && t % 1 == 0
                }(t.length)
            }(t) ? Array.prototype.slice.call(t) : [t]
        }

        function Ha(t) {
            var e = t;
            return Da(t) && (e = /^(#[a-z]\w+)$/.test(t.trim()) ? document.getElementById(t.trim().slice(1)) : document.querySelectorAll(t)), Ba(e).reduce((function (t, e) {
                return [].concat(Ra(t), Ra(Ba(e).filter(za)))
            }), [])
        }! function () {
            function t() {
                for (var t = arguments.length, e = 0; e < t; e++) {
                    var n = e < 0 || arguments.length <= e ? void 0 : arguments[e];
                    1 === n.nodeType || 11 === n.nodeType ? this.appendChild(n) : this.appendChild(document.createTextNode(String(n)))
                }
            }

            function e() {
                for (; this.lastChild;) this.removeChild(this.lastChild);
                arguments.length && this.append.apply(this, arguments)
            }

            function n() {
                for (var t = this.parentNode, e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                var r = n.length;
                if (t)
                    for (r || t.removeChild(this); r--;) {
                        var s = n[r];
                        "object" != typeof s ? s = this.ownerDocument.createTextNode(s) : s.parentNode && s.parentNode.removeChild(s), r ? t.insertBefore(this.previousSibling, s) : t.replaceChild(s, this)
                    }
            }
            "undefined" != typeof Element && (Element.prototype.append || (Element.prototype.append = t, DocumentFragment.prototype.append = t), Element.prototype.replaceChildren || (Element.prototype.replaceChildren = e, DocumentFragment.prototype.replaceChildren = e), Element.prototype.replaceWith || (Element.prototype.replaceWith = n, DocumentFragment.prototype.replaceWith = n))
        }();
        var Va = Object.entries,
            Ga = "_splittype",
            Wa = {},
            ja = 0;

        function Xa(t, e, n) {
            if (!Fa(t)) return null;
            var i = t[Ga] || (t[Ga] = ++ja),
                r = Wa[i] || (Wa[i] = {});
            return void 0 === n ? e && Object.getPrototypeOf(e) === Object.prototype && (Wa[i] = Pa(Pa({}, r), e)) : void 0 !== e && (r[e] = n), n
        }

        function qa(t, e) {
            var n = Fa(t) ? t[Ga] : null,
                i = n && Wa[n] || {};
            return void 0 === e ? i : i[e]
        }

        function Ya(t) {
            var e = t && t[Ga];
            e && (delete t[e], delete Wa[e])
        }
        var Ka = "\\ud800-\\udfff",
            Za = "\\u0300-\\u036f\\ufe20-\\ufe23",
            Ja = "\\u20d0-\\u20f0",
            $a = "\\ufe0e\\ufe0f",
            Qa = "[".concat(Ka, "]"),
            tl = "[".concat(Za).concat(Ja, "]"),
            el = "\\ud83c[\\udffb-\\udfff]",
            nl = "(?:".concat(tl, "|").concat(el, ")"),
            il = "[^".concat(Ka, "]"),
            rl = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            sl = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            ol = "\\u200d",
            al = "".concat(nl, "?"),
            ll = "[".concat($a, "]?"),
            cl = ll + al + ("(?:" + ol + "(?:" + [il, rl, sl].join("|") + ")" + ll + al + ")*"),
            ul = "(?:".concat(["".concat(il).concat(tl, "?"), tl, rl, sl, Qa].join("|"), "\n)"),
            hl = RegExp("".concat(el, "(?=").concat(el, ")|").concat(ul).concat(cl), "g"),
            dl = RegExp("[".concat([ol, Ka, Za, Ja, $a].join(""), "]"));

        function fl(t) {
            return dl.test(t)
        }

        function pl(t) {
            return fl(t) ? function (t) {
                return t.match(hl) || []
            }(t) : function (t) {
                return t.split("")
            }(t)
        }

        function ml(t) {
            var e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
            return (t = null == (e = t) ? "" : String(e)) && Da(t) && !n && fl(t) ? pl(t) : t.split(n)
        }

        function gl(t, e) {
            var n = document.createElement(t);
            return e ? (Object.keys(e).forEach((function (t) {
                var i = e[t],
                    r = Da(i) ? i.trim() : i;
                null !== r && "" !== r && ("children" === t ? n.append.apply(n, Ra(Ba(r))) : n.setAttribute(t, r))
            })), n) : n
        }
        var vl = {
            splitClass: "",
            lineClass: "line",
            wordClass: "word",
            charClass: "char",
            types: ["lines", "words", "chars"],
            absolute: !1,
            tagName: "div"
        };

        function _l(t, e) {
            var n, i = ka((e = Ia(vl, e)).types),
                r = e.tagName,
                s = t.nodeValue,
                o = document.createDocumentFragment(),
                a = [];
            return /^\s/.test(s) && o.append(" "), n = function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : " ";
                return (t ? String(t) : "").trim().replace(/\s+/g, " ").split(e)
            }(s).reduce((function (t, n, s, l) {
                var c, u;
                return i.chars && (u = ml(n).map((function (t) {
                    var n = gl(r, {
                        class: "".concat(e.splitClass, " ").concat(e.charClass),
                        style: "display: inline-block;",
                        children: t
                    });
                    return Xa(n, "isChar", !0), a = [].concat(Ra(a), [n]), n
                }))), i.words || i.lines ? (Xa(c = gl(r, {
                    class: "".concat(e.wordClass, " ").concat(e.splitClass),
                    style: "display: inline-block; ".concat(i.words && e.absolute ? "position: relative;" : ""),
                    children: i.chars ? u : n
                }), {
                    isWord: !0,
                    isWordStart: !0,
                    isWordEnd: !0
                }), o.appendChild(c)) : u.forEach((function (t) {
                    o.appendChild(t)
                })), s < l.length - 1 && o.append(" "), i.words ? t.concat(c) : t
            }), []), /\s$/.test(s) && o.append(" "), t.replaceWith(o), {
                words: n,
                chars: a
            }
        }

        function yl(t, e) {
            var n = t.nodeType,
                i = {
                    words: [],
                    chars: []
                };
            if (!/(1|3|11)/.test(n)) return i;
            if (3 === n && /\S/.test(t.nodeValue)) return _l(t, e);
            var r = Ba(t.childNodes);
            if (r.length && (Xa(t, "isSplit", !0), !qa(t).isRoot)) {
                t.style.display = "inline-block", t.style.position = "relative";
                var s = t.nextSibling,
                    o = t.previousSibling,
                    a = t.textContent || "",
                    l = s ? s.textContent : " ",
                    c = o ? o.textContent : " ";
                Xa(t, {
                    isWordEnd: /\s$/.test(a) || /^\s/.test(l),
                    isWordStart: /^\s/.test(a) || /\s$/.test(c)
                })
            }
            return r.reduce((function (t, n) {
                var i = yl(n, e),
                    r = i.words,
                    s = i.chars;
                return {
                    words: [].concat(Ra(t.words), Ra(r)),
                    chars: [].concat(Ra(t.chars), Ra(s))
                }
            }), i)
        }

        function xl(t) {
            qa(t).isWord ? (Ya(t), t.replaceWith.apply(t, Ra(t.childNodes))) : Ba(t.children).forEach((function (t) {
                return xl(t)
            }))
        }

        function bl(t, e, n) {
            var i, r, s, o = ka(e.types),
                a = e.tagName,
                l = t.getElementsByTagName("*"),
                c = [],
                u = [],
                h = null,
                d = [],
                f = t.parentElement,
                p = t.nextElementSibling,
                m = document.createDocumentFragment(),
                g = window.getComputedStyle(t),
                v = g.textAlign,
                _ = .2 * parseFloat(g.fontSize);
            return e.absolute && (s = {
                left: t.offsetLeft,
                top: t.offsetTop,
                width: t.offsetWidth
            }, r = t.offsetWidth, i = t.offsetHeight, Xa(t, {
                cssWidth: t.style.width,
                cssHeight: t.style.height
            })), Ba(l).forEach((function (i) {
                var r = i.parentElement === t,
                    s = function (t, e, n, i) {
                        if (!n.absolute) return {
                            top: e ? t.offsetTop : null
                        };
                        var r = t.offsetParent,
                            s = Ca(i, 2),
                            o = s[0],
                            a = s[1],
                            l = 0,
                            c = 0;
                        if (r && r !== document.body) {
                            var u = r.getBoundingClientRect();
                            l = u.x + o, c = u.y + a
                        }
                        var h = t.getBoundingClientRect(),
                            d = h.width,
                            f = h.height,
                            p = h.x;
                        return {
                            width: d,
                            height: f,
                            top: h.y + a - c,
                            left: p + o - l
                        }
                    }(i, r, e, n),
                    a = s.width,
                    l = s.height,
                    d = s.top,
                    f = s.left;
                /^br$/i.test(i.nodeName) || (o.lines && r && ((null === h || d - h >= _) && (h = d, c.push(u = [])), u.push(i)), e.absolute && Xa(i, {
                    top: d,
                    left: f,
                    width: a,
                    height: l
                }))
            })), f && f.removeChild(t), o.lines && (d = c.map((function (t) {
                var n = gl(a, {
                    class: "".concat(e.splitClass, " ").concat(e.lineClass),
                    style: "display: block; text-align: ".concat(v, "; width: 100%;")
                });
                Xa(n, "isLine", !0);
                var i = {
                    height: 0,
                    top: 1e4
                };
                return m.appendChild(n), t.forEach((function (t, e, r) {
                    var s = qa(t),
                        o = s.isWordEnd,
                        a = s.top,
                        l = s.height,
                        c = r[e + 1];
                    i.height = Math.max(i.height, l), i.top = Math.min(i.top, a), n.appendChild(t), o && qa(c).isWordStart && n.append(" ")
                })), e.absolute && Xa(n, {
                    height: i.height,
                    top: i.top
                }), n
            })), o.words || xl(m), t.replaceChildren(m)), e.absolute && (t.style.width = "".concat(t.style.width || r, "px"), t.style.height = "".concat(i, "px"), Ba(l).forEach((function (t) {
                var e = qa(t),
                    n = e.isLine,
                    i = e.top,
                    r = e.left,
                    o = e.width,
                    a = e.height,
                    l = qa(t.parentElement),
                    c = !n && l.isLine;
                t.style.top = "".concat(c ? i - l.top : i, "px"), t.style.left = "".concat(n ? s.left : r - (c ? s.left : 0), "px"), t.style.height = "".concat(a, "px"), t.style.width = "".concat(n ? s.width : o, "px"), t.style.position = "absolute"
            }))), f && (p ? f.insertBefore(t, p) : f.appendChild(t)), d
        }
        var Sl = Ia(vl, {}),
            El = function () {
                function t(e, n) {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.isSplit = !1, this.settings = Ia(Sl, Ua(n)), this.elements = Ha(e), this.split()
                }
                return wa(t, null, [{
                    key: "clearData",
                    value: function () {
                        Object.keys(Wa).forEach((function (t) {
                            delete Wa[t]
                        }))
                    }
                }, {
                    key: "setDefaults",
                    value: function (t) {
                        return Sl = Ia(Sl, Ua(t)), vl
                    }
                }, {
                    key: "revert",
                    value: function (t) {
                        Ha(t).forEach((function (t) {
                            var e = qa(t),
                                n = e.isSplit,
                                i = e.html,
                                r = e.cssWidth,
                                s = e.cssHeight;
                            n && (t.innerHTML = i, t.style.width = r || "", t.style.height = s || "", Ya(t))
                        }))
                    }
                }, {
                    key: "create",
                    value: function (e, n) {
                        return new t(e, n)
                    }
                }, {
                    key: "data",
                    get: function () {
                        return Wa
                    }
                }, {
                    key: "defaults",
                    get: function () {
                        return Sl
                    },
                    set: function (t) {
                        Sl = Ia(Sl, Ua(t))
                    }
                }]), wa(t, [{
                    key: "split",
                    value: function (t) {
                        var e = this;
                        this.revert(), this.elements.forEach((function (t) {
                            Xa(t, "html", t.innerHTML)
                        })), this.lines = [], this.words = [], this.chars = [];
                        var n = [window.pageXOffset, window.pageYOffset];
                        void 0 !== t && (this.settings = Ia(this.settings, Ua(t)));
                        var i = ka(this.settings.types);
                        i.none || (this.elements.forEach((function (t) {
                            Xa(t, "isRoot", !0);
                            var n = yl(t, e.settings),
                                i = n.words,
                                r = n.chars;
                            e.words = [].concat(Ra(e.words), Ra(i)), e.chars = [].concat(Ra(e.chars), Ra(r))
                        })), this.elements.forEach((function (t) {
                            if (i.lines || e.settings.absolute) {
                                var r = bl(t, e.settings, n);
                                e.lines = [].concat(Ra(e.lines), Ra(r))
                            }
                        })), this.isSplit = !0, window.scrollTo(n[0], n[1]), Va(Wa).forEach((function (t) {
                            var e = Ca(t, 2),
                                n = e[0],
                                i = e[1],
                                r = i.isRoot,
                                s = i.isSplit;
                            r && s || (Wa[n] = null, delete Wa[n])
                        })))
                    }
                }, {
                    key: "revert",
                    value: function () {
                        this.isSplit && (this.lines = null, this.words = null, this.chars = null, this.isSplit = !1), t.revert(this.elements)
                    }
                }]), t
            }(),
            Ml = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
            wl = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
            Tl = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
            Al = /(^[#\.][a-z]|[a-y][a-z])/i,
            Pl = Math.PI / 180,
            Cl = 180 / Math.PI,
            Rl = Math.sin,
            Ll = Math.cos,
            Ol = Math.abs,
            Il = Math.sqrt,
            Dl = Math.atan2,
            Nl = 1e8,
            Ul = function (t) {
                return "string" == typeof t
            },
            kl = function (t) {
                return "number" == typeof t
            },
            Fl = {},
            zl = {},
            Bl = 1e5,
            Hl = function (t) {
                return Math.round((t + Nl) % 1 * Bl) / Bl || (t < 0 ? 0 : 1)
            },
            Vl = function (t) {
                return Math.round(t * Bl) / Bl || 0
            },
            Gl = function (t) {
                return Math.round(1e10 * t) / 1e10 || 0
            },
            Wl = function (t, e, n, i) {
                var r = t[e],
                    s = 1 === i ? 6 : nc(r, n, i);
                if ((s || !i) && s + n + 2 < r.length) return t.splice(e, 0, r.slice(0, n + s + 2)), r.splice(0, n + s), 1
            },
            jl = function (t, e, n) {
                var i = t.length,
                    r = ~~(n * i);
                if (t[r] > e) {
                    for (; --r && t[r] > e;);
                    r < 0 && (r = 0)
                } else
                    for (; t[++r] < e && r < i;);
                return r < i ? r : i - 1
            },
            Xl = function (t, e) {
                return e.totalLength = t.totalLength, t.samples ? (e.samples = t.samples.slice(0), e.lookup = t.lookup.slice(0), e.minLength = t.minLength, e.resolution = t.resolution) : t.totalPoints && (e.totalPoints = t.totalPoints), e
            },
            ql = function (t, e) {
                var n = t.length,
                    i = t[n - 1] || [],
                    r = i.length;
                n && e[0] === i[r - 2] && e[1] === i[r - 1] && (e = i.concat(e.slice(2)), n--), t[n] = e
            };

        function Yl(t) {
            var e, n = (t = Ul(t) && Al.test(t) && document.querySelector(t) || t).getAttribute ? t : 0;
            return n && (t = t.getAttribute("d")) ? (n._gsPath || (n._gsPath = {}), (e = n._gsPath[t]) && !e._dirty ? e : n._gsPath[t] = ac(t)) : t ? Ul(t) ? ac(t) : kl(t[0]) ? [t] : t : void 0
        }

        function Kl(t) {
            var e, n = 0;
            for (t.reverse(); n < t.length; n += 2) e = t[n], t[n] = t[n + 1], t[n + 1] = e;
            t.reversed = !t.reversed
        }
        var Zl = {
            rect: "rx,ry,x,y,width,height",
            circle: "r,cx,cy",
            ellipse: "rx,ry,cx,cy",
            line: "x1,x2,y1,y2"
        };

        function Jl(t, e) {
            var n, i, r, s, o, a, l, c, u, h, d, f, p, m, g, v, _, y, x, b, S, E, M = t.tagName.toLowerCase(),
                w = .552284749831;
            return "path" !== M && t.getBBox ? (a = function (t, e) {
                var n, i = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                    r = [].slice.call(t.attributes),
                    s = r.length;
                for (e = "," + e + ","; --s > -1;) n = r[s].nodeName.toLowerCase(), e.indexOf("," + n + ",") < 0 && i.setAttributeNS(null, n, r[s].nodeValue);
                return i
            }(t, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), E = function (t, e) {
                for (var n = e ? e.split(",") : [], i = {}, r = n.length; --r > -1;) i[n[r]] = +t.getAttribute(n[r]) || 0;
                return i
            }(t, Zl[M]), "rect" === M ? (s = E.rx, o = E.ry || s, i = E.x, r = E.y, h = E.width - 2 * s, d = E.height - 2 * o, n = s || o ? "M" + (v = (m = (p = i + s) + h) + s) + "," + (y = r + o) + " V" + (x = y + d) + " C" + [v, b = x + o * w, g = m + s * w, S = x + o, m, S, m - (m - p) / 3, S, p + (m - p) / 3, S, p, S, f = i + s * (1 - w), S, i, b, i, x, i, x - (x - y) / 3, i, y + (x - y) / 3, i, y, i, _ = r + o * (1 - w), f, r, p, r, p + (m - p) / 3, r, m - (m - p) / 3, r, m, r, g, r, v, _, v, y].join(",") + "z" : "M" + (i + h) + "," + r + " v" + d + " h" + -h + " v" + -d + " h" + h + "z") : "circle" === M || "ellipse" === M ? ("circle" === M ? c = (s = o = E.r) * w : (s = E.rx, c = (o = E.ry) * w), n = "M" + ((i = E.cx) + s) + "," + (r = E.cy) + " C" + [i + s, r + c, i + (l = s * w), r + o, i, r + o, i - l, r + o, i - s, r + c, i - s, r, i - s, r - c, i - l, r - o, i, r - o, i + l, r - o, i + s, r - c, i + s, r].join(",") + "z") : "line" === M ? n = "M" + E.x1 + "," + E.y1 + " L" + E.x2 + "," + E.y2 : "polyline" !== M && "polygon" !== M || (n = "M" + (i = (u = (t.getAttribute("points") + "").match(wl) || []).shift()) + "," + (r = u.shift()) + " L" + u.join(","), "polygon" === M && (n += "," + i + "," + r + "z")), a.setAttribute("d", uc(a._gsRawPath = ac(n))), e && t.parentNode && (t.parentNode.insertBefore(a, t), t.parentNode.removeChild(t)), a) : t
        }

        function $l(t, e, n) {
            var i, r = t[e],
                s = t[e + 2],
                o = t[e + 4];
            return r += (s - r) * n, r += ((s += (o - s) * n) - r) * n, i = s + (o + (t[e + 6] - o) * n - s) * n - r, r = t[e + 1], r += ((s = t[e + 3]) - r) * n, r += ((s += ((o = t[e + 5]) - s) * n) - r) * n, Vl(Dl(s + (o + (t[e + 7] - o) * n - s) * n - r, i) * Cl)
        }

        function Ql(t, e, n) {
            n = void 0 === n ? 1 : Gl(n) || 0, e = Gl(e) || 0;
            var i = Math.max(0, ~~(Ol(n - e) - 1e-8)),
                r = function (t) {
                    for (var e = [], n = 0; n < t.length; n++) e[n] = Xl(t[n], t[n].slice(0));
                    return Xl(t, e)
                }(t);
            if (e > n && (e = 1 - e, n = 1 - n, function (t, e) {
                    var n = t.length;
                    for (e || t.reverse(); n--;) t[n].reversed || Kl(t[n])
                }(r), r.totalLength = 0), e < 0 || n < 0) {
                var s = Math.abs(~~Math.min(e, n)) + 1;
                e += s, n += s
            }
            r.totalLength || ec(r);
            var o, a, l, c, u, h, d, f, p = n > 1,
                m = ic(r, e, Fl, !0),
                g = ic(r, n, zl),
                v = g.segment,
                _ = m.segment,
                y = g.segIndex,
                x = m.segIndex,
                b = g.i,
                S = m.i,
                E = x === y,
                M = b === S && E;
            if (p || i) {
                for (o = y < x || E && b < S || M && g.t < m.t, Wl(r, x, S, m.t) && (x++, o || (y++, M ? (g.t = (g.t - m.t) / (1 - m.t), b = 0) : E && (b -= S))), Math.abs(1 - (n - e)) < 1e-5 ? y = x - 1 : !g.t && y ? y-- : Wl(r, y, b, g.t) && o && x++, 1 === m.t && (x = (x + 1) % r.length), u = [], d = 1 + (h = r.length) * i, f = x, d += (h - x + y) % h, c = 0; c < d; c++) ql(u, r[f++ % h]);
                r = u
            } else if (l = 1 === g.t ? 6 : nc(v, b, g.t), e !== n)
                for (a = nc(_, S, M ? m.t / g.t : m.t), E && (l += a), v.splice(b + l + 2), (a || S) && _.splice(0, S + a), c = r.length; c--;)(c < x || c > y) && r.splice(c, 1);
            else v.angle = $l(v, b + l, 0), m = v[b += l], g = v[b + 1], v.length = v.totalLength = 0, v.totalPoints = r.totalPoints = 8, v.push(m, g, m, g, m, g, m, g);
            return r.totalLength = 0, r
        }

        function tc(t, e, n) {
            e = e || 0, t.samples || (t.samples = [], t.lookup = []);
            var i, r, s, o, a, l, c, u, h, d, f, p, m, g, v, _, y, x = ~~t.resolution || 12,
                b = 1 / x,
                S = n ? e + 6 * n + 1 : t.length,
                E = t[e],
                M = t[e + 1],
                w = e ? e / 6 * x : 0,
                T = t.samples,
                A = t.lookup,
                P = (e ? t.minLength : Nl) || Nl,
                C = T[w + n * x - 1],
                R = e ? T[w - 1] : 0;
            for (T.length = A.length = 0, r = e + 2; r < S; r += 6) {
                if (s = t[r + 4] - E, o = t[r + 2] - E, a = t[r] - E, u = t[r + 5] - M, h = t[r + 3] - M, d = t[r + 1] - M, l = c = f = p = 0, Ol(s) < .01 && Ol(u) < .01 && Ol(a) + Ol(d) < .01) t.length > 8 && (t.splice(r, 6), r -= 6, S -= 6);
                else
                    for (i = 1; i <= x; i++) l = c - (c = ((g = b * i) * g * s + 3 * (m = 1 - g) * (g * o + m * a)) * g), f = p - (p = (g * g * u + 3 * m * (g * h + m * d)) * g), (_ = Il(f * f + l * l)) < P && (P = _), R += _, T[w++] = R;
                E += s, M += u
            }
            if (C)
                for (C -= R; w < T.length; w++) T[w] += C;
            if (T.length && P) {
                if (t.totalLength = y = T[T.length - 1] || 0, t.minLength = P, y / P < 9999)
                    for (_ = v = 0, i = 0; i < y; i += P) A[_++] = T[v] < i ? ++v : v
            } else t.totalLength = T[0] = 0;
            return e ? R - T[e / 2 - 1] : R
        }

        function ec(t, e) {
            var n, i, r;
            for (r = n = i = 0; r < t.length; r++) t[r].resolution = ~~e || 12, i += t[r].length, n += tc(t[r]);
            return t.totalPoints = i, t.totalLength = n, t
        }

        function nc(t, e, n) {
            if (n <= 0 || n >= 1) return 0;
            var i = t[e],
                r = t[e + 1],
                s = t[e + 2],
                o = t[e + 3],
                a = t[e + 4],
                l = t[e + 5],
                c = i + (s - i) * n,
                u = s + (a - s) * n,
                h = r + (o - r) * n,
                d = o + (l - o) * n,
                f = c + (u - c) * n,
                p = h + (d - h) * n,
                m = a + (t[e + 6] - a) * n,
                g = l + (t[e + 7] - l) * n;
            return u += (m - u) * n, d += (g - d) * n, t.splice(e + 2, 4, Vl(c), Vl(h), Vl(f), Vl(p), Vl(f + (u - f) * n), Vl(p + (d - p) * n), Vl(u), Vl(d), Vl(m), Vl(g)), t.samples && t.samples.splice(e / 6 * t.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6
        }

        function ic(t, e, n, i) {
            n = n || {}, t.totalLength || ec(t), (e < 0 || e > 1) && (e = Hl(e));
            var r, s, o, a, l, c, u, h = 0,
                d = t[0];
            if (e)
                if (1 === e) u = 1, c = (d = t[h = t.length - 1]).length - 8;
                else {
                    if (t.length > 1) {
                        for (o = t.totalLength * e, l = c = 0;
                            (l += t[c++].totalLength) < o;) h = c;
                        e = (o - (a = l - (d = t[h]).totalLength)) / (l - a) || 0
                    }
                    r = d.samples, s = d.resolution, o = d.totalLength * e, a = (c = d.lookup.length ? d.lookup[~~(o / d.minLength)] || 0 : jl(r, o, e)) ? r[c - 1] : 0, (l = r[c]) < o && (a = l, l = r[++c]), u = 1 / s * ((o - a) / (l - a) + c % s), c = 6 * ~~(c / s), i && 1 === u && (c + 6 < d.length ? (c += 6, u = 0) : h + 1 < t.length && (c = u = 0, d = t[++h]))
                }
            else u = c = h = 0, d = t[0];
            return n.t = u, n.i = c, n.path = t, n.segment = d, n.segIndex = h, n
        }

        function rc(t, e, n, i) {
            var r, s, o, a, l, c, u, h, d, f = t[0],
                p = i || {};
            if ((e < 0 || e > 1) && (e = Hl(e)), f.lookup || ec(t), t.length > 1) {
                for (o = t.totalLength * e, l = c = 0;
                    (l += t[c++].totalLength) < o;) f = t[c];
                e = (o - (a = l - f.totalLength)) / (l - a) || 0
            }
            return r = f.samples, s = f.resolution, o = f.totalLength * e, a = (c = f.lookup.length ? f.lookup[e < 1 ? ~~(o / f.minLength) : f.lookup.length - 1] || 0 : jl(r, o, e)) ? r[c - 1] : 0, (l = r[c]) < o && (a = l, l = r[++c]), d = 1 - (u = 1 / s * ((o - a) / (l - a) + c % s) || 0), h = f[c = 6 * ~~(c / s)], p.x = Vl((u * u * (f[c + 6] - h) + 3 * d * (u * (f[c + 4] - h) + d * (f[c + 2] - h))) * u + h), p.y = Vl((u * u * (f[c + 7] - (h = f[c + 1])) + 3 * d * (u * (f[c + 5] - h) + d * (f[c + 3] - h))) * u + h), n && (p.angle = f.totalLength ? $l(f, c, u >= 1 ? 1 - 1e-9 : u || 1e-9) : f.angle || 0), p
        }

        function sc(t, e, n, i, r, s, o) {
            for (var a, l, c, u, h, d = t.length; --d > -1;)
                for (l = (a = t[d]).length, c = 0; c < l; c += 2) u = a[c], h = a[c + 1], a[c] = u * e + h * i + s, a[c + 1] = u * n + h * r + o;
            return t._dirty = 1, t
        }

        function oc(t, e, n, i, r, s, o, a, l) {
            if (t !== a || e !== l) {
                n = Ol(n), i = Ol(i);
                var c = r % 360 * Pl,
                    u = Ll(c),
                    h = Rl(c),
                    d = Math.PI,
                    f = 2 * d,
                    p = (t - a) / 2,
                    m = (e - l) / 2,
                    g = u * p + h * m,
                    v = -h * p + u * m,
                    _ = g * g,
                    y = v * v,
                    x = _ / (n * n) + y / (i * i);
                x > 1 && (n = Il(x) * n, i = Il(x) * i);
                var b = n * n,
                    S = i * i,
                    E = (b * S - b * y - S * _) / (b * y + S * _);
                E < 0 && (E = 0);
                var M = (s === o ? -1 : 1) * Il(E),
                    w = M * (n * v / i),
                    T = M * (-i * g / n),
                    A = (t + a) / 2 + (u * w - h * T),
                    P = (e + l) / 2 + (h * w + u * T),
                    C = (g - w) / n,
                    R = (v - T) / i,
                    L = (-g - w) / n,
                    O = (-v - T) / i,
                    I = C * C + R * R,
                    D = (R < 0 ? -1 : 1) * Math.acos(C / Il(I)),
                    N = (C * O - R * L < 0 ? -1 : 1) * Math.acos((C * L + R * O) / Il(I * (L * L + O * O)));
                isNaN(N) && (N = d), !o && N > 0 ? N -= f : o && N < 0 && (N += f), D %= f, N %= f;
                var U, k = Math.ceil(Ol(N) / (f / 4)),
                    F = [],
                    z = N / k,
                    B = 4 / 3 * Rl(z / 2) / (1 + Ll(z / 2)),
                    H = u * n,
                    V = h * n,
                    G = h * -i,
                    W = u * i;
                for (U = 0; U < k; U++) g = Ll(r = D + U * z), v = Rl(r), C = Ll(r += z), R = Rl(r), F.push(g - B * v, v + B * g, C + B * R, R - B * C, C, R);
                for (U = 0; U < F.length; U += 2) g = F[U], v = F[U + 1], F[U] = g * H + v * G + A, F[U + 1] = g * V + v * W + P;
                return F[U - 2] = a, F[U - 1] = l, F
            }
        }

        function ac(t) {
            var e, n, i, r, s, o, a, l, c, u, h, d, f, p, m, g = (t + "").replace(Tl, (function (t) {
                    var e = +t;
                    return e < 1e-4 && e > -1e-4 ? 0 : e
                })).match(Ml) || [],
                v = [],
                _ = 0,
                y = 0,
                x = 2 / 3,
                b = g.length,
                S = 0,
                E = function (t, e, n, i) {
                    u = (n - t) / 3, h = (i - e) / 3, a.push(t + u, e + h, n - u, i - h, n, i)
                };
            if (!t || !isNaN(g[0]) || isNaN(g[1])) return v;
            for (e = 0; e < b; e++)
                if (f = s, isNaN(g[e]) ? o = (s = g[e].toUpperCase()) !== g[e] : e--, i = +g[e + 1], r = +g[e + 2], o && (i += _, r += y), e || (l = i, c = r), "M" === s) a && (a.length < 8 ? v.length -= 1 : S += a.length), _ = l = i, y = c = r, a = [i, r], v.push(a), e += 2, s = "L";
                else if ("C" === s) a || (a = [0, 0]), o || (_ = y = 0), a.push(i, r, _ + 1 * g[e + 3], y + 1 * g[e + 4], _ += 1 * g[e + 5], y += 1 * g[e + 6]), e += 6;
            else if ("S" === s) u = _, h = y, "C" !== f && "S" !== f || (u += _ - a[a.length - 4], h += y - a[a.length - 3]), o || (_ = y = 0), a.push(u, h, i, r, _ += 1 * g[e + 3], y += 1 * g[e + 4]), e += 4;
            else if ("Q" === s) u = _ + (i - _) * x, h = y + (r - y) * x, o || (_ = y = 0), _ += 1 * g[e + 3], y += 1 * g[e + 4], a.push(u, h, _ + (i - _) * x, y + (r - y) * x, _, y), e += 4;
            else if ("T" === s) u = _ - a[a.length - 4], h = y - a[a.length - 3], a.push(_ + u, y + h, i + (_ + 1.5 * u - i) * x, r + (y + 1.5 * h - r) * x, _ = i, y = r), e += 2;
            else if ("H" === s) E(_, y, _ = i, y), e += 1;
            else if ("V" === s) E(_, y, _, y = i + (o ? y - _ : 0)), e += 1;
            else if ("L" === s || "Z" === s) "Z" === s && (i = l, r = c, a.closed = !0), ("L" === s || Ol(_ - i) > .5 || Ol(y - r) > .5) && (E(_, y, i, r), "L" === s && (e += 2)), _ = i, y = r;
            else if ("A" === s) {
                if (p = g[e + 4], m = g[e + 5], u = g[e + 6], h = g[e + 7], n = 7, p.length > 1 && (p.length < 3 ? (h = u, u = m, n--) : (h = m, u = p.substr(2), n -= 2), m = p.charAt(1), p = p.charAt(0)), d = oc(_, y, +g[e + 1], +g[e + 2], +g[e + 3], +p, +m, (o ? _ : 0) + 1 * u, (o ? y : 0) + 1 * h), e += n, d)
                    for (n = 0; n < d.length; n++) a.push(d[n]);
                _ = a[a.length - 2], y = a[a.length - 1]
            }
            return (e = a.length) < 6 ? (v.pop(), e = 0) : a[0] === a[e - 2] && a[1] === a[e - 1] && (a.closed = !0), v.totalPoints = S + e, v
        }

        function lc(t, e) {
            void 0 === e && (e = 1);
            for (var n = t[0], i = 0, r = [n, i], s = 2; s < t.length; s += 2) r.push(n, i, t[s], i = (t[s] - n) * e / 2, n = t[s], -i);
            return r
        }

        function cc(t, e) {
            Ol(t[0] - t[2]) < 1e-4 && Ol(t[1] - t[3]) < 1e-4 && (t = t.slice(2));
            var n, i, r, s, o, a, l, c, u, h, d, f, p, m, g = t.length - 2,
                v = +t[0],
                _ = +t[1],
                y = +t[2],
                x = +t[3],
                b = [v, _, v, _],
                S = y - v,
                E = x - _,
                M = Math.abs(t[g] - v) < .001 && Math.abs(t[g + 1] - _) < .001;
            for (M && (t.push(y, x), y = v, x = _, v = t[g - 2], _ = t[g - 1], t.unshift(v, _), g += 4), e = e || 0 === e ? +e : 1, r = 2; r < g; r += 2) n = v, i = _, v = y, _ = x, y = +t[r + 2], x = +t[r + 3], v === y && _ === x || (s = S, o = E, S = y - v, E = x - _, c = ((a = Il(s * s + o * o)) + (l = Il(S * S + E * E))) * e * .25 / Il(Math.pow(S / l + s / a, 2) + Math.pow(E / l + o / a, 2)), d = v - ((u = v - (v - n) * (a ? c / a : 0)) + (((h = v + (y - v) * (l ? c / l : 0)) - u) * (3 * a / (a + l) + .5) / 4 || 0)), m = _ - ((f = _ - (_ - i) * (a ? c / a : 0)) + (((p = _ + (x - _) * (l ? c / l : 0)) - f) * (3 * a / (a + l) + .5) / 4 || 0)), v === n && _ === i || b.push(Vl(u + d), Vl(f + m), Vl(v), Vl(_), Vl(h + d), Vl(p + m)));
            return v !== y || _ !== x || b.length < 4 ? b.push(Vl(y), Vl(x), Vl(y), Vl(x)) : b.length -= 2, 2 === b.length ? b.push(v, _, v, _, v, _) : M && (b.splice(0, 6), b.length = b.length - 6), b
        }

        function uc(t) {
            kl(t[0]) && (t = [t]);
            var e, n, i, r, s = "",
                o = t.length;
            for (n = 0; n < o; n++) {
                for (r = t[n], s += "M" + Vl(r[0]) + "," + Vl(r[1]) + " C", e = r.length, i = 2; i < e; i++) s += Vl(r[i++]) + "," + Vl(r[i++]) + " " + Vl(r[i++]) + "," + Vl(r[i++]) + " " + Vl(r[i++]) + "," + Vl(r[i]) + " ";
                r.closed && (s += "z")
            }
            return s
        }
        var hc, dc, fc, pc, mc, gc, vc, _c, yc, xc = "transform",
            bc = xc + "Origin",
            Sc = function (t) {
                var e = t.ownerDocument || t;
                !(xc in t.style) && "msTransform" in t.style && (bc = (xc = "msTransform") + "Origin");
                for (; e.parentNode && (e = e.parentNode););
                if (dc = window, vc = new Rc, e) {
                    hc = e, fc = e.documentElement, pc = e.body, (_c = hc.createElementNS("http://www.w3.org/2000/svg", "g")).style.transform = "none";
                    var n = e.createElement("div"),
                        i = e.createElement("div"),
                        r = e && (e.body || e.firstElementChild);
                    r && r.appendChild && (r.appendChild(n), n.appendChild(i), n.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), yc = i.offsetParent !== n, r.removeChild(n))
                }
                return e
            },
            Ec = [],
            Mc = [],
            wc = function (t) {
                return t.ownerSVGElement || ("svg" === (t.tagName + "").toLowerCase() ? t : null)
            },
            Tc = function t(e) {
                return "fixed" === dc.getComputedStyle(e).position || ((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0)
            },
            Ac = function t(e, n) {
                if (e.parentNode && (hc || Sc(e))) {
                    var i = wc(e),
                        r = i ? i.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                        s = i ? n ? "rect" : "g" : "div",
                        o = 2 !== n ? 0 : 100,
                        a = 3 === n ? 100 : 0,
                        l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                        c = hc.createElementNS ? hc.createElementNS(r.replace(/^https/, "http"), s) : hc.createElement(s);
                    return n && (i ? (gc || (gc = t(e)), c.setAttribute("width", .01), c.setAttribute("height", .01), c.setAttribute("transform", "translate(" + o + "," + a + ")"), gc.appendChild(c)) : (mc || ((mc = t(e)).style.cssText = l), c.style.cssText = l + "width:0.1px;height:0.1px;top:" + a + "px;left:" + o + "px", mc.appendChild(c))), c
                }
                throw "Need document and parent."
            },
            Pc = function (t, e) {
                var n, i, r, s, o, a, l = wc(t),
                    c = t === l,
                    u = l ? Ec : Mc,
                    h = t.parentNode;
                if (t === dc) return t;
                if (u.length || u.push(Ac(t, 1), Ac(t, 2), Ac(t, 3)), n = l ? gc : mc, l) c ? (r = function (t) {
                    var e, n = t.getCTM();
                    return n || (e = t.style[xc], t.style[xc] = "none", t.appendChild(_c), n = _c.getCTM(), t.removeChild(_c), e ? t.style[xc] = e : t.style.removeProperty(xc.replace(/([A-Z])/g, "-$1").toLowerCase())), n || vc.clone()
                }(t), s = -r.e / r.a, o = -r.f / r.d, i = vc) : t.getBBox ? (r = t.getBBox(), i = (i = t.transform ? t.transform.baseVal : {}).numberOfItems ? i.numberOfItems > 1 ? function (t) {
                    for (var e = new Rc, n = 0; n < t.numberOfItems; n++) e.multiply(t.getItem(n).matrix);
                    return e
                }(i) : i.getItem(0).matrix : vc, s = i.a * r.x + i.c * r.y, o = i.b * r.x + i.d * r.y) : (i = new Rc, s = o = 0), e && "g" === t.tagName.toLowerCase() && (s = o = 0), (c ? l : h).appendChild(n), n.setAttribute("transform", "matrix(" + i.a + "," + i.b + "," + i.c + "," + i.d + "," + (i.e + s) + "," + (i.f + o) + ")");
                else {
                    if (s = o = 0, yc)
                        for (i = t.offsetParent, r = t; r && (r = r.parentNode) && r !== i && r.parentNode;)(dc.getComputedStyle(r)[xc] + "").length > 4 && (s = r.offsetLeft, o = r.offsetTop, r = 0);
                    if ("absolute" !== (a = dc.getComputedStyle(t)).position && "fixed" !== a.position)
                        for (i = t.offsetParent; h && h !== i;) s += h.scrollLeft || 0, o += h.scrollTop || 0, h = h.parentNode;
                    (r = n.style).top = t.offsetTop - o + "px", r.left = t.offsetLeft - s + "px", r[xc] = a[xc], r[bc] = a[bc], r.position = "fixed" === a.position ? "fixed" : "absolute", t.parentNode.appendChild(n)
                }
                return n
            },
            Cc = function (t, e, n, i, r, s, o) {
                return t.a = e, t.b = n, t.c = i, t.d = r, t.e = s, t.f = o, t
            },
            Rc = function () {
                function t(t, e, n, i, r, s) {
                    void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), void 0 === r && (r = 0), void 0 === s && (s = 0), Cc(this, t, e, n, i, r, s)
                }
                var e = t.prototype;
                return e.inverse = function () {
                    var t = this.a,
                        e = this.b,
                        n = this.c,
                        i = this.d,
                        r = this.e,
                        s = this.f,
                        o = t * i - e * n || 1e-10;
                    return Cc(this, i / o, -e / o, -n / o, t / o, (n * s - i * r) / o, -(t * s - e * r) / o)
                }, e.multiply = function (t) {
                    var e = this.a,
                        n = this.b,
                        i = this.c,
                        r = this.d,
                        s = this.e,
                        o = this.f,
                        a = t.a,
                        l = t.c,
                        c = t.b,
                        u = t.d,
                        h = t.e,
                        d = t.f;
                    return Cc(this, a * e + c * i, a * n + c * r, l * e + u * i, l * n + u * r, s + h * e + d * i, o + h * n + d * r)
                }, e.clone = function () {
                    return new t(this.a, this.b, this.c, this.d, this.e, this.f)
                }, e.equals = function (t) {
                    var e = this.a,
                        n = this.b,
                        i = this.c,
                        r = this.d,
                        s = this.e,
                        o = this.f;
                    return e === t.a && n === t.b && i === t.c && r === t.d && s === t.e && o === t.f
                }, e.apply = function (t, e) {
                    void 0 === e && (e = {});
                    var n = t.x,
                        i = t.y,
                        r = this.a,
                        s = this.b,
                        o = this.c,
                        a = this.d,
                        l = this.e,
                        c = this.f;
                    return e.x = n * r + i * o + l || 0, e.y = n * s + i * a + c || 0, e
                }, t
            }();

        function Lc(t, e, n, i) {
            if (!t || !t.parentNode || (hc || Sc(t)).documentElement === t) return new Rc;
            var r = function (t) {
                    for (var e, n; t && t !== pc;)(n = t._gsap) && n.uncache && n.get(t, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), e ? e.push(n) : e = [n]), t = t.parentNode;
                    return e
                }(t),
                s = wc(t) ? Ec : Mc,
                o = Pc(t, n),
                a = s[0].getBoundingClientRect(),
                l = s[1].getBoundingClientRect(),
                c = s[2].getBoundingClientRect(),
                u = o.parentNode,
                h = !i && Tc(t),
                d = new Rc((l.left - a.left) / 100, (l.top - a.top) / 100, (c.left - a.left) / 100, (c.top - a.top) / 100, a.left + (h ? 0 : dc.pageXOffset || hc.scrollLeft || fc.scrollLeft || pc.scrollLeft || 0), a.top + (h ? 0 : dc.pageYOffset || hc.scrollTop || fc.scrollTop || pc.scrollTop || 0));
            if (u.removeChild(o), r)
                for (a = r.length; a--;)(l = r[a]).scaleX = l.scaleY = 0, l.renderTransform(1, l);
            return e ? d.inverse() : d
        }
        var Oc, Ic, Dc, Nc, Uc, kc, Fc = "x,translateX,left,marginLeft,xPercent".split(","),
            zc = "y,translateY,top,marginTop,yPercent".split(","),
            Bc = Math.PI / 180,
            Hc = function (t, e, n, i) {
                for (var r = e.length, s = 2 === i ? 0 : i, o = 0; o < r; o++) t[s] = parseFloat(e[o][n]), 2 === i && (t[s + 1] = 0), s += 2;
                return t
            },
            Vc = function (t, e, n) {
                return parseFloat(t._gsap.get(t, e, n || "px")) || 0
            },
            Gc = function (t) {
                var e, n = t[0],
                    i = t[1];
                for (e = 2; e < t.length; e += 2) n = t[e] += n, i = t[e + 1] += i
            },
            Wc = function (t, e, n, i, r, s, o, a, l) {
                "cubic" === o.type ? e = [e] : (!1 !== o.fromCurrent && e.unshift(Vc(n, i, a), r ? Vc(n, r, l) : 0), o.relative && Gc(e), e = [(r ? cc : lc)(e, o.curviness)]);
                return e = s(Kc(e, n, o)), Zc(t, n, i, e, "x", a), r && Zc(t, n, r, e, "y", l), ec(e, o.resolution || (0 === o.curviness ? 20 : 12))
            },
            jc = function (t) {
                return t
            },
            Xc = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g,
            qc = function (t, e, n) {
                var i, r = Lc(t),
                    s = 0,
                    o = 0;
                return "svg" === (t.tagName + "").toLowerCase() ? (i = t.viewBox.baseVal).width || (i = {
                    width: +t.getAttribute("width"),
                    height: +t.getAttribute("height")
                }) : i = e && t.getBBox && t.getBBox(), e && "auto" !== e && (s = e.push ? e[0] * (i ? i.width : t.offsetWidth || 0) : e.x, o = e.push ? e[1] * (i ? i.height : t.offsetHeight || 0) : e.y), n.apply(s || o ? r.apply({
                    x: s,
                    y: o
                }) : {
                    x: r.e,
                    y: r.f
                })
            },
            Yc = function (t, e, n, i) {
                var r, s = Lc(t.parentNode, !0, !0),
                    o = s.clone().multiply(Lc(e)),
                    a = qc(t, n, s),
                    l = qc(e, i, s),
                    c = l.x,
                    u = l.y;
                return o.e = o.f = 0, "auto" === i && e.getTotalLength && "path" === e.tagName.toLowerCase() && (r = e.getAttribute("d").match(Xc) || [], c += (r = o.apply({
                    x: +r[0],
                    y: +r[1]
                })).x, u += r.y), r && (c -= (r = o.apply(e.getBBox())).x, u -= r.y), o.e = c - a.x, o.f = u - a.y, o
            },
            Kc = function (t, e, n) {
                var i, r, s, o = n.align,
                    a = n.matrix,
                    l = n.offsetX,
                    c = n.offsetY,
                    u = n.alignOrigin,
                    h = t[0][0],
                    d = t[0][1],
                    f = Vc(e, "x"),
                    p = Vc(e, "y");
                return t && t.length ? (o && ("self" === o || (i = Nc(o)[0] || e) === e ? sc(t, 1, 0, 0, 1, f - h, p - d) : (u && !1 !== u[2] ? Oc.set(e, {
                    transformOrigin: 100 * u[0] + "% " + 100 * u[1] + "%"
                }) : u = [Vc(e, "xPercent") / -100, Vc(e, "yPercent") / -100], s = (r = Yc(e, i, u, "auto")).apply({
                    x: h,
                    y: d
                }), sc(t, r.a, r.b, r.c, r.d, f + r.e - (s.x - r.e), p + r.f - (s.y - r.f)))), a ? sc(t, a.a, a.b, a.c, a.d, a.e, a.f) : (l || c) && sc(t, 1, 0, 0, 1, l || 0, c || 0), t) : Yl("M0,0L0,0")
            },
            Zc = function (t, e, n, i, r, s) {
                var o = e._gsap,
                    a = o.harness,
                    l = a && a.aliases && a.aliases[n],
                    c = l && l.indexOf(",") < 0 ? l : n,
                    u = t._pt = new Ic(t._pt, e, c, 0, 0, jc, 0, o.set(e, c, t));
                u.u = Dc(o.get(e, c, s)) || 0, u.path = i, u.pp = r, t._props.push(c)
            },
            Jc = {
                version: "3.12.5",
                name: "motionPath",
                register: function (t, e, n) {
                    Dc = (Oc = t).utils.getUnit, Nc = Oc.utils.toArray, Uc = Oc.core.getStyleSaver, kc = Oc.core.reverting || function () {}, Ic = n
                },
                init: function (t, e, n) {
                    if (!Oc) return !1;
                    "object" == typeof e && !e.style && e.path || (e = {
                        path: e
                    });
                    var i, r, s, o, a = [],
                        l = e,
                        c = l.path,
                        u = l.autoRotate,
                        h = l.unitX,
                        d = l.unitY,
                        f = l.x,
                        p = l.y,
                        m = c[0],
                        g = (s = e.start, o = "end" in e ? e.end : 1, function (t) {
                            return s || 1 !== o ? Ql(t, s, o) : t
                        });
                    if (this.rawPaths = a, this.target = t, this.tween = n, this.styles = Uc && Uc(t, "transform"), (this.rotate = u || 0 === u) && (this.rOffset = parseFloat(u) || 0, this.radians = !!e.useRadians, this.rProp = e.rotation || "rotation", this.rSet = t._gsap.set(t, this.rProp, this), this.ru = Dc(t._gsap.get(t, this.rProp)) || 0), Array.isArray(c) && !("closed" in c) && "number" != typeof m) {
                        for (r in m) !f && ~Fc.indexOf(r) ? f = r : !p && ~zc.indexOf(r) && (p = r);
                        for (r in f && p ? a.push(Wc(this, Hc(Hc([], c, f, 0), c, p, 1), t, f, p, g, e, h || Dc(c[0][f]), d || Dc(c[0][p]))) : f = p = 0, m) r !== f && r !== p && a.push(Wc(this, Hc([], c, r, 2), t, r, 0, g, e, Dc(c[0][r])))
                    } else ec(i = g(Kc(Yl(e.path), t, e)), e.resolution), a.push(i), Zc(this, t, e.x || "x", i, "x", e.unitX || "px"), Zc(this, t, e.y || "y", i, "y", e.unitY || "px")
                },
                render: function (t, e) {
                    var n = e.rawPaths,
                        i = n.length,
                        r = e._pt;
                    if (e.tween._time || !kc()) {
                        for (t > 1 ? t = 1 : t < 0 && (t = 0); i--;) rc(n[i], t, !i && e.rotate, n[i]);
                        for (; r;) r.set(r.t, r.p, r.path[r.pp] + r.u, r.d, t), r = r._next;
                        e.rotate && e.rSet(e.target, e.rProp, n[0].angle * (e.radians ? Bc : 1) + e.rOffset + e.ru, e, t)
                    } else e.styles.revert()
                },
                getLength: function (t) {
                    return ec(Yl(t)).totalLength
                },
                sliceRawPath: Ql,
                getRawPath: Yl,
                pointsToSegment: cc,
                stringToRawPath: ac,
                rawPathToString: uc,
                transformRawPath: sc,
                getGlobalMatrix: Lc,
                getPositionOnPath: rc,
                cacheRawPathMeasurements: ec,
                convertToPath: function (t, e) {
                    return Nc(t).map((function (t) {
                        return Jl(t, !1 !== e)
                    }))
                },
                convertCoordinates: function (t, e, n) {
                    var i = Lc(e, !0, !0).multiply(Lc(t));
                    return n ? i.apply(n) : i
                },
                getAlignMatrix: Yc,
                getRelativePosition: function (t, e, n, i) {
                    var r = Yc(t, e, n, i);
                    return {
                        x: r.e,
                        y: r.f
                    }
                },
                arrayToRawPath: function (t, e) {
                    var n = Hc(Hc([], t, (e = e || {}).x || "x", 0), t, e.y || "y", 1);
                    return e.relative && Gc(n), ["cubic" === e.type ? n : cc(n, e.curviness)]
                }
            };
        (Oc || "undefined" != typeof window && (Oc = window.gsap) && Oc.registerPlugin && Oc) && Oc.registerPlugin(Jc);
        const $c = "160",
            Qc = 1,
            tu = 2,
            eu = 3,
            nu = 0,
            iu = 1,
            ru = 100,
            su = 0,
            ou = 1,
            au = 2,
            lu = 0,
            cu = 1,
            uu = 2,
            hu = 3,
            du = 4,
            fu = 5,
            pu = 6,
            mu = "attached",
            gu = 301,
            vu = 302,
            _u = 303,
            yu = 304,
            xu = 306,
            bu = 1e3,
            Su = 1001,
            Eu = 1002,
            Mu = 1003,
            wu = 1004,
            Tu = 1005,
            Au = 1006,
            Pu = 1007,
            Cu = 1008,
            Ru = 1009,
            Lu = 1012,
            Ou = 1013,
            Iu = 1014,
            Du = 1015,
            Nu = 1016,
            Uu = 1020,
            ku = 1023,
            Fu = 1026,
            zu = 1027,
            Bu = 33776,
            Hu = 33777,
            Vu = 33778,
            Gu = 33779,
            Wu = 36492,
            ju = 2300,
            Xu = 2301,
            qu = 2302,
            Yu = 2400,
            Ku = 2401,
            Zu = 2402,
            Ju = 3001,
            $u = "",
            Qu = "srgb",
            th = "srgb-linear",
            eh = "display-p3",
            nh = "display-p3-linear",
            ih = "linear",
            rh = "srgb",
            sh = "rec709",
            oh = "p3",
            ah = 7680,
            lh = 35044,
            ch = "300 es",
            uh = 1035,
            hh = 2e3,
            dh = 2001;
        class fh {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                    t.target = null
                }
            }
        }
        const ph = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let mh = 1234567;
        const gh = Math.PI / 180,
            vh = 180 / Math.PI;

        function _h() {
            const t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                i = 4294967295 * Math.random() | 0;
            return (ph[255 & t] + ph[t >> 8 & 255] + ph[t >> 16 & 255] + ph[t >> 24 & 255] + "-" + ph[255 & e] + ph[e >> 8 & 255] + "-" + ph[e >> 16 & 15 | 64] + ph[e >> 24 & 255] + "-" + ph[63 & n | 128] + ph[n >> 8 & 255] + "-" + ph[n >> 16 & 255] + ph[n >> 24 & 255] + ph[255 & i] + ph[i >> 8 & 255] + ph[i >> 16 & 255] + ph[i >> 24 & 255]).toLowerCase()
        }

        function yh(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }

        function xh(t, e) {
            return (t % e + e) % e
        }

        function bh(t, e, n) {
            return (1 - n) * t + n * e
        }

        function Sh(t) {
            return 0 == (t & t - 1) && 0 !== t
        }

        function Eh(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }

        function Mh(t, e) {
            switch (e.constructor) {
                case Float32Array:
                    return t;
                case Uint32Array:
                    return t / 4294967295;
                case Uint16Array:
                    return t / 65535;
                case Uint8Array:
                    return t / 255;
                case Int32Array:
                    return Math.max(t / 2147483647, -1);
                case Int16Array:
                    return Math.max(t / 32767, -1);
                case Int8Array:
                    return Math.max(t / 127, -1);
                default:
                    throw new Error("Invalid component type.")
            }
        }

        function wh(t, e) {
            switch (e.constructor) {
                case Float32Array:
                    return t;
                case Uint32Array:
                    return Math.round(4294967295 * t);
                case Uint16Array:
                    return Math.round(65535 * t);
                case Uint8Array:
                    return Math.round(255 * t);
                case Int32Array:
                    return Math.round(2147483647 * t);
                case Int16Array:
                    return Math.round(32767 * t);
                case Int8Array:
                    return Math.round(127 * t);
                default:
                    throw new Error("Invalid component type.")
            }
        }
        const Th = {
            DEG2RAD: gh,
            RAD2DEG: vh,
            generateUUID: _h,
            clamp: yh,
            euclideanModulo: xh,
            mapLinear: function (t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            inverseLerp: function (t, e, n) {
                return t !== e ? (n - t) / (e - t) : 0
            },
            lerp: bh,
            damp: function (t, e, n, i) {
                return bh(t, e, 1 - Math.exp(-n * i))
            },
            pingpong: function (t, e = 1) {
                return e - Math.abs(xh(t, 2 * e) - e)
            },
            smoothstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function (t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function (t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function (t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function (t) {
                void 0 !== t && (mh = t);
                let e = mh += 1831565813;
                return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
            },
            degToRad: function (t) {
                return t * gh
            },
            radToDeg: function (t) {
                return t * vh
            },
            isPowerOfTwo: Sh,
            ceilPowerOfTwo: function (t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: Eh,
            setQuaternionFromProperEuler: function (t, e, n, i, r) {
                const s = Math.cos,
                    o = Math.sin,
                    a = s(n / 2),
                    l = o(n / 2),
                    c = s((e + i) / 2),
                    u = o((e + i) / 2),
                    h = s((e - i) / 2),
                    d = o((e - i) / 2),
                    f = s((i - e) / 2),
                    p = o((i - e) / 2);
                switch (r) {
                    case "XYX":
                        t.set(a * u, l * h, l * d, a * c);
                        break;
                    case "YZY":
                        t.set(l * d, a * u, l * h, a * c);
                        break;
                    case "ZXZ":
                        t.set(l * h, l * d, a * u, a * c);
                        break;
                    case "XZX":
                        t.set(a * u, l * p, l * f, a * c);
                        break;
                    case "YXY":
                        t.set(l * f, a * u, l * p, a * c);
                        break;
                    case "ZYZ":
                        t.set(l * p, l * f, a * u, a * c)
                }
            },
            normalize: wh,
            denormalize: Mh
        };
        class Ah {
            constructor(t = 0, e = 0) {
                Ah.prototype.isVector2 = !0, this.x = t, this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t, this.y = e, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(yh(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this
            }
            rotateAround(t, e) {
                const n = Math.cos(e),
                    i = Math.sin(e),
                    r = this.x - t.x,
                    s = this.y - t.y;
                return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        class Ph {
            constructor(t, e, n, i, r, s, o, a, l) {
                Ph.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, s, o, a, l)
            }
            set(t, e, n, i, r, s, o, a, l) {
                const c = this.elements;
                return c[0] = t, c[1] = i, c[2] = o, c[3] = e, c[4] = r, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    s = n[0],
                    o = n[3],
                    a = n[6],
                    l = n[1],
                    c = n[4],
                    u = n[7],
                    h = n[2],
                    d = n[5],
                    f = n[8],
                    p = i[0],
                    m = i[3],
                    g = i[6],
                    v = i[1],
                    _ = i[4],
                    y = i[7],
                    x = i[2],
                    b = i[5],
                    S = i[8];
                return r[0] = s * p + o * v + a * x, r[3] = s * m + o * _ + a * b, r[6] = s * g + o * y + a * S, r[1] = l * p + c * v + u * x, r[4] = l * m + c * _ + u * b, r[7] = l * g + c * y + u * S, r[2] = h * p + d * v + f * x, r[5] = h * m + d * _ + f * b, r[8] = h * g + d * y + f * S, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    l = t[7],
                    c = t[8];
                return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    l = t[7],
                    c = t[8],
                    u = c * s - o * l,
                    h = o * a - c * r,
                    d = l * r - s * a,
                    f = e * u + n * h + i * d;
                if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const p = 1 / f;
                return t[0] = u * p, t[1] = (i * l - c * n) * p, t[2] = (o * n - i * s) * p, t[3] = h * p, t[4] = (c * e - i * a) * p, t[5] = (i * r - o * e) * p, t[6] = d * p, t[7] = (n * a - l * e) * p, t[8] = (s * e - n * r) * p, this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }
            setUvTransform(t, e, n, i, r, s, o) {
                const a = Math.cos(r),
                    l = Math.sin(r);
                return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1), this
            }
            scale(t, e) {
                return this.premultiply(Ch.makeScale(t, e)), this
            }
            rotate(t) {
                return this.premultiply(Ch.makeRotation(-t)), this
            }
            translate(t, e) {
                return this.premultiply(Ch.makeTranslation(t, e)), this
            }
            makeTranslation(t, e) {
                return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
            }
            makeRotation(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
            }
            makeScale(t, e) {
                return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Ch = new Ph;

        function Rh(t) {
            for (let e = t.length - 1; e >= 0; --e)
                if (t[e] >= 65535) return !0;
            return !1
        }
        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

        function Lh(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }

        function Oh() {
            const t = Lh("canvas");
            return t.style.display = "block", t
        }
        const Ih = {};

        function Dh(t) {
            t in Ih || (Ih[t] = !0)
        }
        const Nh = (new Ph).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
            Uh = (new Ph).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
            kh = {
                [th]: {
                    transfer: ih,
                    primaries: sh,
                    toReference: t => t,
                    fromReference: t => t
                },
                [Qu]: {
                    transfer: rh,
                    primaries: sh,
                    toReference: t => t.convertSRGBToLinear(),
                    fromReference: t => t.convertLinearToSRGB()
                },
                [nh]: {
                    transfer: ih,
                    primaries: oh,
                    toReference: t => t.applyMatrix3(Uh),
                    fromReference: t => t.applyMatrix3(Nh)
                },
                [eh]: {
                    transfer: rh,
                    primaries: oh,
                    toReference: t => t.convertSRGBToLinear().applyMatrix3(Uh),
                    fromReference: t => t.applyMatrix3(Nh).convertLinearToSRGB()
                }
            },
            Fh = new Set([th, nh]),
            zh = {
                enabled: !0,
                _workingColorSpace: th,
                get workingColorSpace() {
                    return this._workingColorSpace
                },
                set workingColorSpace(t) {
                    if (!Fh.has(t)) throw new Error(`Unsupported working color space, "${t}".`);
                    this._workingColorSpace = t
                },
                convert: function (t, e, n) {
                    if (!1 === this.enabled || e === n || !e || !n) return t;
                    const i = kh[e].toReference;
                    return (0, kh[n].fromReference)(i(t))
                },
                fromWorkingColorSpace: function (t, e) {
                    return this.convert(t, this._workingColorSpace, e)
                },
                toWorkingColorSpace: function (t, e) {
                    return this.convert(t, e, this._workingColorSpace)
                },
                getPrimaries: function (t) {
                    return kh[t].primaries
                },
                getTransfer: function (t) {
                    return t === $u ? ih : kh[t].transfer
                }
            };

        function Bh(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function Hh(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        let Vh;
        class Gh {
            static getDataURL(t) {
                if (/^data:/i.test(t.src)) return t.src;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                let e;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    void 0 === Vh && (Vh = Lh("canvas")), Vh.width = t.width, Vh.height = t.height;
                    const n = Vh.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Vh
                }
                return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
            static sRGBToLinear(t) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const e = Lh("canvas");
                    e.width = t.width, e.height = t.height;
                    const n = e.getContext("2d");
                    n.drawImage(t, 0, 0, t.width, t.height);
                    const i = n.getImageData(0, 0, t.width, t.height),
                        r = i.data;
                    for (let t = 0; t < r.length; t++) r[t] = 255 * Bh(r[t] / 255);
                    return n.putImageData(i, 0, 0), e
                }
                if (t.data) {
                    const e = t.data.slice(0);
                    for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Bh(e[t] / 255)) : e[t] = Bh(e[t]);
                    return {
                        data: e,
                        width: t.width,
                        height: t.height
                    }
                }
                return t
            }
        }
        let Wh = 0;
        class jh {
            constructor(t = null) {
                this.isSource = !0, Object.defineProperty(this, "id", {
                    value: Wh++
                }), this.uuid = _h(), this.data = t, this.version = 0
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                const n = {
                        uuid: this.uuid,
                        url: ""
                    },
                    i = this.data;
                if (null !== i) {
                    let t;
                    if (Array.isArray(i)) {
                        t = [];
                        for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(Xh(i[e].image)) : t.push(Xh(i[e]))
                    } else t = Xh(i);
                    n.url = t
                }
                return e || (t.images[this.uuid] = n), n
            }
        }

        function Xh(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Gh.getDataURL(t) : t.data ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : {}
        }
        let qh = 0;
        class Yh extends fh {
            constructor(t = Yh.DEFAULT_IMAGE, e = Yh.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, o = 1023, a = 1009, l = Yh.DEFAULT_ANISOTROPY, c = "") {
                super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                    value: qh++
                }), this.uuid = _h(), this.name = "", this.source = new jh(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new Ah(0, 0), this.repeat = new Ah(1, 1), this.center = new Ah(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ph, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, "string" == typeof c ? this.colorSpace = c : (Dh("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = c === Ju ? Qu : $u), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(t = null) {
                this.source.data = t
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(t).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case bu:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case Su:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case Eu:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case bu:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case Su:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case Eu:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
            set needsUpdate(t) {
                !0 === t && (this.version++, this.source.needsUpdate = !0)
            }
            get encoding() {
                return Dh("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Qu ? Ju : 3e3
            }
            set encoding(t) {
                Dh("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = t === Ju ? Qu : $u
            }
        }
        Yh.DEFAULT_IMAGE = null, Yh.DEFAULT_MAPPING = 300, Yh.DEFAULT_ANISOTROPY = 1;
        class Kh {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                Kh.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t, this.y = e, this.z = n, this.w = i, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setW(t) {
                return this.w = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    s = t.elements;
                return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const s = .01,
                    o = .1,
                    a = t.elements,
                    l = a[0],
                    c = a[4],
                    u = a[8],
                    h = a[1],
                    d = a[5],
                    f = a[9],
                    p = a[2],
                    m = a[6],
                    g = a[10];
                if (Math.abs(c - h) < s && Math.abs(u - p) < s && Math.abs(f - m) < s) {
                    if (Math.abs(c + h) < o && Math.abs(u + p) < o && Math.abs(f + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const t = (l + 1) / 2,
                        a = (d + 1) / 2,
                        v = (g + 1) / 2,
                        _ = (c + h) / 4,
                        y = (u + p) / 4,
                        x = (f + m) / 4;
                    return t > a && t > v ? t < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = _ / n, r = y / n) : a > v ? a < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = _ / i, r = x / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = y / r, i = x / r), this.set(n, i, r, e), this
                }
                let v = Math.sqrt((m - f) * (m - f) + (u - p) * (u - p) + (h - c) * (h - c));
                return Math.abs(v) < .001 && (v = 1), this.x = (m - f) / v, this.y = (u - p) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        class Zh extends fh {
            constructor(t = 1, e = 1, n = {}) {
                super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new Kh(0, 0, t, e), this.scissorTest = !1, this.viewport = new Kh(0, 0, t, e);
                const i = {
                    width: t,
                    height: e,
                    depth: 1
                };
                void 0 !== n.encoding && (Dh("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === Ju ? Qu : $u), n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: Au,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0
                }, n), this.texture = new Yh(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps, this.texture.internalFormat = n.internalFormat, this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
            }
            setSize(t, e, n = 1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
                const e = Object.assign({}, t.texture.image);
                return this.texture.source = new jh(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Jh extends Zh {
            constructor(t = 1, e = 1, n = {}) {
                super(t, e, n), this.isWebGLRenderTarget = !0
            }
        }
        class $h extends Yh {
            constructor(t = null, e = 1, n = 1, i = 1) {
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = Mu, this.minFilter = Mu, this.wrapR = Su, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class Qh extends Yh {
            constructor(t = null, e = 1, n = 1, i = 1) {
                super(null), this.isData3DTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = Mu, this.minFilter = Mu, this.wrapR = Su, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class td {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i
            }
            static slerpFlat(t, e, n, i, r, s, o) {
                let a = n[i + 0],
                    l = n[i + 1],
                    c = n[i + 2],
                    u = n[i + 3];
                const h = r[s + 0],
                    d = r[s + 1],
                    f = r[s + 2],
                    p = r[s + 3];
                if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = u);
                if (1 === o) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = f, void(t[e + 3] = p);
                if (u !== p || a !== h || l !== d || c !== f) {
                    let t = 1 - o;
                    const e = a * h + l * d + c * f + u * p,
                        n = e >= 0 ? 1 : -1,
                        i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i),
                            s = Math.atan2(r, e * n);
                        t = Math.sin(t * s) / r, o = Math.sin(o * s) / r
                    }
                    const r = o * n;
                    if (a = a * t + h * r, l = l * t + d * r, c = c * t + f * r, u = u * t + p * r, t === 1 - o) {
                        const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                        a *= t, l *= t, c *= t, u *= t
                    }
                }
                t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = u
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                const o = n[i],
                    a = n[i + 1],
                    l = n[i + 2],
                    c = n[i + 3],
                    u = r[s],
                    h = r[s + 1],
                    d = r[s + 2],
                    f = r[s + 3];
                return t[e] = o * f + c * u + a * d - l * h, t[e + 1] = a * f + c * h + l * u - o * d, t[e + 2] = l * f + c * d + o * h - a * u, t[e + 3] = c * f - o * u - a * h - l * d, t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t, this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }
            setFromEuler(t, e = !0) {
                const n = t._x,
                    i = t._y,
                    r = t._z,
                    s = t._order,
                    o = Math.cos,
                    a = Math.sin,
                    l = o(n / 2),
                    c = o(i / 2),
                    u = o(r / 2),
                    h = a(n / 2),
                    d = a(i / 2),
                    f = a(r / 2);
                switch (s) {
                    case "XYZ":
                        this._x = h * c * u + l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u - h * d * f;
                        break;
                    case "YXZ":
                        this._x = h * c * u + l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u + h * d * f;
                        break;
                    case "ZXY":
                        this._x = h * c * u - l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u - h * d * f;
                        break;
                    case "ZYX":
                        this._x = h * c * u - l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u + h * d * f;
                        break;
                    case "YZX":
                        this._x = h * c * u + l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u - h * d * f;
                        break;
                    case "XZY":
                        this._x = h * c * u - l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u + h * d * f
                }
                return !0 === e && this._onChangeCallback(), this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2,
                    i = Math.sin(n);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(t) {
                const e = t.elements,
                    n = e[0],
                    i = e[4],
                    r = e[8],
                    s = e[1],
                    o = e[5],
                    a = e[9],
                    l = e[2],
                    c = e[6],
                    u = e[10],
                    h = n + o + u;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (s - i) * t
                } else if (n > o && n > u) {
                    const t = 2 * Math.sqrt(1 + n - o - u);
                    this._w = (c - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
                } else if (o > u) {
                    const t = 2 * Math.sqrt(1 + o - n - u);
                    this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + c) / t
                } else {
                    const t = 2 * Math.sqrt(1 + u - n - o);
                    this._w = (s - i) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = .25 * t
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(yh(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n) return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }
            multiply(t) {
                return this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x,
                    i = t._y,
                    r = t._z,
                    s = t._w,
                    o = e._x,
                    a = e._y,
                    l = e._z,
                    c = e._w;
                return this._x = n * c + s * o + i * l - r * a, this._y = i * c + s * a + r * o - n * l, this._z = r * c + s * l + n * a - i * o, this._w = s * c - n * o - i * a - r * l, this._onChangeCallback(), this
            }
            slerp(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                const n = this._x,
                    i = this._y,
                    r = this._z,
                    s = this._w;
                let o = s * t._w + n * t._x + i * t._y + r * t._z;
                if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                const a = 1 - o * o;
                if (a <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this
                }
                const l = Math.sqrt(a),
                    c = Math.atan2(l, o),
                    u = Math.sin((1 - e) * c) / l,
                    h = Math.sin(e * c) / l;
                return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this
            }
            slerpQuaternions(t, e, n) {
                return this.copy(t).slerp(e, n)
            }
            random() {
                const t = Math.random(),
                    e = Math.sqrt(1 - t),
                    n = Math.sqrt(t),
                    i = 2 * Math.PI * Math.random(),
                    r = 2 * Math.PI * Math.random();
                return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e = 0) {
                return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w
            }
        }
        class ed {
            constructor(t = 0, e = 0, n = 0) {
                ed.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }
            applyEuler(t) {
                return this.applyQuaternion(id.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(id.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements,
                    s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
            }
            applyQuaternion(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.x,
                    s = t.y,
                    o = t.z,
                    a = t.w,
                    l = 2 * (s * i - o * n),
                    c = 2 * (o * e - r * i),
                    u = 2 * (r * n - s * e);
                return this.x = e + a * l + s * u - o * c, this.y = n + a * c + o * l - r * u, this.z = i + a * u + r * c - s * l, this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
            }
            cross(t) {
                return this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x,
                    i = t.y,
                    r = t.z,
                    s = e.x,
                    o = e.y,
                    a = e.z;
                return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return nd.copy(this).projectOnVector(t), this.sub(nd)
            }
            reflect(t) {
                return this.sub(nd.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(yh(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y,
                    i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = i, this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            setFromEuler(t) {
                return this.x = t._x, this.y = t._y, this.z = t._z, this
            }
            setFromColor(t) {
                return this.x = t.r, this.y = t.g, this.z = t.b, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const t = 2 * (Math.random() - .5),
                    e = Math.random() * Math.PI * 2,
                    n = Math.sqrt(1 - t ** 2);
                return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        const nd = new ed,
            id = new td;
        class rd {
            constructor(t = new ed(1 / 0, 1 / 0, 1 / 0), e = new ed(-1 / 0, -1 / 0, -1 / 0)) {
                this.isBox3 = !0, this.min = t, this.max = e
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromArray(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(od.fromArray(t, e));
                return this
            }
            setFromBufferAttribute(t) {
                this.makeEmpty();
                for (let e = 0, n = t.count; e < n; e++) this.expandByPoint(od.fromBufferAttribute(t, e));
                return this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = od.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            setFromObject(t, e = !1) {
                return this.makeEmpty(), this.expandByObject(t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            expandByObject(t, e = !1) {
                t.updateWorldMatrix(!1, !1);
                const n = t.geometry;
                if (void 0 !== n) {
                    const i = n.getAttribute("position");
                    if (!0 === e && void 0 !== i && !0 !== t.isInstancedMesh)
                        for (let e = 0, n = i.count; e < n; e++) !0 === t.isMesh ? t.getVertexPosition(e, od) : od.fromBufferAttribute(i, e), od.applyMatrix4(t.matrixWorld), this.expandByPoint(od);
                    else void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(), ad.copy(t.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), ad.copy(n.boundingBox)), ad.applyMatrix4(t.matrixWorld), this.union(ad)
                }
                const i = t.children;
                for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, od), od.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(pd), md.subVectors(this.max, pd), ld.subVectors(t.a, pd), cd.subVectors(t.b, pd), ud.subVectors(t.c, pd), hd.subVectors(cd, ld), dd.subVectors(ud, cd), fd.subVectors(ld, ud);
                let e = [0, -hd.z, hd.y, 0, -dd.z, dd.y, 0, -fd.z, fd.y, hd.z, 0, -hd.x, dd.z, 0, -dd.x, fd.z, 0, -fd.x, -hd.y, hd.x, 0, -dd.y, dd.x, 0, -fd.y, fd.x, 0];
                return !!_d(e, ld, cd, ud, md) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!_d(e, ld, cd, ud, md) && (gd.crossVectors(hd, dd), e = [gd.x, gd.y, gd.z], _d(e, ld, cd, ud, md)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return this.clampPoint(t, od).distanceTo(t)
            }
            getBoundingSphere(t) {
                return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(od).length()), t
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (sd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), sd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), sd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), sd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), sd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), sd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), sd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), sd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(sd)), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        const sd = [new ed, new ed, new ed, new ed, new ed, new ed, new ed, new ed],
            od = new ed,
            ad = new rd,
            ld = new ed,
            cd = new ed,
            ud = new ed,
            hd = new ed,
            dd = new ed,
            fd = new ed,
            pd = new ed,
            md = new ed,
            gd = new ed,
            vd = new ed;

        function _d(t, e, n, i, r) {
            for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                vd.fromArray(t, s);
                const o = r.x * Math.abs(vd.x) + r.y * Math.abs(vd.y) + r.z * Math.abs(vd.z),
                    a = e.dot(vd),
                    l = n.dot(vd),
                    c = i.dot(vd);
                if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
            }
            return !0
        }
        const yd = new rd,
            xd = new ed,
            bd = new ed;
        class Sd {
            constructor(t = new ed, e = -1) {
                this.isSphere = !0, this.center = t, this.radius = e
            }
            set(t, e) {
                return this.center.copy(t), this.radius = e, this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : yd.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(i), this
            }
            copy(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }
            translate(t) {
                return this.center.add(t), this
            }
            expandByPoint(t) {
                if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
                xd.subVectors(t, this.center);
                const e = xd.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e),
                        n = .5 * (t - this.radius);
                    this.center.addScaledVector(xd, n / t), this.radius += n
                }
                return this
            }
            union(t) {
                return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (bd.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(xd.copy(t.center).add(bd)), this.expandByPoint(xd.copy(t.center).sub(bd))), this)
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Ed = new ed,
            Md = new ed,
            wd = new ed,
            Td = new ed,
            Ad = new ed,
            Pd = new ed,
            Cd = new ed;
        class Rd {
            constructor(t = new ed, e = new ed(0, 0, -1)) {
                this.origin = t, this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }
            copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }
            at(t, e) {
                return e.copy(this.origin).addScaledVector(this.direction, t)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }
            recast(t) {
                return this.origin.copy(this.at(t, Ed)), this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = Ed.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Ed.copy(this.origin).addScaledVector(this.direction, e), Ed.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                Md.copy(t).add(e).multiplyScalar(.5), wd.copy(e).sub(t).normalize(), Td.copy(this.origin).sub(Md);
                const r = .5 * t.distanceTo(e),
                    s = -this.direction.dot(wd),
                    o = Td.dot(this.direction),
                    a = -Td.dot(wd),
                    l = Td.lengthSq(),
                    c = Math.abs(1 - s * s);
                let u, h, d, f;
                if (c > 0)
                    if (u = s * a - o, h = s * o - a, f = r * c, u >= 0)
                        if (h >= -f)
                            if (h <= f) {
                                const t = 1 / c;
                                u *= t, h *= t, d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l
                            } else h = r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                else h = -r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                else h <= -f ? (u = Math.max(0, -(-s * r + o)), h = u > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + l) : h <= f ? (u = 0, h = Math.min(Math.max(-r, -a), r), d = h * (h + 2 * a) + l) : (u = Math.max(0, -(s * r + o)), h = u > 0 ? r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + l);
                else h = s > 0 ? -r : r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, u), i && i.copy(Md).addScaledVector(wd, h), d
            }
            intersectSphere(t, e) {
                Ed.subVectors(t.center, this.origin);
                const n = Ed.dot(this.direction),
                    i = Ed.dot(Ed) - n * n,
                    r = t.radius * t.radius;
                if (i > r) return null;
                const s = Math.sqrt(r - i),
                    o = n - s,
                    a = n + s;
                return a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e) return !0;
                return t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, s, o, a;
                const l = 1 / this.direction.x,
                    c = 1 / this.direction.y,
                    u = 1 / this.direction.z,
                    h = this.origin;
                return l >= 0 ? (n = (t.min.x - h.x) * l, i = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l, i = (t.min.x - h.x) * l), c >= 0 ? (r = (t.min.y - h.y) * c, s = (t.max.y - h.y) * c) : (r = (t.max.y - h.y) * c, s = (t.min.y - h.y) * c), n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r), (s < i || isNaN(i)) && (i = s), u >= 0 ? (o = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, Ed)
            }
            intersectTriangle(t, e, n, i, r) {
                Ad.subVectors(e, t), Pd.subVectors(n, t), Cd.crossVectors(Ad, Pd);
                let s, o = this.direction.dot(Cd);
                if (o > 0) {
                    if (i) return null;
                    s = 1
                } else {
                    if (!(o < 0)) return null;
                    s = -1, o = -o
                }
                Td.subVectors(this.origin, t);
                const a = s * this.direction.dot(Pd.crossVectors(Td, Pd));
                if (a < 0) return null;
                const l = s * this.direction.dot(Ad.cross(Td));
                if (l < 0) return null;
                if (a + l > o) return null;
                const c = -s * Td.dot(Cd);
                return c < 0 ? null : this.at(c / o, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Ld {
            constructor(t, e, n, i, r, s, o, a, l, c, u, h, d, f, p, m) {
                Ld.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, s, o, a, l, c, u, h, d, f, p, m)
            }
            set(t, e, n, i, r, s, o, a, l, c, u, h, d, f, p, m) {
                const g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = f, g[11] = p, g[15] = m, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new Ld).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            }
            copyPosition(t) {
                const e = this.elements,
                    n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(t) {
                const e = this.elements,
                    n = t.elements,
                    i = 1 / Od.setFromMatrixColumn(t, 0).length(),
                    r = 1 / Od.setFromMatrixColumn(t, 1).length(),
                    s = 1 / Od.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromEuler(t) {
                const e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z,
                    s = Math.cos(n),
                    o = Math.sin(n),
                    a = Math.cos(i),
                    l = Math.sin(i),
                    c = Math.cos(r),
                    u = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = s * c,
                        n = s * u,
                        i = o * c,
                        r = o * u;
                    e[0] = a * c, e[4] = -a * u, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -o * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * a
                } else if ("YXZ" === t.order) {
                    const t = a * c,
                        n = a * u,
                        i = l * c,
                        r = l * u;
                    e[0] = t + r * o, e[4] = i * o - n, e[8] = s * l, e[1] = s * u, e[5] = s * c, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a
                } else if ("ZXY" === t.order) {
                    const t = a * c,
                        n = a * u,
                        i = l * c,
                        r = l * u;
                    e[0] = t - r * o, e[4] = -s * u, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * c, e[9] = r - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a
                } else if ("ZYX" === t.order) {
                    const t = s * c,
                        n = s * u,
                        i = o * c,
                        r = o * u;
                    e[0] = a * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * u, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = s * a
                } else if ("YZX" === t.order) {
                    const t = s * a,
                        n = s * l,
                        i = o * a,
                        r = o * l;
                    e[0] = a * c, e[4] = r - t * u, e[8] = i * u + n, e[1] = u, e[5] = s * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * u + i, e[10] = t - r * u
                } else if ("XZY" === t.order) {
                    const t = s * a,
                        n = s * l,
                        i = o * a,
                        r = o * l;
                    e[0] = a * c, e[4] = -u, e[8] = l * c, e[1] = t * u + r, e[5] = s * c, e[9] = n * u - i, e[2] = i * u - n, e[6] = o * c, e[10] = r * u + t
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Dd, t, Nd)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return Fd.subVectors(t, e), 0 === Fd.lengthSq() && (Fd.z = 1), Fd.normalize(), Ud.crossVectors(n, Fd), 0 === Ud.lengthSq() && (1 === Math.abs(n.z) ? Fd.x += 1e-4 : Fd.z += 1e-4, Fd.normalize(), Ud.crossVectors(n, Fd)), Ud.normalize(), kd.crossVectors(Fd, Ud), i[0] = Ud.x, i[4] = kd.x, i[8] = Fd.x, i[1] = Ud.y, i[5] = kd.y, i[9] = Fd.y, i[2] = Ud.z, i[6] = kd.z, i[10] = Fd.z, this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    s = n[0],
                    o = n[4],
                    a = n[8],
                    l = n[12],
                    c = n[1],
                    u = n[5],
                    h = n[9],
                    d = n[13],
                    f = n[2],
                    p = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    _ = n[7],
                    y = n[11],
                    x = n[15],
                    b = i[0],
                    S = i[4],
                    E = i[8],
                    M = i[12],
                    w = i[1],
                    T = i[5],
                    A = i[9],
                    P = i[13],
                    C = i[2],
                    R = i[6],
                    L = i[10],
                    O = i[14],
                    I = i[3],
                    D = i[7],
                    N = i[11],
                    U = i[15];
                return r[0] = s * b + o * w + a * C + l * I, r[4] = s * S + o * T + a * R + l * D, r[8] = s * E + o * A + a * L + l * N, r[12] = s * M + o * P + a * O + l * U, r[1] = c * b + u * w + h * C + d * I, r[5] = c * S + u * T + h * R + d * D, r[9] = c * E + u * A + h * L + d * N, r[13] = c * M + u * P + h * O + d * U, r[2] = f * b + p * w + m * C + g * I, r[6] = f * S + p * T + m * R + g * D, r[10] = f * E + p * A + m * L + g * N, r[14] = f * M + p * P + m * O + g * U, r[3] = v * b + _ * w + y * C + x * I, r[7] = v * S + _ * T + y * R + x * D, r[11] = v * E + _ * A + y * L + x * N, r[15] = v * M + _ * P + y * O + x * U, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[4],
                    i = t[8],
                    r = t[12],
                    s = t[1],
                    o = t[5],
                    a = t[9],
                    l = t[13],
                    c = t[2],
                    u = t[6],
                    h = t[10],
                    d = t[14];
                return t[3] * (+r * a * u - i * l * u - r * o * h + n * l * h + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * h + r * s * h - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * u - e * o * d - r * s * u + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * u + e * o * h + i * s * u - n * s * h + n * a * c)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    l = t[7],
                    c = t[8],
                    u = t[9],
                    h = t[10],
                    d = t[11],
                    f = t[12],
                    p = t[13],
                    m = t[14],
                    g = t[15],
                    v = u * m * l - p * h * l + p * a * d - o * m * d - u * a * g + o * h * g,
                    _ = f * h * l - c * m * l - f * a * d + s * m * d + c * a * g - s * h * g,
                    y = c * p * l - f * u * l + f * o * d - s * p * d - c * o * g + s * u * g,
                    x = f * u * a - c * p * a - f * o * h + s * p * h + c * o * m - s * u * m,
                    b = e * v + n * _ + i * y + r * x;
                if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const S = 1 / b;
                return t[0] = v * S, t[1] = (p * h * r - u * m * r - p * i * d + n * m * d + u * i * g - n * h * g) * S, t[2] = (o * m * r - p * a * r + p * i * l - n * m * l - o * i * g + n * a * g) * S, t[3] = (u * a * r - o * h * r - u * i * l + n * h * l + o * i * d - n * a * d) * S, t[4] = _ * S, t[5] = (c * m * r - f * h * r + f * i * d - e * m * d - c * i * g + e * h * g) * S, t[6] = (f * a * r - s * m * r - f * i * l + e * m * l + s * i * g - e * a * g) * S, t[7] = (s * h * r - c * a * r + c * i * l - e * h * l - s * i * d + e * a * d) * S, t[8] = y * S, t[9] = (f * u * r - c * p * r - f * n * d + e * p * d + c * n * g - e * u * g) * S, t[10] = (s * p * r - f * o * r + f * n * l - e * p * l - s * n * g + e * o * g) * S, t[11] = (c * o * r - s * u * r - c * n * l + e * u * l + s * n * d - e * o * d) * S, t[12] = x * S, t[13] = (c * p * i - f * u * i + f * n * h - e * p * h - c * n * m + e * u * m) * S, t[14] = (f * o * i - s * p * i - f * n * a + e * p * a + s * n * m - e * o * m) * S, t[15] = (s * u * i - c * o * i + c * n * a - e * u * a - s * n * h + e * o * h) * S, this
            }
            scale(t) {
                const e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z;
                return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
            }
            getMaxScaleOnAxis() {
                const t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            }
            makeRotationY(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e),
                    i = Math.sin(e),
                    r = 1 - n,
                    s = t.x,
                    o = t.y,
                    a = t.z,
                    l = r * s,
                    c = r * o;
                return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(t, e, n, i, r, s) {
                return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this
            }
            compose(t, e, n) {
                const i = this.elements,
                    r = e._x,
                    s = e._y,
                    o = e._z,
                    a = e._w,
                    l = r + r,
                    c = s + s,
                    u = o + o,
                    h = r * l,
                    d = r * c,
                    f = r * u,
                    p = s * c,
                    m = s * u,
                    g = o * u,
                    v = a * l,
                    _ = a * c,
                    y = a * u,
                    x = n.x,
                    b = n.y,
                    S = n.z;
                return i[0] = (1 - (p + g)) * x, i[1] = (d + y) * x, i[2] = (f - _) * x, i[3] = 0, i[4] = (d - y) * b, i[5] = (1 - (h + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (f + _) * S, i[9] = (m - v) * S, i[10] = (1 - (h + p)) * S, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = Od.set(i[0], i[1], i[2]).length();
                const s = Od.set(i[4], i[5], i[6]).length(),
                    o = Od.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Id.copy(this);
                const a = 1 / r,
                    l = 1 / s,
                    c = 1 / o;
                return Id.elements[0] *= a, Id.elements[1] *= a, Id.elements[2] *= a, Id.elements[4] *= l, Id.elements[5] *= l, Id.elements[6] *= l, Id.elements[8] *= c, Id.elements[9] *= c, Id.elements[10] *= c, e.setFromRotationMatrix(Id), n.x = r, n.y = s, n.z = o, this
            }
            makePerspective(t, e, n, i, r, s, o = 2e3) {
                const a = this.elements,
                    l = 2 * r / (e - t),
                    c = 2 * r / (n - i),
                    u = (e + t) / (e - t),
                    h = (n + i) / (n - i);
                let d, f;
                if (o === hh) d = -(s + r) / (s - r), f = -2 * s * r / (s - r);
                else {
                    if (o !== dh) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
                    d = -s / (s - r), f = -s * r / (s - r)
                }
                return a[0] = l, a[4] = 0, a[8] = u, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            }
            makeOrthographic(t, e, n, i, r, s, o = 2e3) {
                const a = this.elements,
                    l = 1 / (e - t),
                    c = 1 / (n - i),
                    u = 1 / (s - r),
                    h = (e + t) * l,
                    d = (n + i) * c;
                let f, p;
                if (o === hh) f = (s + r) * u, p = -2 * u;
                else {
                    if (o !== dh) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
                    f = r * u, p = -1 * u
                }
                return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = p, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }
        const Od = new ed,
            Id = new Ld,
            Dd = new ed(0, 0, 0),
            Nd = new ed(1, 1, 1),
            Ud = new ed,
            kd = new ed,
            Fd = new ed,
            zd = new Ld,
            Bd = new td;
        class Hd {
            constructor(t = 0, e = 0, n = 0, i = Hd.DEFAULT_ORDER) {
                this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t, this._onChangeCallback()
            }
            set(t, e, n, i = this._order) {
                return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(t, e = this._order, n = !0) {
                const i = t.elements,
                    r = i[0],
                    s = i[4],
                    o = i[8],
                    a = i[1],
                    l = i[5],
                    c = i[9],
                    u = i[2],
                    h = i[6],
                    d = i[10];
                switch (e) {
                    case "XYZ":
                        this._y = Math.asin(yh(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-yh(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(yh(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-yh(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(yh(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(o, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-yh(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, d), this._y = 0)
                }
                return this._order = e, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(t, e, n) {
                return zd.makeRotationFromQuaternion(t), this.setFromRotationMatrix(zd, e, n)
            }
            setFromVector3(t, e = this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return Bd.setFromEuler(this), this.setFromQuaternion(Bd, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order
            }
        }
        Hd.DEFAULT_ORDER = "XYZ";
        class Vd {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = (1 << t | 0) >>> 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
            isEnabled(t) {
                return 0 != (this.mask & (1 << t | 0))
            }
        }
        let Gd = 0;
        const Wd = new ed,
            jd = new td,
            Xd = new Ld,
            qd = new ed,
            Yd = new ed,
            Kd = new ed,
            Zd = new td,
            Jd = new ed(1, 0, 0),
            $d = new ed(0, 1, 0),
            Qd = new ed(0, 0, 1),
            tf = {
                type: "added"
            },
            ef = {
                type: "removed"
            };
        class nf extends fh {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                    value: Gd++
                }), this.uuid = _h(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = nf.DEFAULT_UP.clone();
                const t = new ed,
                    e = new Hd,
                    n = new td,
                    i = new ed(1, 1, 1);
                e._onChange((function () {
                    n.setFromEuler(e, !1)
                })), n._onChange((function () {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Ld
                    },
                    normalMatrix: {
                        value: new Ph
                    }
                }), this.matrix = new Ld, this.matrixWorld = new Ld, this.matrixAutoUpdate = nf.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = nf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Vd, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t), this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return jd.setFromAxisAngle(t, e), this.quaternion.multiply(jd), this
            }
            rotateOnWorldAxis(t, e) {
                return jd.setFromAxisAngle(t, e), this.quaternion.premultiply(jd), this
            }
            rotateX(t) {
                return this.rotateOnAxis(Jd, t)
            }
            rotateY(t) {
                return this.rotateOnAxis($d, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(Qd, t)
            }
            translateOnAxis(t, e) {
                return Wd.copy(t).applyQuaternion(this.quaternion), this.position.add(Wd.multiplyScalar(e)), this
            }
            translateX(t) {
                return this.translateOnAxis(Jd, t)
            }
            translateY(t) {
                return this.translateOnAxis($d, t)
            }
            translateZ(t) {
                return this.translateOnAxis(Qd, t)
            }
            localToWorld(t) {
                return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return this.updateWorldMatrix(!0, !1), t.applyMatrix4(Xd.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? qd.copy(t) : qd.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), Yd.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Xd.lookAt(Yd, qd, this.up) : Xd.lookAt(qd, Yd, this.up), this.quaternion.setFromRotationMatrix(Xd), i && (Xd.extractRotation(i.matrixWorld), jd.setFromRotationMatrix(Xd), this.quaternion.premultiply(jd.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return t === this || t && t.isObject3D && (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(tf)), this
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(ef)), this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this), this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1), Xd.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Xd.multiply(t.parent.matrixWorld)), t.applyMatrix4(Xd), this.add(t), t.updateWorldMatrix(!1, !0), this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e) return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== i) return i
                }
            }
            getObjectsByProperty(t, e, n = []) {
                this[t] === e && n.push(this);
                const i = this.children;
                for (let r = 0, s = i.length; r < s; r++) i[r].getObjectsByProperty(t, e, n);
                return n
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Yd, t, Kd), t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Yd, Zd, t), t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible) return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    !0 !== i.matrixWorldAutoUpdate && !0 !== t || i.updateMatrixWorld(t)
                }
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t,
                    n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};

                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                }
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((t => ({
                        boxInitialized: t.boxInitialized,
                        boxMin: t.box.min.toArray(),
                        boxMax: t.box.max.toArray(),
                        sphereInitialized: t.sphereInitialized,
                        sphereRadius: t.sphere.radius,
                        sphereCenter: t.sphere.center.toArray()
                    }))), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(t), null !== this.boundingSphere && (i.boundingSphere = {
                        center: i.boundingSphere.center.toArray(),
                        radius: i.boundingSphere.radius
                    }), null !== this.boundingBox && (i.boundingBox = {
                        min: i.boundingBox.min.toArray(),
                        max: i.boundingBox.max.toArray()
                    })), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                r(t.shapes, i)
                            } else r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                        i.material = e
                    } else i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = s(t.geometries),
                        i = s(t.materials),
                        r = s(t.textures),
                        o = s(t.images),
                        a = s(t.shapes),
                        l = s(t.skeletons),
                        c = s(t.animations),
                        u = s(t.nodes);
                    e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u)
                }
                return n.object = i, n;

                function s(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e = !0) {
                if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        nf.DEFAULT_UP = new ed(0, 1, 0), nf.DEFAULT_MATRIX_AUTO_UPDATE = !0, nf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const rf = new ed,
            sf = new ed,
            of = new ed,
            af = new ed,
            lf = new ed,
            cf = new ed,
            uf = new ed,
            hf = new ed,
            df = new ed,
            ff = new ed;
        let pf = !1;
        class mf {
            constructor(t = new ed, e = new ed, n = new ed) {
                this.a = t, this.b = e, this.c = n
            }
            static getNormal(t, e, n, i) {
                i.subVectors(n, e), rf.subVectors(t, e), i.cross(rf);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                rf.subVectors(i, e), sf.subVectors(n, e), of .subVectors(t, e);
                const s = rf.dot(rf),
                    o = rf.dot(sf),
                    a = rf.dot( of ),
                    l = sf.dot(sf),
                    c = sf.dot( of ),
                    u = s * l - o * o;
                if (0 === u) return r.set(0, 0, 0), null;
                const h = 1 / u,
                    d = (l * a - o * c) * h,
                    f = (s * c - o * a) * h;
                return r.set(1 - d - f, f, d)
            }
            static containsPoint(t, e, n, i) {
                return null !== this.getBarycoord(t, e, n, i, af) && (af.x >= 0 && af.y >= 0 && af.x + af.y <= 1)
            }
            static getUV(t, e, n, i, r, s, o, a) {
                return !1 === pf && (pf = !0), this.getInterpolation(t, e, n, i, r, s, o, a)
            }
            static getInterpolation(t, e, n, i, r, s, o, a) {
                return null === this.getBarycoord(t, e, n, i, af) ? (a.x = 0, a.y = 0, "z" in a && (a.z = 0), "w" in a && (a.w = 0), null) : (a.setScalar(0), a.addScaledVector(r, af.x), a.addScaledVector(s, af.y), a.addScaledVector(o, af.z), a)
            }
            static isFrontFacing(t, e, n, i) {
                return rf.subVectors(n, e), sf.subVectors(t, e), rf.cross(sf).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            }
            setFromAttributeAndIndices(t, e, n, i) {
                return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }
            getArea() {
                return rf.subVectors(this.c, this.b), sf.subVectors(this.a, this.b), .5 * rf.cross(sf).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return mf.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return mf.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, i, r) {
                return !1 === pf && (pf = !0), mf.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            }
            getInterpolation(t, e, n, i, r) {
                return mf.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return mf.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return mf.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a,
                    i = this.b,
                    r = this.c;
                let s, o;
                lf.subVectors(i, n), cf.subVectors(r, n), hf.subVectors(t, n);
                const a = lf.dot(hf),
                    l = cf.dot(hf);
                if (a <= 0 && l <= 0) return e.copy(n);
                df.subVectors(t, i);
                const c = lf.dot(df),
                    u = cf.dot(df);
                if (c >= 0 && u <= c) return e.copy(i);
                const h = a * u - c * l;
                if (h <= 0 && a >= 0 && c <= 0) return s = a / (a - c), e.copy(n).addScaledVector(lf, s);
                ff.subVectors(t, r);
                const d = lf.dot(ff),
                    f = cf.dot(ff);
                if (f >= 0 && d <= f) return e.copy(r);
                const p = d * l - a * f;
                if (p <= 0 && l >= 0 && f <= 0) return o = l / (l - f), e.copy(n).addScaledVector(cf, o);
                const m = c * f - d * u;
                if (m <= 0 && u - c >= 0 && d - f >= 0) return uf.subVectors(r, i), o = (u - c) / (u - c + (d - f)), e.copy(i).addScaledVector(uf, o);
                const g = 1 / (m + p + h);
                return s = p * g, o = h * g, e.copy(n).addScaledVector(lf, s).addScaledVector(cf, o)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        const gf = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            vf = {
                h: 0,
                s: 0,
                l: 0
            },
            _f = {
                h: 0,
                s: 0,
                l: 0
            };

        function yf(t, e, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        class xf {
            constructor(t, e, n) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n)
            }
            set(t, e, n) {
                if (void 0 === e && void 0 === n) {
                    const e = t;
                    e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
                } else this.setRGB(t, e, n);
                return this
            }
            setScalar(t) {
                return this.r = t, this.g = t, this.b = t, this
            }
            setHex(t, e = Qu) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, zh.toWorkingColorSpace(this, e), this
            }
            setRGB(t, e, n, i = zh.workingColorSpace) {
                return this.r = t, this.g = e, this.b = n, zh.toWorkingColorSpace(this, i), this
            }
            setHSL(t, e, n, i = zh.workingColorSpace) {
                if (t = xh(t, 1), e = yh(e, 0, 1), n = yh(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                        r = 2 * n - i;
                    this.r = yf(r, i, t + 1 / 3), this.g = yf(r, i, t), this.b = yf(r, i, t - 1 / 3)
                }
                return zh.toWorkingColorSpace(this, i), this
            }
            setStyle(t, e = Qu) {
                function n(t) {
                    void 0 !== t && parseFloat(t)
                }
                let i;
                if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const r = i[1],
                        s = i[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(t[4]), this.setRGB(Math.min(255, parseInt(t[1], 10)) / 255, Math.min(255, parseInt(t[2], 10)) / 255, Math.min(255, parseInt(t[3], 10)) / 255, e);
                            if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(t[4]), this.setRGB(Math.min(100, parseInt(t[1], 10)) / 100, Math.min(100, parseInt(t[2], 10)) / 100, Math.min(100, parseInt(t[3], 10)) / 100, e);
                            break;
                        case "hsl":
                        case "hsla":
                            if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(t[4]), this.setHSL(parseFloat(t[1]) / 360, parseFloat(t[2]) / 100, parseFloat(t[3]) / 100, e)
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = i[1],
                        n = t.length;
                    if (3 === n) return this.setRGB(parseInt(t.charAt(0), 16) / 15, parseInt(t.charAt(1), 16) / 15, parseInt(t.charAt(2), 16) / 15, e);
                    if (6 === n) return this.setHex(parseInt(t, 16), e)
                } else if (t && t.length > 0) return this.setColorName(t, e);
                return this
            }
            setColorName(t, e = Qu) {
                const n = gf[t.toLowerCase()];
                return void 0 !== n && this.setHex(n, e), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }
            copySRGBToLinear(t) {
                return this.r = Bh(t.r), this.g = Bh(t.g), this.b = Bh(t.b), this
            }
            copyLinearToSRGB(t) {
                return this.r = Hh(t.r), this.g = Hh(t.g), this.b = Hh(t.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex(t = Qu) {
                return zh.fromWorkingColorSpace(bf.copy(this), t), 65536 * Math.round(yh(255 * bf.r, 0, 255)) + 256 * Math.round(yh(255 * bf.g, 0, 255)) + Math.round(yh(255 * bf.b, 0, 255))
            }
            getHexString(t = Qu) {
                return ("000000" + this.getHex(t).toString(16)).slice(-6)
            }
            getHSL(t, e = zh.workingColorSpace) {
                zh.fromWorkingColorSpace(bf.copy(this), e);
                const n = bf.r,
                    i = bf.g,
                    r = bf.b,
                    s = Math.max(n, i, r),
                    o = Math.min(n, i, r);
                let a, l;
                const c = (o + s) / 2;
                if (o === s) a = 0, l = 0;
                else {
                    const t = s - o;
                    switch (l = c <= .5 ? t / (s + o) : t / (2 - s - o), s) {
                        case n:
                            a = (i - r) / t + (i < r ? 6 : 0);
                            break;
                        case i:
                            a = (r - n) / t + 2;
                            break;
                        case r:
                            a = (n - i) / t + 4
                    }
                    a /= 6
                }
                return t.h = a, t.s = l, t.l = c, t
            }
            getRGB(t, e = zh.workingColorSpace) {
                return zh.fromWorkingColorSpace(bf.copy(this), e), t.r = bf.r, t.g = bf.g, t.b = bf.b, t
            }
            getStyle(t = Qu) {
                zh.fromWorkingColorSpace(bf.copy(this), t);
                const e = bf.r,
                    n = bf.g,
                    i = bf.b;
                return t !== Qu ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*i)})`
            }
            offsetHSL(t, e, n) {
                return this.getHSL(vf), this.setHSL(vf.h + t, vf.s + e, vf.l + n)
            }
            add(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }
            addColors(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }
            addScalar(t) {
                return this.r += t, this.g += t, this.b += t, this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }
            multiply(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }
            multiplyScalar(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
            }
            lerpHSL(t, e) {
                this.getHSL(vf), t.getHSL(_f);
                const n = bh(vf.h, _f.h, e),
                    i = bh(vf.s, _f.s, e),
                    r = bh(vf.l, _f.l, e);
                return this.setHSL(n, i, r), this
            }
            setFromVector3(t) {
                return this.r = t.x, this.g = t.y, this.b = t.z, this
            }
            applyMatrix3(t) {
                const e = this.r,
                    n = this.g,
                    i = this.b,
                    r = t.elements;
                return this.r = r[0] * e + r[3] * n + r[6] * i, this.g = r[1] * e + r[4] * n + r[7] * i, this.b = r[2] * e + r[5] * n + r[8] * i, this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e = 0) {
                return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
            }
            toJSON() {
                return this.getHex()
            }*[Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b
            }
        }
        const bf = new xf;
        xf.NAMES = gf;
        let Sf = 0;
        class Ef extends fh {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                    value: Sf++
                }), this.uuid = _h(), this.name = "", this.type = "Material", this.blending = 1, this.side = nu, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = ru, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new xf(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ah, this.stencilZFail = ah, this.stencilZPass = ah, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) continue;
                        const i = this[e];
                        void 0 !== i && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n)
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), this.side !== nu && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), 204 !== this.blendSrc && (n.blendSrc = this.blendSrc), 205 !== this.blendDst && (n.blendDst = this.blendDst), this.blendEquation !== ru && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== ah && (n.stencilFail = this.stencilFail), this.stencilZFail !== ah && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== ah && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) {
                    const e = i(t.textures),
                        r = i(t.images);
                    e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        class Mf extends Ef {
            constructor(t) {
                super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new xf(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = su, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
            }
        }
        const wf = Tf();

        function Tf() {
            const t = new ArrayBuffer(4),
                e = new Float32Array(t),
                n = new Uint32Array(t),
                i = new Uint32Array(512),
                r = new Uint32Array(512);
            for (let t = 0; t < 256; ++t) {
                const e = t - 127;
                e < -27 ? (i[t] = 0, i[256 | t] = 32768, r[t] = 24, r[256 | t] = 24) : e < -14 ? (i[t] = 1024 >> -e - 14, i[256 | t] = 1024 >> -e - 14 | 32768, r[t] = -e - 1, r[256 | t] = -e - 1) : e <= 15 ? (i[t] = e + 15 << 10, i[256 | t] = e + 15 << 10 | 32768, r[t] = 13, r[256 | t] = 13) : e < 128 ? (i[t] = 31744, i[256 | t] = 64512, r[t] = 24, r[256 | t] = 24) : (i[t] = 31744, i[256 | t] = 64512, r[t] = 13, r[256 | t] = 13)
            }
            const s = new Uint32Array(2048),
                o = new Uint32Array(64),
                a = new Uint32Array(64);
            for (let t = 1; t < 1024; ++t) {
                let e = t << 13,
                    n = 0;
                for (; 0 == (8388608 & e);) e <<= 1, n -= 8388608;
                e &= -8388609, n += 947912704, s[t] = e | n
            }
            for (let t = 1024; t < 2048; ++t) s[t] = 939524096 + (t - 1024 << 13);
            for (let t = 1; t < 31; ++t) o[t] = t << 23;
            o[31] = 1199570944, o[32] = 2147483648;
            for (let t = 33; t < 63; ++t) o[t] = 2147483648 + (t - 32 << 23);
            o[63] = 3347054592;
            for (let t = 1; t < 64; ++t) 32 !== t && (a[t] = 1024);
            return {
                floatView: e,
                uint32View: n,
                baseTable: i,
                shiftTable: r,
                mantissaTable: s,
                exponentTable: o,
                offsetTable: a
            }
        }

        function Af(t) {
            Math.abs(t), t = yh(t, -65504, 65504), wf.floatView[0] = t;
            const e = wf.uint32View[0],
                n = e >> 23 & 511;
            return wf.baseTable[n] + ((8388607 & e) >> wf.shiftTable[n])
        }

        function Pf(t) {
            const e = t >> 10;
            return wf.uint32View[0] = wf.mantissaTable[wf.offsetTable[e] + (1023 & t)] + wf.exponentTable[e], wf.floatView[0]
        }
        const Cf = {
                toHalfFloat: Af,
                fromHalfFloat: Pf
            },
            Rf = new ed,
            Lf = new Ah;
        class Of {
            constructor(t, e, n = !1) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n, this.usage = lh, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.gpuType = Du, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            get updateRange() {
                return this._updateRange
            }
            setUsage(t) {
                return this.usage = t, this
            }
            addUpdateRange(t, e) {
                this.updateRanges.push({
                    start: t,
                    count: e
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
            }
            copyAt(t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }
            copyArray(t) {
                return this.array.set(t), this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) Lf.fromBufferAttribute(this, e), Lf.applyMatrix3(t), this.setXY(e, Lf.x, Lf.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) Rf.fromBufferAttribute(this, e), Rf.applyMatrix3(t), this.setXYZ(e, Rf.x, Rf.y, Rf.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++) Rf.fromBufferAttribute(this, e), Rf.applyMatrix4(t), this.setXYZ(e, Rf.x, Rf.y, Rf.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) Rf.fromBufferAttribute(this, e), Rf.applyNormalMatrix(t), this.setXYZ(e, Rf.x, Rf.y, Rf.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) Rf.fromBufferAttribute(this, e), Rf.transformDirection(t), this.setXYZ(e, Rf.x, Rf.y, Rf.z);
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            getComponent(t, e) {
                let n = this.array[t * this.itemSize + e];
                return this.normalized && (n = Mh(n, this.array)), n
            }
            setComponent(t, e, n) {
                return this.normalized && (n = wh(n, this.array)), this.array[t * this.itemSize + e] = n, this
            }
            getX(t) {
                let e = this.array[t * this.itemSize];
                return this.normalized && (e = Mh(e, this.array)), e
            }
            setX(t, e) {
                return this.normalized && (e = wh(e, this.array)), this.array[t * this.itemSize] = e, this
            }
            getY(t) {
                let e = this.array[t * this.itemSize + 1];
                return this.normalized && (e = Mh(e, this.array)), e
            }
            setY(t, e) {
                return this.normalized && (e = wh(e, this.array)), this.array[t * this.itemSize + 1] = e, this
            }
            getZ(t) {
                let e = this.array[t * this.itemSize + 2];
                return this.normalized && (e = Mh(e, this.array)), e
            }
            setZ(t, e) {
                return this.normalized && (e = wh(e, this.array)), this.array[t * this.itemSize + 2] = e, this
            }
            getW(t) {
                let e = this.array[t * this.itemSize + 3];
                return this.normalized && (e = Mh(e, this.array)), e
            }
            setW(t, e) {
                return this.normalized && (e = wh(e, this.array)), this.array[t * this.itemSize + 3] = e, this
            }
            setXY(t, e, n) {
                return t *= this.itemSize, this.normalized && (e = wh(e, this.array), n = wh(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
            }
            setXYZ(t, e, n, i) {
                return t *= this.itemSize, this.normalized && (e = wh(e, this.array), n = wh(n, this.array), i = wh(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
            }
            setXYZW(t, e, n, i, r) {
                return t *= this.itemSize, this.normalized && (e = wh(e, this.array), n = wh(n, this.array), i = wh(i, this.array), r = wh(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name), this.usage !== lh && (t.usage = this.usage), t
            }
        }
        class If extends Of {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class Df extends Of {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        class Nf extends Of {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        let Uf = 0;
        const kf = new Ld,
            Ff = new nf,
            zf = new ed,
            Bf = new rd,
            Hf = new rd,
            Vf = new ed;
        class Gf extends fh {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                    value: Uf++
                }), this.uuid = _h(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new(Rh(t) ? Df : If)(t, 1) : this.index = t, this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e, this
            }
            deleteAttribute(t) {
                return delete this.attributes[t], this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n = 0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new Ph).getNormalMatrix(t);
                    n.applyNormalMatrix(e), n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(t) {
                return kf.makeRotationFromQuaternion(t), this.applyMatrix4(kf), this
            }
            rotateX(t) {
                return kf.makeRotationX(t), this.applyMatrix4(kf), this
            }
            rotateY(t) {
                return kf.makeRotationY(t), this.applyMatrix4(kf), this
            }
            rotateZ(t) {
                return kf.makeRotationZ(t), this.applyMatrix4(kf), this
            }
            translate(t, e, n) {
                return kf.makeTranslation(t, e, n), this.applyMatrix4(kf), this
            }
            scale(t, e, n) {
                return kf.makeScale(t, e, n), this.applyMatrix4(kf), this
            }
            lookAt(t) {
                return Ff.lookAt(t), Ff.updateMatrix(), this.applyMatrix4(Ff.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(zf).negate(), this.translate(zf.x, zf.y, zf.z), this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new Nf(e, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new rd);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) this.boundingBox.set(new ed(-1 / 0, -1 / 0, -1 / 0), new ed(1 / 0, 1 / 0, 1 / 0));
                else {
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                Bf.setFromBufferAttribute(n), this.morphTargetsRelative ? (Vf.addVectors(this.boundingBox.min, Bf.min), this.boundingBox.expandByPoint(Vf), Vf.addVectors(this.boundingBox.max, Bf.max), this.boundingBox.expandByPoint(Vf)) : (this.boundingBox.expandByPoint(Bf.min), this.boundingBox.expandByPoint(Bf.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
                }
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Sd);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) this.boundingSphere.set(new ed, 1 / 0);
                else if (t) {
                    const n = this.boundingSphere.center;
                    if (Bf.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Hf.setFromBufferAttribute(n), this.morphTargetsRelative ? (Vf.addVectors(Bf.min, Hf.min), Bf.expandByPoint(Vf), Vf.addVectors(Bf.max, Hf.max), Bf.expandByPoint(Vf)) : (Bf.expandByPoint(Hf.min), Bf.expandByPoint(Hf.max))
                        }
                    Bf.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++) Vf.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Vf));
                    if (e)
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r],
                                o = this.morphTargetsRelative;
                            for (let e = 0, r = s.count; e < r; e++) Vf.fromBufferAttribute(s, e), o && (zf.fromBufferAttribute(t, e), Vf.add(zf)), i = Math.max(i, n.distanceToSquared(Vf))
                        }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius)
                }
            }
            computeTangents() {
                const t = this.index,
                    e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return;
                const n = t.array,
                    i = e.position.array,
                    r = e.normal.array,
                    s = e.uv.array,
                    o = i.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Of(new Float32Array(4 * o), 4));
                const a = this.getAttribute("tangent").array,
                    l = [],
                    c = [];
                for (let t = 0; t < o; t++) l[t] = new ed, c[t] = new ed;
                const u = new ed,
                    h = new ed,
                    d = new ed,
                    f = new Ah,
                    p = new Ah,
                    m = new Ah,
                    g = new ed,
                    v = new ed;

                function _(t, e, n) {
                    u.fromArray(i, 3 * t), h.fromArray(i, 3 * e), d.fromArray(i, 3 * n), f.fromArray(s, 2 * t), p.fromArray(s, 2 * e), m.fromArray(s, 2 * n), h.sub(u), d.sub(u), p.sub(f), m.sub(f);
                    const r = 1 / (p.x * m.y - m.x * p.y);
                    isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -p.y).multiplyScalar(r), v.copy(d).multiplyScalar(p.x).addScaledVector(h, -m.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                }
                let y = this.groups;
                0 === y.length && (y = [{
                    start: 0,
                    count: n.length
                }]);
                for (let t = 0, e = y.length; t < e; ++t) {
                    const e = y[t],
                        i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) _(n[t + 0], n[t + 1], n[t + 2])
                }
                const x = new ed,
                    b = new ed,
                    S = new ed,
                    E = new ed;

                function M(t) {
                    S.fromArray(r, 3 * t), E.copy(S);
                    const e = l[t];
                    x.copy(e), x.sub(S.multiplyScalar(S.dot(e))).normalize(), b.crossVectors(E, e);
                    const n = b.dot(c[t]) < 0 ? -1 : 1;
                    a[4 * t] = x.x, a[4 * t + 1] = x.y, a[4 * t + 2] = x.z, a[4 * t + 3] = n
                }
                for (let t = 0, e = y.length; t < e; ++t) {
                    const e = y[t],
                        i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) M(n[t + 0]), M(n[t + 1]), M(n[t + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index,
                    e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Of(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                    const i = new ed,
                        r = new ed,
                        s = new ed,
                        o = new ed,
                        a = new ed,
                        l = new ed,
                        c = new ed,
                        u = new ed;
                    if (t)
                        for (let h = 0, d = t.count; h < d; h += 3) {
                            const d = t.getX(h + 0),
                                f = t.getX(h + 1),
                                p = t.getX(h + 2);
                            i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, f), s.fromBufferAttribute(e, p), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, f), l.fromBufferAttribute(n, p), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(f, a.x, a.y, a.z), n.setXYZ(p, l.x, l.y, l.z)
                        } else
                            for (let t = 0, o = e.count; t < o; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++) Vf.fromBufferAttribute(t, e), Vf.normalize(), t.setXYZ(e, Vf.x, Vf.y, Vf.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array,
                        i = t.itemSize,
                        r = t.normalized,
                        s = new n.constructor(e.length * i);
                    let o = 0,
                        a = 0;
                    for (let r = 0, l = e.length; r < l; r++) {
                        o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                        for (let t = 0; t < i; t++) s[a++] = n[o++]
                    }
                    return new Of(s, i, r)
                }
                if (null === this.index) return this;
                const e = new Gf,
                    n = this.index.array,
                    i = this.attributes;
                for (const r in i) {
                    const s = t(i[r], n);
                    e.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const s = [],
                        o = r[i];
                    for (let e = 0, i = o.length; e < i; e++) {
                        const i = t(o[e], n);
                        s.push(i)
                    }
                    e.morphAttributes[i] = s
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const i = n[e];
                    t.data.attributes[e] = i.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e],
                        s = [];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        s.push(i.toJSON(t.data))
                    }
                    s.length > 0 && (i[e] = s, r = !0)
                }
                r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                const o = this.boundingSphere;
                return null !== o && (t.data.boundingSphere = {
                    center: o.center.toArray(),
                    radius: o.radius
                }), t
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const t in i) {
                    const n = i[t];
                    this.setAttribute(t, n.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const n = [],
                        i = r[t];
                    for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const s = t.groups;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const o = t.boundingBox;
                null !== o && (this.boundingBox = o.clone());
                const a = t.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Wf = new Ld,
            jf = new Rd,
            Xf = new Sd,
            qf = new ed,
            Yf = new ed,
            Kf = new ed,
            Zf = new ed,
            Jf = new ed,
            $f = new ed,
            Qf = new Ah,
            tp = new Ah,
            ep = new Ah,
            np = new ed,
            ip = new ed,
            rp = new ed,
            sp = new ed,
            op = new ed;
        class ap extends nf {
            constructor(t = new Gf, e = new Mf) {
                super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
            getVertexPosition(t, e) {
                const n = this.geometry,
                    i = n.attributes.position,
                    r = n.morphAttributes.position,
                    s = n.morphTargetsRelative;
                e.fromBufferAttribute(i, t);
                const o = this.morphTargetInfluences;
                if (r && o) {
                    $f.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = o[n],
                            a = r[n];
                        0 !== i && (Jf.fromBufferAttribute(a, t), s ? $f.addScaledVector(Jf, i) : $f.addScaledVector(Jf.sub(e), i))
                    }
                    e.add($f)
                }
                return e
            }
            raycast(t, e) {
                const n = this.geometry,
                    i = this.material,
                    r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Xf.copy(n.boundingSphere), Xf.applyMatrix4(r), jf.copy(t.ray).recast(t.near), !1 === Xf.containsPoint(jf.origin)) {
                        if (null === jf.intersectSphere(Xf, qf)) return;
                        if (jf.origin.distanceToSquared(qf) > (t.far - t.near) ** 2) return
                    }
                    Wf.copy(r).invert(), jf.copy(t.ray).applyMatrix4(Wf), null !== n.boundingBox && !1 === jf.intersectsBox(n.boundingBox) || this._computeIntersections(t, e, jf)
                }
            }
            _computeIntersections(t, e, n) {
                let i;
                const r = this.geometry,
                    s = this.material,
                    o = r.index,
                    a = r.attributes.position,
                    l = r.attributes.uv,
                    c = r.attributes.uv1,
                    u = r.attributes.normal,
                    h = r.groups,
                    d = r.drawRange;
                if (null !== o)
                    if (Array.isArray(s))
                        for (let r = 0, a = h.length; r < a; r++) {
                            const a = h[r],
                                f = s[a.materialIndex];
                            for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3) {
                                i = lp(this, f, t, n, l, c, u, o.getX(r), o.getX(r + 1), o.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = a.materialIndex, e.push(i))
                            }
                        } else {
                            for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3) {
                                i = lp(this, s, t, n, l, c, u, o.getX(r), o.getX(r + 1), o.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), e.push(i))
                            }
                        } else if (void 0 !== a)
                            if (Array.isArray(s))
                                for (let r = 0, o = h.length; r < o; r++) {
                                    const o = h[r],
                                        f = s[o.materialIndex];
                                    for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3) {
                                        i = lp(this, f, t, n, l, c, u, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = o.materialIndex, e.push(i))
                                    }
                                } else {
                                    for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3) {
                                        i = lp(this, s, t, n, l, c, u, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), e.push(i))
                                    }
                                }
            }
        }

        function lp(t, e, n, i, r, s, o, a, l, c) {
            t.getVertexPosition(a, Yf), t.getVertexPosition(l, Kf), t.getVertexPosition(c, Zf);
            const u = function (t, e, n, i, r, s, o, a) {
                let l;
                if (l = e.side === iu ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, e.side === nu, a), null === l) return null;
                op.copy(a), op.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(op);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: op.clone(),
                    object: t
                }
            }(t, e, n, i, Yf, Kf, Zf, sp);
            if (u) {
                r && (Qf.fromBufferAttribute(r, a), tp.fromBufferAttribute(r, l), ep.fromBufferAttribute(r, c), u.uv = mf.getInterpolation(sp, Yf, Kf, Zf, Qf, tp, ep, new Ah)), s && (Qf.fromBufferAttribute(s, a), tp.fromBufferAttribute(s, l), ep.fromBufferAttribute(s, c), u.uv1 = mf.getInterpolation(sp, Yf, Kf, Zf, Qf, tp, ep, new Ah), u.uv2 = u.uv1), o && (np.fromBufferAttribute(o, a), ip.fromBufferAttribute(o, l), rp.fromBufferAttribute(o, c), u.normal = mf.getInterpolation(sp, Yf, Kf, Zf, np, ip, rp, new ed), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
                const t = {
                    a,
                    b: l,
                    c,
                    normal: new ed,
                    materialIndex: 0
                };
                mf.getNormal(Yf, Kf, Zf, t.normal), u.face = t
            }
            return u
        }
        class cp extends Gf {
            constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const o = this;
                i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                const a = [],
                    l = [],
                    c = [],
                    u = [];
                let h = 0,
                    d = 0;

                function f(t, e, n, i, r, s, f, p, m, g, v) {
                    const _ = s / m,
                        y = f / g,
                        x = s / 2,
                        b = f / 2,
                        S = p / 2,
                        E = m + 1,
                        M = g + 1;
                    let w = 0,
                        T = 0;
                    const A = new ed;
                    for (let s = 0; s < M; s++) {
                        const o = s * y - b;
                        for (let a = 0; a < E; a++) {
                            const h = a * _ - x;
                            A[t] = h * i, A[e] = o * r, A[n] = S, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = p > 0 ? 1 : -1, c.push(A.x, A.y, A.z), u.push(a / m), u.push(1 - s / g), w += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const n = h + e + E * t,
                                i = h + e + E * (t + 1),
                                r = h + (e + 1) + E * (t + 1),
                                s = h + (e + 1) + E * t;
                            a.push(n, i, s), a.push(i, r, s), T += 6
                        }
                    o.addGroup(d, T, v), d += T, h += w
                }
                f("z", "y", "x", -1, -1, n, e, t, s, r, 0), f("z", "y", "x", 1, -1, n, e, -t, s, r, 1), f("x", "z", "y", 1, 1, t, n, e, i, s, 2), f("x", "z", "y", 1, -1, t, n, -e, i, s, 3), f("x", "y", "z", 1, -1, t, e, n, i, r, 4), f("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Nf(l, 3)), this.setAttribute("normal", new Nf(c, 3)), this.setAttribute("uv", new Nf(u, 2))
            }
            copy(t) {
                return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
            }
            static fromJSON(t) {
                return new cp(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
            }
        }

        function up(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? e[n][i] = null : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }

        function hp(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = up(t[n]);
                for (const t in i) e[t] = i[t]
            }
            return e
        }

        function dp(t) {
            return null === t.getRenderTarget() ? t.outputColorSpace : zh.workingColorSpace
        }
        const fp = {
            clone: up,
            merge: hp
        };
        class pp extends Ef {
            constructor(t) {
                super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1,
                    clipCullDistance: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = up(t.uniforms), this.uniformsGroups = function (t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                    return e
                }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
                const n = {};
                for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }
        }
        class mp extends nf {
            constructor() {
                super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ld, this.projectionMatrix = new Ld, this.projectionMatrixInverse = new Ld, this.coordinateSystem = hh
            }
            copy(t, e) {
                return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
            }
            getWorldDirection(t) {
                return super.getWorldDirection(t).negate()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class gp extends mp {
            constructor(t = 50, e = 1, n = .1, i = 2e3) {
                super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * vh * Math.atan(e), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * gh * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * vh * Math.atan(Math.tan(.5 * gh * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, i, r, s) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * gh * this.fov) / this.zoom,
                    n = 2 * e,
                    i = this.aspect * n,
                    r = -.5 * i;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = s.fullWidth,
                        o = s.fullHeight;
                    r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o
                }
                const o = this.filmOffset;
                0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }
        const vp = -90;
        class _p extends nf {
            constructor(t, e, n) {
                super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                const i = new gp(vp, 1, t, e);
                i.layers = this.layers, this.add(i);
                const r = new gp(vp, 1, t, e);
                r.layers = this.layers, this.add(r);
                const s = new gp(vp, 1, t, e);
                s.layers = this.layers, this.add(s);
                const o = new gp(vp, 1, t, e);
                o.layers = this.layers, this.add(o);
                const a = new gp(vp, 1, t, e);
                a.layers = this.layers, this.add(a);
                const l = new gp(vp, 1, t, e);
                l.layers = this.layers, this.add(l)
            }
            updateCoordinateSystem() {
                const t = this.coordinateSystem,
                    e = this.children.concat(),
                    [n, i, r, s, o, a] = e;
                for (const t of e) this.remove(t);
                if (t === hh) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), a.up.set(0, 1, 0), a.lookAt(0, 0, -1);
                else {
                    if (t !== dh) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                    n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), a.up.set(0, -1, 0), a.lookAt(0, 0, -1)
                }
                for (const t of e) this.add(t), t.updateMatrixWorld()
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const {
                    renderTarget: n,
                    activeMipmapLevel: i
                } = this;
                this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
                const [r, s, o, a, l, c] = this.children, u = t.getRenderTarget(), h = t.getActiveCubeFace(), d = t.getActiveMipmapLevel(), f = t.xr.enabled;
                t.xr.enabled = !1;
                const p = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0, i), t.render(e, r), t.setRenderTarget(n, 1, i), t.render(e, s), t.setRenderTarget(n, 2, i), t.render(e, o), t.setRenderTarget(n, 3, i), t.render(e, a), t.setRenderTarget(n, 4, i), t.render(e, l), n.texture.generateMipmaps = p, t.setRenderTarget(n, 5, i), t.render(e, c), t.setRenderTarget(u, h, d), t.xr.enabled = f, n.texture.needsPMREMUpdate = !0
            }
        }
        class yp extends Yh {
            constructor(t, e, n, i, r, s, o, a, l, c) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : gu, n, i, r, s, o, a, l, c), this.isCubeTexture = !0, this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        class xp extends Jh {
            constructor(t = 1, e = {}) {
                super(t, t, e), this.isWebGLCubeRenderTarget = !0;
                const n = {
                        width: t,
                        height: t,
                        depth: 1
                    },
                    i = [n, n, n, n, n, n];
                void 0 !== e.encoding && (Dh("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), e.colorSpace = e.encoding === Ju ? Qu : $u), this.texture = new yp(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Au
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                    },
                    i = new cp(5, 5, 5),
                    r = new pp({
                        name: "CubemapFromEquirect",
                        uniforms: up(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: iu,
                        blending: 0
                    });
                r.uniforms.tEquirect.value = e;
                const s = new ap(i, r),
                    o = e.minFilter;
                e.minFilter === Cu && (e.minFilter = Au);
                return new _p(1, 10, this).update(t, s), e.minFilter = o, s.geometry.dispose(), s.material.dispose(), this
            }
            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }
        const bp = new ed,
            Sp = new ed,
            Ep = new Ph;
        class Mp {
            constructor(t = new ed(1, 0, 0), e = 0) {
                this.isPlane = !0, this.normal = t, this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n), this.constant = i, this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = bp.subVectors(n, e).cross(Sp.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t), this
            }
            copy(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
            }
            intersectLine(t, e) {
                const n = t.delta(bp),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || Ep.getNormalMatrix(t),
                    i = this.coplanarPoint(bp).applyMatrix4(t),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal), this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const wp = new Sd,
            Tp = new ed;
        class Ap {
            constructor(t = new Mp, e = new Mp, n = new Mp, i = new Mp, r = new Mp, s = new Mp) {
                this.planes = [t, e, n, i, r, s]
            }
            set(t, e, n, i, r, s) {
                const o = this.planes;
                return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t, e = 2e3) {
                const n = this.planes,
                    i = t.elements,
                    r = i[0],
                    s = i[1],
                    o = i[2],
                    a = i[3],
                    l = i[4],
                    c = i[5],
                    u = i[6],
                    h = i[7],
                    d = i[8],
                    f = i[9],
                    p = i[10],
                    m = i[11],
                    g = i[12],
                    v = i[13],
                    _ = i[14],
                    y = i[15];
                if (n[0].setComponents(a - r, h - l, m - d, y - g).normalize(), n[1].setComponents(a + r, h + l, m + d, y + g).normalize(), n[2].setComponents(a + s, h + c, m + f, y + v).normalize(), n[3].setComponents(a - s, h - c, m - f, y - v).normalize(), n[4].setComponents(a - o, h - u, m - p, y - _).normalize(), e === hh) n[5].setComponents(a + o, h + u, m + p, y + _).normalize();
                else {
                    if (e !== dh) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                    n[5].setComponents(o, u, p, _).normalize()
                }
                return this
            }
            intersectsObject(t) {
                if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), wp.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                else {
                    const e = t.geometry;
                    null === e.boundingSphere && e.computeBoundingSphere(), wp.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                }
                return this.intersectsSphere(wp)
            }
            intersectsSprite(t) {
                return wp.center.set(0, 0, 0), wp.radius = .7071067811865476, wp.applyMatrix4(t.matrixWorld), this.intersectsSphere(wp)
            }
            intersectsSphere(t) {
                const e = this.planes,
                    n = t.center,
                    i = -t.radius;
                for (let t = 0; t < 6; t++) {
                    if (e[t].distanceToPoint(n) < i) return !1
                }
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (Tp.x = i.normal.x > 0 ? t.max.x : t.min.x, Tp.y = i.normal.y > 0 ? t.max.y : t.min.y, Tp.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Tp) < 0) return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function Pp() {
            let t = null,
                e = !1,
                n = null,
                i = null;

            function r(e, s) {
                n(e, s), i = t.requestAnimationFrame(r)
            }
            return {
                start: function () {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
                },
                stop: function () {
                    t.cancelAnimationFrame(i), e = !1
                },
                setAnimationLoop: function (t) {
                    n = t
                },
                setContext: function (e) {
                    t = e
                }
            }
        }

        function Cp(t, e) {
            const n = e.isWebGL2,
                i = new WeakMap;
            return {
                get: function (t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                },
                remove: function (e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = i.get(e);
                    n && (t.deleteBuffer(n.buffer), i.delete(e))
                },
                update: function (e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = i.get(e);
                        return void((!t || t.version < e.version) && i.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const s = i.get(e);
                    if (void 0 === s) i.set(e, function (e, i) {
                        const r = e.array,
                            s = e.usage,
                            o = r.byteLength,
                            a = t.createBuffer();
                        let l;
                        if (t.bindBuffer(i, a), t.bufferData(i, r, s), e.onUploadCallback(), r instanceof Float32Array) l = t.FLOAT;
                        else if (r instanceof Uint16Array)
                            if (e.isFloat16BufferAttribute) {
                                if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                l = t.HALF_FLOAT
                            } else l = t.UNSIGNED_SHORT;
                        else if (r instanceof Int16Array) l = t.SHORT;
                        else if (r instanceof Uint32Array) l = t.UNSIGNED_INT;
                        else if (r instanceof Int32Array) l = t.INT;
                        else if (r instanceof Int8Array) l = t.BYTE;
                        else if (r instanceof Uint8Array) l = t.UNSIGNED_BYTE;
                        else {
                            if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                            l = t.UNSIGNED_BYTE
                        }
                        return {
                            buffer: a,
                            type: l,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version,
                            size: o
                        }
                    }(e, r));
                    else if (s.version < e.version) {
                        if (s.size !== e.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        ! function (e, i, r) {
                            const s = i.array,
                                o = i._updateRange,
                                a = i.updateRanges;
                            if (t.bindBuffer(r, e), -1 === o.count && 0 === a.length && t.bufferSubData(r, 0, s), 0 !== a.length) {
                                for (let e = 0, i = a.length; e < i; e++) {
                                    const i = a[e];
                                    n ? t.bufferSubData(r, i.start * s.BYTES_PER_ELEMENT, s, i.start, i.count) : t.bufferSubData(r, i.start * s.BYTES_PER_ELEMENT, s.subarray(i.start, i.start + i.count))
                                }
                                i.clearUpdateRanges()
                            } - 1 !== o.count && (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1), i.onUploadCallback()
                        }(s.buffer, e, r), s.version = e.version
                    }
                }
            }
        }
        class Rp extends Gf {
            constructor(t = 1, e = 1, n = 1, i = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2,
                    s = e / 2,
                    o = Math.floor(n),
                    a = Math.floor(i),
                    l = o + 1,
                    c = a + 1,
                    u = t / o,
                    h = e / a,
                    d = [],
                    f = [],
                    p = [],
                    m = [];
                for (let t = 0; t < c; t++) {
                    const e = t * h - s;
                    for (let n = 0; n < l; n++) {
                        const i = n * u - r;
                        f.push(i, -e, 0), p.push(0, 0, 1), m.push(n / o), m.push(1 - t / a)
                    }
                }
                for (let t = 0; t < a; t++)
                    for (let e = 0; e < o; e++) {
                        const n = e + l * t,
                            i = e + l * (t + 1),
                            r = e + 1 + l * (t + 1),
                            s = e + 1 + l * t;
                        d.push(n, i, s), d.push(i, r, s)
                    }
                this.setIndex(d), this.setAttribute("position", new Nf(f, 3)), this.setAttribute("normal", new Nf(p, 3)), this.setAttribute("uv", new Nf(m, 2))
            }
            copy(t) {
                return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
            }
            static fromJSON(t) {
                return new Rp(t.width, t.height, t.widthSegments, t.heightSegments)
            }
        }
        const Lp = {
                alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor *= toneMappingExposure;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
            },
            Op = {
                common: {
                    diffuse: {
                        value: new xf(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new Ph
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ph
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    },
                    specularMapTransform: {
                        value: new Ph
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    },
                    aoMapTransform: {
                        value: new Ph
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    },
                    lightMapTransform: {
                        value: new Ph
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpMapTransform: {
                        value: new Ph
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalMapTransform: {
                        value: new Ph
                    },
                    normalScale: {
                        value: new Ah(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementMapTransform: {
                        value: new Ph
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    },
                    emissiveMapTransform: {
                        value: new Ph
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    },
                    metalnessMapTransform: {
                        value: new Ph
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    },
                    roughnessMapTransform: {
                        value: new Ph
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new xf(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: {
                        value: []
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotLightMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new xf(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ph
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new Ph
                    }
                },
                sprite: {
                    diffuse: {
                        value: new xf(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new Ah(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new Ph
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ph
                    },
                    alphaTest: {
                        value: 0
                    }
                }
            },
            Ip = {
                basic: {
                    uniforms: hp([Op.common, Op.specularmap, Op.envmap, Op.aomap, Op.lightmap, Op.fog]),
                    vertexShader: Lp.meshbasic_vert,
                    fragmentShader: Lp.meshbasic_frag
                },
                lambert: {
                    uniforms: hp([Op.common, Op.specularmap, Op.envmap, Op.aomap, Op.lightmap, Op.emissivemap, Op.bumpmap, Op.normalmap, Op.displacementmap, Op.fog, Op.lights, {
                        emissive: {
                            value: new xf(0)
                        }
                    }]),
                    vertexShader: Lp.meshlambert_vert,
                    fragmentShader: Lp.meshlambert_frag
                },
                phong: {
                    uniforms: hp([Op.common, Op.specularmap, Op.envmap, Op.aomap, Op.lightmap, Op.emissivemap, Op.bumpmap, Op.normalmap, Op.displacementmap, Op.fog, Op.lights, {
                        emissive: {
                            value: new xf(0)
                        },
                        specular: {
                            value: new xf(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Lp.meshphong_vert,
                    fragmentShader: Lp.meshphong_frag
                },
                standard: {
                    uniforms: hp([Op.common, Op.envmap, Op.aomap, Op.lightmap, Op.emissivemap, Op.bumpmap, Op.normalmap, Op.displacementmap, Op.roughnessmap, Op.metalnessmap, Op.fog, Op.lights, {
                        emissive: {
                            value: new xf(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Lp.meshphysical_vert,
                    fragmentShader: Lp.meshphysical_frag
                },
                toon: {
                    uniforms: hp([Op.common, Op.aomap, Op.lightmap, Op.emissivemap, Op.bumpmap, Op.normalmap, Op.displacementmap, Op.gradientmap, Op.fog, Op.lights, {
                        emissive: {
                            value: new xf(0)
                        }
                    }]),
                    vertexShader: Lp.meshtoon_vert,
                    fragmentShader: Lp.meshtoon_frag
                },
                matcap: {
                    uniforms: hp([Op.common, Op.bumpmap, Op.normalmap, Op.displacementmap, Op.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: Lp.meshmatcap_vert,
                    fragmentShader: Lp.meshmatcap_frag
                },
                points: {
                    uniforms: hp([Op.points, Op.fog]),
                    vertexShader: Lp.points_vert,
                    fragmentShader: Lp.points_frag
                },
                dashed: {
                    uniforms: hp([Op.common, Op.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Lp.linedashed_vert,
                    fragmentShader: Lp.linedashed_frag
                },
                depth: {
                    uniforms: hp([Op.common, Op.displacementmap]),
                    vertexShader: Lp.depth_vert,
                    fragmentShader: Lp.depth_frag
                },
                normal: {
                    uniforms: hp([Op.common, Op.bumpmap, Op.normalmap, Op.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Lp.meshnormal_vert,
                    fragmentShader: Lp.meshnormal_frag
                },
                sprite: {
                    uniforms: hp([Op.sprite, Op.fog]),
                    vertexShader: Lp.sprite_vert,
                    fragmentShader: Lp.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new Ph
                        },
                        t2D: {
                            value: null
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: Lp.background_vert,
                    fragmentShader: Lp.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        backgroundBlurriness: {
                            value: 0
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: Lp.backgroundCube_vert,
                    fragmentShader: Lp.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: Lp.cube_vert,
                    fragmentShader: Lp.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: Lp.equirect_vert,
                    fragmentShader: Lp.equirect_frag
                },
                distanceRGBA: {
                    uniforms: hp([Op.common, Op.displacementmap, {
                        referencePosition: {
                            value: new ed
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: Lp.distanceRGBA_vert,
                    fragmentShader: Lp.distanceRGBA_frag
                },
                shadow: {
                    uniforms: hp([Op.lights, Op.fog, {
                        color: {
                            value: new xf(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Lp.shadow_vert,
                    fragmentShader: Lp.shadow_frag
                }
            };
        Ip.physical = {
            uniforms: hp([Ip.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Ph
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Ph
                },
                clearcoatNormalScale: {
                    value: new Ah(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Ph
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Ph
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Ph
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new xf(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Ph
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Ph
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Ph
                },
                transmissionSamplerSize: {
                    value: new Ah
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Ph
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new xf(0)
                },
                specularColor: {
                    value: new xf(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Ph
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Ph
                },
                anisotropyVector: {
                    value: new Ah
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Ph
                }
            }]),
            vertexShader: Lp.meshphysical_vert,
            fragmentShader: Lp.meshphysical_frag
        };
        const Dp = {
            r: 0,
            b: 0,
            g: 0
        };

        function Np(t, e, n, i, r, s, o) {
            const a = new xf(0);
            let l, c, u = !0 === s ? 0 : 1,
                h = null,
                d = 0,
                f = null;

            function p(e, n) {
                e.getRGB(Dp, dp(t)), i.buffers.color.setClear(Dp.r, Dp.g, Dp.b, n, o)
            }
            return {
                getClearColor: function () {
                    return a
                },
                setClearColor: function (t, e = 1) {
                    a.set(t), u = e, p(a, u)
                },
                getClearAlpha: function () {
                    return u
                },
                setClearAlpha: function (t) {
                    u = t, p(a, u)
                },
                render: function (s, m) {
                    let g = !1,
                        v = !0 === m.isScene ? m.background : null;
                    if (v && v.isTexture) {
                        v = (m.backgroundBlurriness > 0 ? n : e).get(v)
                    }
                    null === v ? p(a, u) : v && v.isColor && (p(v, 1), g = !0);
                    const _ = t.xr.getEnvironmentBlendMode();
                    "additive" === _ ? i.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === _ && i.buffers.color.setClear(0, 0, 0, 0, o), (t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), v && (v.isCubeTexture || v.mapping === xu) ? (void 0 === c && (c = new ap(new cp(1, 1, 1), new pp({
                        name: "BackgroundCubeMaterial",
                        uniforms: up(Ip.backgroundCube.uniforms),
                        vertexShader: Ip.backgroundCube.vertexShader,
                        fragmentShader: Ip.backgroundCube.fragmentShader,
                        side: iu,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(c.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), r.update(c)), c.material.uniforms.envMap.value = v, c.material.uniforms.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, c.material.toneMapped = zh.getTransfer(v.colorSpace) !== rh, h === v && d === v.version && f === t.toneMapping || (c.material.needsUpdate = !0, h = v, d = v.version, f = t.toneMapping), c.layers.enableAll(), s.unshift(c, c.geometry, c.material, 0, 0, null)) : v && v.isTexture && (void 0 === l && (l = new ap(new Rp(2, 2), new pp({
                        name: "BackgroundMaterial",
                        uniforms: up(Ip.background.uniforms),
                        vertexShader: Ip.background.vertexShader,
                        fragmentShader: Ip.background.fragmentShader,
                        side: nu,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), r.update(l)), l.material.uniforms.t2D.value = v, l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, l.material.toneMapped = zh.getTransfer(v.colorSpace) !== rh, !0 === v.matrixAutoUpdate && v.updateMatrix(), l.material.uniforms.uvTransform.value.copy(v.matrix), h === v && d === v.version && f === t.toneMapping || (l.material.needsUpdate = !0, h = v, d = v.version, f = t.toneMapping), l.layers.enableAll(), s.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }

        function Up(t, e, n, i) {
            const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                o = i.isWebGL2 || null !== s,
                a = {},
                l = f(null);
            let c = l,
                u = !1;

            function h(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
            }

            function d(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
            }

            function f(t) {
                const e = [],
                    n = [],
                    i = [];
                for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function p() {
                const t = c.newAttributes;
                for (let e = 0, n = t.length; e < n; e++) t[e] = 0
            }

            function m(t) {
                g(t, 0)
            }

            function g(n, r) {
                const s = c.newAttributes,
                    o = c.enabledAttributes,
                    a = c.attributeDivisors;
                if (s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r) {
                    (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r
                }
            }

            function v() {
                const e = c.newAttributes,
                    n = c.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
            }

            function _(e, n, i, r, s, o, a) {
                !0 === a ? t.vertexAttribIPointer(e, n, i, s, o) : t.vertexAttribPointer(e, n, i, r, s, o)
            }

            function y() {
                x(), u = !0, c !== l && (c = l, h(c.object))
            }

            function x() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }
            return {
                setup: function (r, l, d, y, x) {
                    let b = !1;
                    if (o) {
                        const e = function (e, n, r) {
                            const o = !0 === r.wireframe;
                            let l = a[e.id];
                            void 0 === l && (l = {}, a[e.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {}, l[n.id] = c);
                            let u = c[o];
                            void 0 === u && (u = f(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[o] = u);
                            return u
                        }(y, d, l);
                        c !== e && (c = e, h(c.object)), b = function (t, e, n, i) {
                            const r = c.attributes,
                                s = e.attributes;
                            let o = 0;
                            const a = n.getAttributes();
                            for (const e in a) {
                                if (a[e].location >= 0) {
                                    const n = r[e];
                                    let i = s[e];
                                    if (void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (i = t.instanceColor)), void 0 === n) return !0;
                                    if (n.attribute !== i) return !0;
                                    if (i && n.data !== i.data) return !0;
                                    o++
                                }
                            }
                            return c.attributesNum !== o || c.index !== i
                        }(r, y, d, x), b && function (t, e, n, i) {
                            const r = {},
                                s = e.attributes;
                            let o = 0;
                            const a = n.getAttributes();
                            for (const e in a) {
                                if (a[e].location >= 0) {
                                    let n = s[e];
                                    void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                                    const i = {};
                                    i.attribute = n, n && n.data && (i.data = n.data), r[e] = i, o++
                                }
                            }
                            c.attributes = r, c.attributesNum = o, c.index = i
                        }(r, y, d, x)
                    } else {
                        const t = !0 === l.wireframe;
                        c.geometry === y.id && c.program === d.id && c.wireframe === t || (c.geometry = y.id, c.program = d.id, c.wireframe = t, b = !0)
                    }
                    null !== x && n.update(x, t.ELEMENT_ARRAY_BUFFER), (b || u) && (u = !1, function (r, s, o, a) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        p();
                        const l = a.attributes,
                            c = o.getAttributes(),
                            u = s.defaultAttributeValues;
                        for (const e in c) {
                            const s = c[e];
                            if (s.location >= 0) {
                                let o = l[e];
                                if (void 0 === o && ("instanceMatrix" === e && r.instanceMatrix && (o = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (o = r.instanceColor)), void 0 !== o) {
                                    const e = o.normalized,
                                        l = o.itemSize,
                                        c = n.get(o);
                                    if (void 0 === c) continue;
                                    const u = c.buffer,
                                        h = c.type,
                                        d = c.bytesPerElement,
                                        f = !0 === i.isWebGL2 && (h === t.INT || h === t.UNSIGNED_INT || o.gpuType === Ou);
                                    if (o.isInterleavedBufferAttribute) {
                                        const n = o.data,
                                            i = n.stride,
                                            c = o.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < s.locationSize; t++) g(s.location + t, n.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < s.locationSize; t++) m(s.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, u);
                                        for (let t = 0; t < s.locationSize; t++) _(s.location + t, l / s.locationSize, h, e, i * d, (c + l / s.locationSize * t) * d, f)
                                    } else {
                                        if (o.isInstancedBufferAttribute) {
                                            for (let t = 0; t < s.locationSize; t++) g(s.location + t, o.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)
                                        } else
                                            for (let t = 0; t < s.locationSize; t++) m(s.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, u);
                                        for (let t = 0; t < s.locationSize; t++) _(s.location + t, l / s.locationSize, h, e, l * d, l / s.locationSize * t * d, f)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(s.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(s.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(s.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(s.location, n)
                                    }
                                }
                            }
                        }
                        v()
                    }(r, l, d, y), null !== x && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(x).buffer))
                },
                reset: y,
                resetDefaultState: x,
                dispose: function () {
                    y();
                    for (const t in a) {
                        const e = a[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) d(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete a[t]
                    }
                },
                releaseStatesOfGeometry: function (t) {
                    if (void 0 === a[t.id]) return;
                    const e = a[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) d(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete a[t.id]
                },
                releaseStatesOfProgram: function (t) {
                    for (const e in a) {
                        const n = a[e];
                        if (void 0 === n[t.id]) continue;
                        const i = n[t.id];
                        for (const t in i) d(i[t].object), delete i[t];
                        delete n[t.id]
                    }
                },
                initAttributes: p,
                enableAttribute: m,
                disableUnusedAttributes: v
            }
        }

        function kp(t, e, n, i) {
            const r = i.isWebGL2;
            let s;
            this.setMode = function (t) {
                s = t
            }, this.render = function (e, i) {
                t.drawArrays(s, e, i), n.update(i, s, 1)
            }, this.renderInstances = function (i, o, a) {
                if (0 === a) return;
                let l, c;
                if (r) l = t, c = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return;
                l[c](s, i, o, a), n.update(o, s, a)
            }, this.renderMultiDraw = function (t, i, r) {
                if (0 === r) return;
                const o = e.get("WEBGL_multi_draw");
                if (null === o)
                    for (let e = 0; e < r; e++) this.render(t[e], i[e]);
                else {
                    o.multiDrawArraysWEBGL(s, t, 0, i, 0, r);
                    let e = 0;
                    for (let t = 0; t < r; t++) e += i[t];
                    n.update(e, s, 1)
                }
            }
        }

        function Fp(t, e, n) {
            let i;

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === t.constructor.name;
            let o = void 0 !== n.precision ? n.precision : "highp";
            const a = r(o);
            a !== o && (o = a);
            const l = s || e.has("WEBGL_draw_buffers"),
                c = !0 === n.logarithmicDepthBuffer,
                u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                d = t.getParameter(t.MAX_TEXTURE_SIZE),
                f = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                g = t.getParameter(t.MAX_VARYING_VECTORS),
                v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                _ = h > 0,
                y = s || e.has("OES_texture_float");
            return {
                isWebGL2: s,
                drawBuffers: l,
                getMaxAnisotropy: function () {
                    if (void 0 !== i) return i;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: o,
                logarithmicDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: h,
                maxTextureSize: d,
                maxCubemapSize: f,
                maxAttributes: p,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: _,
                floatFragmentTextures: y,
                floatVertexTextures: _ && y,
                maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0
            }
        }

        function zp(t) {
            const e = this;
            let n = null,
                i = 0,
                r = !1,
                s = !1;
            const o = new Mp,
                a = new Ph,
                l = {
                    value: null,
                    needsUpdate: !1
                };

            function c(t, n, i, r) {
                const s = null !== t ? t.length : 0;
                let c = null;
                if (0 !== s) {
                    if (c = l.value, !0 !== r || null === c) {
                        const e = i + 4 * s,
                            r = n.matrixWorldInverse;
                        a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                        for (let e = 0, n = i; e !== s; ++e, n += 4) o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(c, n), c[n + 3] = o.constant
                    }
                    l.value = c, l.needsUpdate = !0
                }
                return e.numPlanes = s, e.numIntersection = 0, c
            }
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e) {
                const n = 0 !== t.length || e || 0 !== i || r;
                return r = e, i = t.length, n
            }, this.beginShadows = function () {
                s = !0, c(null)
            }, this.endShadows = function () {
                s = !1
            }, this.setGlobalState = function (t, e) {
                n = c(t, e, 0)
            }, this.setState = function (o, a, u) {
                const h = o.clippingPlanes,
                    d = o.clipIntersection,
                    f = o.clipShadows,
                    p = t.get(o);
                if (!r || null === h || 0 === h.length || s && !f) s ? c(null) : function () {
                    l.value !== n && (l.value = n, l.needsUpdate = i > 0);
                    e.numPlanes = i, e.numIntersection = 0
                }();
                else {
                    const t = s ? 0 : i,
                        e = 4 * t;
                    let r = p.clippingState || null;
                    l.value = r, r = c(h, a, e, u);
                    for (let t = 0; t !== e; ++t) r[t] = n[t];
                    p.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                }
            }
        }

        function Bp(t) {
            let e = new WeakMap;

            function n(t, e) {
                return e === _u ? t.mapping = gu : e === yu && (t.mapping = vu), t
            }

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }
            return {
                get: function (r) {
                    if (r && r.isTexture) {
                        const s = r.mapping;
                        if (s === _u || s === yu) {
                            if (e.has(r)) {
                                return n(e.get(r).texture, r.mapping)
                            } {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const o = new xp(s.height / 2);
                                    return o.fromEquirectangularTexture(t, r), e.set(r, o), r.addEventListener("dispose", i), n(o.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function () {
                    e = new WeakMap
                }
            }
        }
        class Hp extends mp {
            constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) {
                super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            }
            setViewOffset(t, e, n, i, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2;
                let r = n - t,
                    s = n + t,
                    o = i + e,
                    a = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }
        const Vp = [.125, .215, .35, .446, .526, .582],
            Gp = 20,
            Wp = new Hp,
            jp = new xf;
        let Xp = null,
            qp = 0,
            Yp = 0;
        const Kp = (1 + Math.sqrt(5)) / 2,
            Zp = 1 / Kp,
            Jp = [new ed(1, 1, 1), new ed(-1, 1, 1), new ed(1, 1, -1), new ed(-1, 1, -1), new ed(0, Kp, Zp), new ed(0, Kp, -Zp), new ed(Zp, 0, Kp), new ed(-Zp, 0, Kp), new ed(Kp, Zp, 0), new ed(-Kp, Zp, 0)];
        class $p {
            constructor(t) {
                this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e = 0, n = .1, i = 100) {
                Xp = this._renderer.getRenderTarget(), qp = this._renderer.getActiveCubeFace(), Yp = this._renderer.getActiveMipmapLevel(), this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0, this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
            }
            fromEquirectangular(t, e = null) {
                return this._fromTexture(t, e)
            }
            fromCubemap(t, e = null) {
                return this._fromTexture(t, e)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = nm(), this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = em(), this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(t) {
                this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
            }
            _cleanup(t) {
                this._renderer.setRenderTarget(Xp, qp, Yp), t.scissorTest = !1, tm(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t, e) {
                t.mapping === gu || t.mapping === vu ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Xp = this._renderer.getRenderTarget(), qp = this._renderer.getActiveCubeFace(), Yp = this._renderer.getActiveMipmapLevel();
                const n = e || this._allocateTargets();
                return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
            }
            _allocateTargets() {
                const t = 3 * Math.max(this._cubeSize, 112),
                    e = 4 * this._cubeSize,
                    n = {
                        magFilter: Au,
                        minFilter: Au,
                        generateMipmaps: !1,
                        type: Nu,
                        format: ku,
                        colorSpace: th,
                        depthBuffer: !1
                    },
                    i = Qp(t, e, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Qp(t, e, n);
                    const {
                        _lodMax: i
                    } = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function (t) {
                        const e = [],
                            n = [],
                            i = [];
                        let r = t;
                        const s = t - 4 + 1 + Vp.length;
                        for (let o = 0; o < s; o++) {
                            const s = Math.pow(2, r);
                            n.push(s);
                            let a = 1 / s;
                            o > t - 4 ? a = Vp[o - t + 4 - 1] : 0 === o && (a = 0), i.push(a);
                            const l = 1 / (s - 2),
                                c = -l,
                                u = 1 + l,
                                h = [c, c, u, c, u, u, c, c, u, u, c, u],
                                d = 6,
                                f = 6,
                                p = 3,
                                m = 2,
                                g = 1,
                                v = new Float32Array(p * f * d),
                                _ = new Float32Array(m * f * d),
                                y = new Float32Array(g * f * d);
                            for (let t = 0; t < d; t++) {
                                const e = t % 3 * 2 / 3 - 1,
                                    n = t > 2 ? 0 : -1,
                                    i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                                v.set(i, p * f * t), _.set(h, m * f * t);
                                const r = [t, t, t, t, t, t];
                                y.set(r, g * f * t)
                            }
                            const x = new Gf;
                            x.setAttribute("position", new Of(v, p)), x.setAttribute("uv", new Of(_, m)), x.setAttribute("faceIndex", new Of(y, g)), e.push(x), r > 4 && r--
                        }
                        return {
                            lodPlanes: e,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)), this._blurMaterial = function (t, e, n) {
                        const i = new Float32Array(Gp),
                            r = new ed(0, 1, 0),
                            s = new pp({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: Gp,
                                    CUBEUV_TEXEL_WIDTH: 1 / e,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${t}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: i
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: r
                                    }
                                },
                                vertexShader: im(),
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            });
                        return s
                    }(i, t, e)
                }
                return i
            }
            _compileMaterial(t) {
                const e = new ap(this._lodPlanes[0], t);
                this._renderer.compile(e, Wp)
            }
            _sceneToCubeUV(t, e, n, i) {
                const r = new gp(90, 1, e, n),
                    s = [1, -1, 1, 1, 1, 1],
                    o = [1, 1, 1, -1, -1, -1],
                    a = this._renderer,
                    l = a.autoClear,
                    c = a.toneMapping;
                a.getClearColor(jp), a.toneMapping = lu, a.autoClear = !1;
                const u = new Mf({
                        name: "PMREM.Background",
                        side: iu,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    h = new ap(new cp, u);
                let d = !1;
                const f = t.background;
                f ? f.isColor && (u.color.copy(f), t.background = null, d = !0) : (u.color.copy(jp), d = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 === n ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e]));
                    const l = this._cubeSize;
                    tm(i, n * l, e > 2 ? l : 0, l, l), a.setRenderTarget(i), d && a.render(h, r), a.render(t, r)
                }
                h.geometry.dispose(), h.material.dispose(), a.toneMapping = c, a.autoClear = l, t.background = f
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer,
                    i = t.mapping === gu || t.mapping === vu;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = nm()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = em());
                const r = i ? this._cubemapMaterial : this._equirectMaterial,
                    s = new ap(this._lodPlanes[0], r);
                r.uniforms.envMap.value = t;
                const o = this._cubeSize;
                tm(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(s, Wp)
            }
            _applyPMREM(t) {
                const e = this._renderer,
                    n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < this._lodPlanes.length; e++) {
                    const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                        i = Jp[(e - 1) % Jp.length];
                    this._blur(t, e - 1, e, n, i)
                }
                e.autoClear = n
            }
            _blur(t, e, n, i, r) {
                const s = this._pingPongRenderTarget;
                this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
            }
            _halfBlur(t, e, n, i, r, s, o) {
                const a = this._renderer,
                    l = this._blurMaterial,
                    c = new ap(this._lodPlanes[i], l),
                    u = l.uniforms,
                    h = this._sizeLods[n] - 1,
                    d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                    f = r / d,
                    p = isFinite(r) ? 1 + Math.floor(3 * f) : Gp,
                    m = [];
                let g = 0;
                for (let t = 0; t < Gp; ++t) {
                    const e = t / f,
                        n = Math.exp(-e * e / 2);
                    m.push(n), 0 === t ? g += n : t < p && (g += 2 * n)
                }
                for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                u.envMap.value = t.texture, u.samples.value = p, u.weights.value = m, u.latitudinal.value = "latitudinal" === s, o && (u.poleAxis.value = o);
                const {
                    _lodMax: v
                } = this;
                u.dTheta.value = d, u.mipInt.value = v - n;
                const _ = this._sizeLods[i];
                tm(e, 3 * _ * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _), a.setRenderTarget(e), a.render(c, Wp)
            }
        }

        function Qp(t, e, n) {
            const i = new Jh(t, e, n);
            return i.texture.mapping = xu, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
        }

        function tm(t, e, n, i, r) {
            t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
        }

        function em() {
            return new pp({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: im(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function nm() {
            return new pp({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: im(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function im() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }

        function rm(t) {
            let e = new WeakMap,
                n = null;

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }
            return {
                get: function (r) {
                    if (r && r.isTexture) {
                        const s = r.mapping,
                            o = s === _u || s === yu,
                            a = s === gu || s === vu;
                        if (o || a) {
                            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                r.needsPMREMUpdate = !1;
                                let i = e.get(r);
                                return null === n && (n = new $p(t)), i = o ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
                            }
                            if (e.has(r)) return e.get(r).texture; {
                                const s = r.image;
                                if (o && s && s.height > 0 || a && s && function (t) {
                                        let e = 0;
                                        const n = 6;
                                        for (let i = 0; i < n; i++) void 0 !== t[i] && e++;
                                        return e === n
                                    }(s)) {
                                    null === n && (n = new $p(t));
                                    const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                    return e.set(r, s), r.addEventListener("dispose", i), s.texture
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function () {
                    e = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function sm(t) {
            const e = {};

            function n(n) {
                if (void 0 !== e[n]) return e[n];
                let i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = t.getExtension(n)
                }
                return e[n] = i, i
            }
            return {
                has: function (t) {
                    return null !== n(t)
                },
                init: function (t) {
                    t.isWebGL2 ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                },
                get: function (t) {
                    const e = n(t);
                    return e
                }
            }
        }

        function om(t, e, n, i) {
            const r = {},
                s = new WeakMap;

            function o(t) {
                const a = t.target;
                null !== a.index && e.remove(a.index);
                for (const t in a.attributes) e.remove(a.attributes[t]);
                for (const t in a.morphAttributes) {
                    const n = a.morphAttributes[t];
                    for (let t = 0, i = n.length; t < i; t++) e.remove(n[t])
                }
                a.removeEventListener("dispose", o), delete r[a.id];
                const l = s.get(a);
                l && (e.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
            }

            function a(t) {
                const n = [],
                    i = t.index,
                    r = t.attributes.position;
                let o = 0;
                if (null !== i) {
                    const t = i.array;
                    o = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0],
                            r = t[e + 1],
                            s = t[e + 2];
                        n.push(i, r, r, s, s, i)
                    }
                } else {
                    if (void 0 === r) return; {
                        const t = r.array;
                        o = r.version;
                        for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                            const t = e + 0,
                                i = e + 1,
                                r = e + 2;
                            n.push(t, i, i, r, r, t)
                        }
                    }
                }
                const a = new(Rh(n) ? Df : If)(n, 1);
                a.version = o;
                const l = s.get(t);
                l && e.remove(l), s.set(t, a)
            }
            return {
                get: function (t, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", o), r[e.id] = !0, n.memory.geometries++), e
                },
                update: function (n) {
                    const i = n.attributes;
                    for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
                    const r = n.morphAttributes;
                    for (const n in r) {
                        const i = r[n];
                        for (let n = 0, r = i.length; n < r; n++) e.update(i[n], t.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function (t) {
                    const e = s.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && a(t)
                    } else a(t);
                    return s.get(t)
                }
            }
        }

        function am(t, e, n, i) {
            const r = i.isWebGL2;
            let s, o, a;
            this.setMode = function (t) {
                s = t
            }, this.setIndex = function (t) {
                o = t.type, a = t.bytesPerElement
            }, this.render = function (e, i) {
                t.drawElements(s, i, o, e * a), n.update(i, s, 1)
            }, this.renderInstances = function (i, l, c) {
                if (0 === c) return;
                let u, h;
                if (r) u = t, h = "drawElementsInstanced";
                else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return;
                u[h](s, l, o, i * a, c), n.update(l, s, c)
            }, this.renderMultiDraw = function (t, i, r) {
                if (0 === r) return;
                const l = e.get("WEBGL_multi_draw");
                if (null === l)
                    for (let e = 0; e < r; e++) this.render(t[e] / a, i[e]);
                else {
                    l.multiDrawElementsWEBGL(s, i, 0, o, t, 0, r);
                    let e = 0;
                    for (let t = 0; t < r; t++) e += i[t];
                    n.update(e, s, 1)
                }
            }
        }

        function lm(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function () {
                    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function (n, i, r) {
                    switch (e.calls++, i) {
                        case t.TRIANGLES:
                            e.triangles += r * (n / 3);
                            break;
                        case t.LINES:
                            e.lines += r * (n / 2);
                            break;
                        case t.LINE_STRIP:
                            e.lines += r * (n - 1);
                            break;
                        case t.LINE_LOOP:
                            e.lines += r * n;
                            break;
                        case t.POINTS:
                            e.points += r * n
                    }
                }
            }
        }

        function cm(t, e) {
            return t[0] - e[0]
        }

        function um(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function hm(t, e, n) {
            const i = {},
                r = new Float32Array(8),
                s = new WeakMap,
                o = new Kh,
                a = [];
            for (let t = 0; t < 8; t++) a[t] = [t, 0];
            return {
                update: function (l, c, u) {
                    const h = l.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const d = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                            f = void 0 !== d ? d.length : 0;
                        let p = s.get(c);
                        if (void 0 === p || p.count !== f) {
                            void 0 !== p && p.texture.dispose();
                            const v = void 0 !== c.morphAttributes.position,
                                _ = void 0 !== c.morphAttributes.normal,
                                y = void 0 !== c.morphAttributes.color,
                                x = c.morphAttributes.position || [],
                                b = c.morphAttributes.normal || [],
                                S = c.morphAttributes.color || [];
                            let E = 0;
                            !0 === v && (E = 1), !0 === _ && (E = 2), !0 === y && (E = 3);
                            let M = c.attributes.position.count * E,
                                w = 1;
                            M > e.maxTextureSize && (w = Math.ceil(M / e.maxTextureSize), M = e.maxTextureSize);
                            const T = new Float32Array(M * w * 4 * f),
                                A = new $h(T, M, w, f);
                            A.type = Du, A.needsUpdate = !0;
                            const P = 4 * E;
                            for (let R = 0; R < f; R++) {
                                const L = x[R],
                                    O = b[R],
                                    I = S[R],
                                    D = M * w * 4 * R;
                                for (let N = 0; N < L.count; N++) {
                                    const U = N * P;
                                    !0 === v && (o.fromBufferAttribute(L, N), T[D + U + 0] = o.x, T[D + U + 1] = o.y, T[D + U + 2] = o.z, T[D + U + 3] = 0), !0 === _ && (o.fromBufferAttribute(O, N), T[D + U + 4] = o.x, T[D + U + 5] = o.y, T[D + U + 6] = o.z, T[D + U + 7] = 0), !0 === y && (o.fromBufferAttribute(I, N), T[D + U + 8] = o.x, T[D + U + 9] = o.y, T[D + U + 10] = o.z, T[D + U + 11] = 4 === I.itemSize ? o.w : 1)
                                }
                            }

                            function C() {
                                A.dispose(), s.delete(c), c.removeEventListener("dispose", C)
                            }
                            p = {
                                count: f,
                                texture: A,
                                size: new Ah(M, w)
                            }, s.set(c, p), c.addEventListener("dispose", C)
                        }
                        let m = 0;
                        for (let k = 0; k < h.length; k++) m += h[k];
                        const g = c.morphTargetsRelative ? 1 : 1 - m;
                        u.getUniforms().setValue(t, "morphTargetBaseInfluence", g), u.getUniforms().setValue(t, "morphTargetInfluences", h), u.getUniforms().setValue(t, "morphTargetsTexture", p.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", p.size)
                    } else {
                        const F = void 0 === h ? 0 : h.length;
                        let z = i[c.id];
                        if (void 0 === z || z.length !== F) {
                            z = [];
                            for (let W = 0; W < F; W++) z[W] = [W, 0];
                            i[c.id] = z
                        }
                        for (let j = 0; j < F; j++) {
                            const X = z[j];
                            X[0] = j, X[1] = h[j]
                        }
                        z.sort(um);
                        for (let q = 0; q < 8; q++) q < F && z[q][1] ? (a[q][0] = z[q][0], a[q][1] = z[q][1]) : (a[q][0] = Number.MAX_SAFE_INTEGER, a[q][1] = 0);
                        a.sort(cm);
                        const B = c.morphAttributes.position,
                            H = c.morphAttributes.normal;
                        let V = 0;
                        for (let Y = 0; Y < 8; Y++) {
                            const K = a[Y],
                                Z = K[0],
                                J = K[1];
                            Z !== Number.MAX_SAFE_INTEGER && J ? (B && c.getAttribute("morphTarget" + Y) !== B[Z] && c.setAttribute("morphTarget" + Y, B[Z]), H && c.getAttribute("morphNormal" + Y) !== H[Z] && c.setAttribute("morphNormal" + Y, H[Z]), r[Y] = J, V += J) : (B && !0 === c.hasAttribute("morphTarget" + Y) && c.deleteAttribute("morphTarget" + Y), H && !0 === c.hasAttribute("morphNormal" + Y) && c.deleteAttribute("morphNormal" + Y), r[Y] = 0)
                        }
                        const G = c.morphTargetsRelative ? 1 : 1 - V;
                        u.getUniforms().setValue(t, "morphTargetBaseInfluence", G), u.getUniforms().setValue(t, "morphTargetInfluences", r)
                    }
                }
            }
        }

        function dm(t, e, n, i) {
            let r = new WeakMap;

            function s(t) {
                const e = t.target;
                e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function (o) {
                    const a = i.render.frame,
                        l = o.geometry,
                        c = e.get(o, l);
                    if (r.get(c) !== a && (e.update(c), r.set(c, a)), o.isInstancedMesh && (!1 === o.hasEventListener("dispose", s) && o.addEventListener("dispose", s), r.get(o) !== a && (n.update(o.instanceMatrix, t.ARRAY_BUFFER), null !== o.instanceColor && n.update(o.instanceColor, t.ARRAY_BUFFER), r.set(o, a))), o.isSkinnedMesh) {
                        const t = o.skeleton;
                        r.get(t) !== a && (t.update(), r.set(t, a))
                    }
                    return c
                },
                dispose: function () {
                    r = new WeakMap
                }
            }
        }
        class fm extends Yh {
            constructor(t, e, n, i, r, s, o, a, l, c) {
                if ((c = void 0 !== c ? c : Fu) !== Fu && c !== zu) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === Fu && (n = Iu), void 0 === n && c === zu && (n = Uu), super(null, i, r, s, o, a, c, n, l), this.isDepthTexture = !0, this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== o ? o : Mu, this.minFilter = void 0 !== a ? a : Mu, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
            }
            copy(t) {
                return super.copy(t), this.compareFunction = t.compareFunction, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
            }
        }
        const pm = new Yh,
            mm = new fm(1, 1);
        mm.compareFunction = 515;
        const gm = new $h,
            vm = new Qh,
            _m = new yp,
            ym = [],
            xm = [],
            bm = new Float32Array(16),
            Sm = new Float32Array(9),
            Em = new Float32Array(4);

        function Mm(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0) return t;
            const r = e * n;
            let s = ym[r];
            if (void 0 === s && (s = new Float32Array(r), ym[r] = s), 0 !== e) {
                i.toArray(s, 0);
                for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
            }
            return s
        }

        function wm(t, e) {
            if (t.length !== e.length) return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n]) return !1;
            return !0
        }

        function Tm(t, e) {
            for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
        }

        function Am(t, e) {
            let n = xm[e];
            void 0 === n && (n = new Int32Array(e), xm[e] = n);
            for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
            return n
        }

        function Pm(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function Cm(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (wm(n, e)) return;
                t.uniform2fv(this.addr, e), Tm(n, e)
            }
        }

        function Rm(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
            else {
                if (wm(n, e)) return;
                t.uniform3fv(this.addr, e), Tm(n, e)
            }
        }

        function Lm(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (wm(n, e)) return;
                t.uniform4fv(this.addr, e), Tm(n, e)
            }
        }

        function Om(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (wm(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), Tm(n, e)
            } else {
                if (wm(n, i)) return;
                Em.set(i), t.uniformMatrix2fv(this.addr, !1, Em), Tm(n, i)
            }
        }

        function Im(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (wm(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), Tm(n, e)
            } else {
                if (wm(n, i)) return;
                Sm.set(i), t.uniformMatrix3fv(this.addr, !1, Sm), Tm(n, i)
            }
        }

        function Dm(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (wm(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), Tm(n, e)
            } else {
                if (wm(n, i)) return;
                bm.set(i), t.uniformMatrix4fv(this.addr, !1, bm), Tm(n, i)
            }
        }

        function Nm(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function Um(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (wm(n, e)) return;
                t.uniform2iv(this.addr, e), Tm(n, e)
            }
        }

        function km(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else {
                if (wm(n, e)) return;
                t.uniform3iv(this.addr, e), Tm(n, e)
            }
        }

        function Fm(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (wm(n, e)) return;
                t.uniform4iv(this.addr, e), Tm(n, e)
            }
        }

        function zm(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function Bm(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (wm(n, e)) return;
                t.uniform2uiv(this.addr, e), Tm(n, e)
            }
        }

        function Hm(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else {
                if (wm(n, e)) return;
                t.uniform3uiv(this.addr, e), Tm(n, e)
            }
        }

        function Vm(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (wm(n, e)) return;
                t.uniform4uiv(this.addr, e), Tm(n, e)
            }
        }

        function Gm(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r);
            const s = this.type === t.SAMPLER_2D_SHADOW ? mm : pm;
            n.setTexture2D(e || s, r)
        }

        function Wm(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || vm, r)
        }

        function jm(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || _m, r)
        }

        function Xm(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || gm, r)
        }

        function qm(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function Ym(t, e) {
            const n = Mm(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }

        function Km(t, e) {
            const n = Mm(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }

        function Zm(t, e) {
            const n = Mm(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }

        function Jm(t, e) {
            const n = Mm(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }

        function $m(t, e) {
            const n = Mm(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }

        function Qm(t, e) {
            const n = Mm(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }

        function tg(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function eg(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function ng(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function ig(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function rg(t, e) {
            t.uniform1uiv(this.addr, e)
        }

        function sg(t, e) {
            t.uniform2uiv(this.addr, e)
        }

        function og(t, e) {
            t.uniform3uiv(this.addr, e)
        }

        function ag(t, e) {
            t.uniform4uiv(this.addr, e)
        }

        function lg(t, e, n) {
            const i = this.cache,
                r = e.length,
                s = Am(n, r);
            wm(i, s) || (t.uniform1iv(this.addr, s), Tm(i, s));
            for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || pm, s[t])
        }

        function cg(t, e, n) {
            const i = this.cache,
                r = e.length,
                s = Am(n, r);
            wm(i, s) || (t.uniform1iv(this.addr, s), Tm(i, s));
            for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || vm, s[t])
        }

        function ug(t, e, n) {
            const i = this.cache,
                r = e.length,
                s = Am(n, r);
            wm(i, s) || (t.uniform1iv(this.addr, s), Tm(i, s));
            for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || _m, s[t])
        }

        function hg(t, e, n) {
            const i = this.cache,
                r = e.length,
                s = Am(n, r);
            wm(i, s) || (t.uniform1iv(this.addr, s), Tm(i, s));
            for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || gm, s[t])
        }
        class dg {
            constructor(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = function (t) {
                    switch (t) {
                        case 5126:
                            return Pm;
                        case 35664:
                            return Cm;
                        case 35665:
                            return Rm;
                        case 35666:
                            return Lm;
                        case 35674:
                            return Om;
                        case 35675:
                            return Im;
                        case 35676:
                            return Dm;
                        case 5124:
                        case 35670:
                            return Nm;
                        case 35667:
                        case 35671:
                            return Um;
                        case 35668:
                        case 35672:
                            return km;
                        case 35669:
                        case 35673:
                            return Fm;
                        case 5125:
                            return zm;
                        case 36294:
                            return Bm;
                        case 36295:
                            return Hm;
                        case 36296:
                            return Vm;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Gm;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Wm;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return jm;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Xm
                    }
                }(e.type)
            }
        }
        class fg {
            constructor(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = function (t) {
                    switch (t) {
                        case 5126:
                            return qm;
                        case 35664:
                            return Ym;
                        case 35665:
                            return Km;
                        case 35666:
                            return Zm;
                        case 35674:
                            return Jm;
                        case 35675:
                            return $m;
                        case 35676:
                            return Qm;
                        case 5124:
                        case 35670:
                            return tg;
                        case 35667:
                        case 35671:
                            return eg;
                        case 35668:
                        case 35672:
                            return ng;
                        case 35669:
                        case 35673:
                            return ig;
                        case 5125:
                            return rg;
                        case 36294:
                            return sg;
                        case 36295:
                            return og;
                        case 36296:
                            return ag;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return lg;
                        case 35679:
                        case 36299:
                        case 36307:
                            return cg;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return ug;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return hg
                    }
                }(e.type)
            }
        }
        class pg {
            constructor(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            setValue(t, e, n) {
                const i = this.seq;
                for (let r = 0, s = i.length; r !== s; ++r) {
                    const s = i[r];
                    s.setValue(t, e[s.id], n)
                }
            }
        }
        const mg = /(\w+)(\])?(\[|\.)?/g;

        function gg(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function vg(t, e, n) {
            const i = t.name,
                r = i.length;
            for (mg.lastIndex = 0;;) {
                const s = mg.exec(i),
                    o = mg.lastIndex;
                let a = s[1];
                const l = "]" === s[2],
                    c = s[3];
                if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === r) {
                    gg(n, void 0 === c ? new dg(a, t, e) : new fg(a, t, e));
                    break
                } {
                    let t = n.map[a];
                    void 0 === t && (t = new pg(a), gg(n, t)), n = t
                }
            }
        }
        class _g {
            constructor(t, e) {
                this.seq = [], this.map = {};
                const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = t.getActiveUniform(e, i);
                    vg(n, t.getUniformLocation(e, n.name), this)
                }
            }
            setValue(t, e, n, i) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, n, i)
            }
            setOptional(t, e, n) {
                const i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }
            static upload(t, e, n, i) {
                for (let r = 0, s = e.length; r !== s; ++r) {
                    const s = e[r],
                        o = n[s.id];
                    !1 !== o.needsUpdate && s.setValue(t, o.value, i)
                }
            }
            static seqWithValue(t, e) {
                const n = [];
                for (let i = 0, r = t.length; i !== r; ++i) {
                    const r = t[i];
                    r.id in e && n.push(r)
                }
                return n
            }
        }

        function yg(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n), t.compileShader(i), i
        }
        const xg = 37297;
        let bg = 0;

        function Sg(t, e, n) {
            const i = t.getShaderParameter(e, t.COMPILE_STATUS),
                r = t.getShaderInfoLog(e).trim();
            if (i && "" === r) return "";
            const s = /ERROR: 0:(\d+)/.exec(r);
            if (s) {
                const i = parseInt(s[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function (t, e) {
                    const n = t.split("\n"),
                        i = [],
                        r = Math.max(e - 6, 0),
                        s = Math.min(e + 6, n.length);
                    for (let t = r; t < s; t++) {
                        const r = t + 1;
                        i.push(`${r===e?">":" "} ${r}: ${n[t]}`)
                    }
                    return i.join("\n")
                }(t.getShaderSource(e), i)
            }
            return r
        }

        function Eg(t, e) {
            const n = function (t) {
                const e = zh.getPrimaries(zh.workingColorSpace),
                    n = zh.getPrimaries(t);
                let i;
                switch (e === n ? i = "" : e === oh && n === sh ? i = "LinearDisplayP3ToLinearSRGB" : e === sh && n === oh && (i = "LinearSRGBToLinearDisplayP3"), t) {
                    case th:
                    case nh:
                        return [i, "LinearTransferOETF"];
                    case Qu:
                    case eh:
                        return [i, "sRGBTransferOETF"];
                    default:
                        return [i, "LinearTransferOETF"]
                }
            }(e);
            return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
        }

        function Mg(t, e) {
            let n;
            switch (e) {
                case cu:
                    n = "Linear";
                    break;
                case uu:
                    n = "Reinhard";
                    break;
                case hu:
                    n = "OptimizedCineon";
                    break;
                case du:
                    n = "ACESFilmic";
                    break;
                case pu:
                    n = "AgX";
                    break;
                case fu:
                    n = "Custom";
                    break;
                default:
                    n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function wg(t) {
            return "" !== t
        }

        function Tg(t, e) {
            const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function Ag(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Pg = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Cg(t) {
            return t.replace(Pg, Lg)
        }
        const Rg = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);

        function Lg(t, e) {
            let n = Lp[e];
            if (void 0 === n) {
                const t = Rg.get(e);
                if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
                n = Lp[t]
            }
            return Cg(n)
        }
        const Og = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Ig(t) {
            return t.replace(Og, Dg)
        }

        function Dg(t, e, n, i) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }

        function Ng(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function Ug(t, e, n, i) {
            const r = t.getContext(),
                s = n.defines;
            let o = n.vertexShader,
                a = n.fragmentShader;
            const l = function (t) {
                    let e = "SHADOWMAP_TYPE_BASIC";
                    return t.shadowMapType === Qc ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === tu ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === eu && (e = "SHADOWMAP_TYPE_VSM"), e
                }(n),
                c = function (t) {
                    let e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case gu:
                        case vu:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case xu:
                            e = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return e
                }(n),
                u = function (t) {
                    let e = "ENVMAP_MODE_REFLECTION";
                    t.envMap && t.envMapMode === vu && (e = "ENVMAP_MODE_REFRACTION");
                    return e
                }(n),
                h = function (t) {
                    let e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case su:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case ou:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case au:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(n),
                d = function (t) {
                    const e = t.envMapCubeUVHeight;
                    if (null === e) return null;
                    const n = Math.log2(e) - 2,
                        i = 1 / e;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }(n),
                f = n.isWebGL2 ? "" : function (t) {
                    return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(wg).join("\n")
                }(n),
                p = function (t) {
                    return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""].filter(wg).join("\n")
                }(n),
                m = function (t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        !1 !== i && e.push("#define " + n + " " + i)
                    }
                    return e.join("\n")
                }(s),
                g = r.createProgram();
            let v, _, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(wg).join("\n"), v.length > 0 && (v += "\n"), _ = [f, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(wg).join("\n"), _.length > 0 && (_ += "\n")) : (v = [Ng(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(wg).join("\n"), _ = [f, Ng(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== lu ? "#define TONE_MAPPING" : "", n.toneMapping !== lu ? Lp.tonemapping_pars_fragment : "", n.toneMapping !== lu ? Mg("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Lp.colorspace_pars_fragment, Eg("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(wg).join("\n")), o = Cg(o), o = Tg(o, n), o = Ag(o, n), a = Cg(a), a = Tg(a, n), a = Ag(a, n), o = Ig(o), a = Ig(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", v = [p, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v, _ = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === ch ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === ch ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
            const x = y + v + o,
                b = y + _ + a,
                S = yg(r, r.VERTEX_SHADER, x),
                E = yg(r, r.FRAGMENT_SHADER, b);

            function M(e) {
                if (t.debug.checkShaderErrors) {
                    const n = r.getProgramInfoLog(g).trim(),
                        i = r.getShaderInfoLog(S).trim(),
                        s = r.getShaderInfoLog(E).trim();
                    let o = !0,
                        a = !0;
                    if (!1 === r.getProgramParameter(g, r.LINK_STATUS))
                        if (o = !1, "function" == typeof t.debug.onShaderError) t.debug.onShaderError(r, g, S, E);
                        else {
                            Sg(r, S, "vertex"), Sg(r, E, "fragment")
                        }
                    else "" !== n || "" !== i && "" !== s || (a = !1);
                    a && (e.diagnostics = {
                        runnable: o,
                        programLog: n,
                        vertexShader: {
                            log: i,
                            prefix: v
                        },
                        fragmentShader: {
                            log: s,
                            prefix: _
                        }
                    })
                }
                r.deleteShader(S), r.deleteShader(E), w = new _g(r, g), T = function (t, e) {
                    const n = {},
                        i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                        const i = t.getActiveAttrib(e, r),
                            s = i.name;
                        let o = 1;
                        i.type === t.FLOAT_MAT2 && (o = 2), i.type === t.FLOAT_MAT3 && (o = 3), i.type === t.FLOAT_MAT4 && (o = 4), n[s] = {
                            type: i.type,
                            location: t.getAttribLocation(e, s),
                            locationSize: o
                        }
                    }
                    return n
                }(r, g)
            }
            let w, T;
            r.attachShader(g, S), r.attachShader(g, E), void 0 !== n.index0AttributeName ? r.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g), this.getUniforms = function () {
                return void 0 === w && M(this), w
            }, this.getAttributes = function () {
                return void 0 === T && M(this), T
            };
            let A = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function () {
                return !1 === A && (A = r.getProgramParameter(g, xg)), A
            }, this.destroy = function () {
                i.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0
            }, this.type = n.shaderType, this.name = n.shaderName, this.id = bg++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = S, this.fragmentShader = E, this
        }
        let kg = 0;
        class Fg {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }
            update(t) {
                const e = t.vertexShader,
                    n = t.fragmentShader,
                    i = this._getShaderStage(e),
                    r = this._getShaderStage(n),
                    s = this._getShaderCacheForMaterial(t);
                return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this
            }
            remove(t) {
                const e = this.materialCache.get(t);
                for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
                return this.materialCache.delete(t), this
            }
            getVertexShaderID(t) {
                return this._getShaderStage(t.vertexShader).id
            }
            getFragmentShaderID(t) {
                return this._getShaderStage(t.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }
            _getShaderCacheForMaterial(t) {
                const e = this.materialCache;
                let n = e.get(t);
                return void 0 === n && (n = new Set, e.set(t, n)), n
            }
            _getShaderStage(t) {
                const e = this.shaderCache;
                let n = e.get(t);
                return void 0 === n && (n = new zg(t), e.set(t, n)), n
            }
        }
        class zg {
            constructor(t) {
                this.id = kg++, this.code = t, this.usedTimes = 0
            }
        }

        function Bg(t, e, n, i, r, s, o) {
            const a = new Vd,
                l = new Fg,
                c = [],
                u = r.isWebGL2,
                h = r.logarithmicDepthBuffer,
                d = r.vertexTextures;
            let f = r.precision;
            const p = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };

            function m(t) {
                return 0 === t ? "uv" : `uv${t}`
            }
            return {
                getParameters: function (s, a, c, g, v) {
                    const _ = g.fog,
                        y = v.geometry,
                        x = s.isMeshStandardMaterial ? g.environment : null,
                        b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || x),
                        S = b && b.mapping === xu ? b.image.height : null,
                        E = p[s.type];
                    null !== s.precision && (f = r.getMaxPrecision(s.precision), s.precision);
                    const M = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                        w = void 0 !== M ? M.length : 0;
                    let T, A, P, C, R = 0;
                    if (void 0 !== y.morphAttributes.position && (R = 1), void 0 !== y.morphAttributes.normal && (R = 2), void 0 !== y.morphAttributes.color && (R = 3), E) {
                        const t = Ip[E];
                        T = t.vertexShader, A = t.fragmentShader
                    } else T = s.vertexShader, A = s.fragmentShader, l.update(s), P = l.getVertexShaderID(s), C = l.getFragmentShaderID(s);
                    const L = t.getRenderTarget(),
                        O = !0 === v.isInstancedMesh,
                        I = !0 === v.isBatchedMesh,
                        D = !!s.map,
                        N = !!s.matcap,
                        U = !!b,
                        k = !!s.aoMap,
                        F = !!s.lightMap,
                        z = !!s.bumpMap,
                        B = !!s.normalMap,
                        H = !!s.displacementMap,
                        V = !!s.emissiveMap,
                        G = !!s.metalnessMap,
                        W = !!s.roughnessMap,
                        j = s.anisotropy > 0,
                        X = s.clearcoat > 0,
                        q = s.iridescence > 0,
                        Y = s.sheen > 0,
                        K = s.transmission > 0,
                        Z = j && !!s.anisotropyMap,
                        J = X && !!s.clearcoatMap,
                        $ = X && !!s.clearcoatNormalMap,
                        Q = X && !!s.clearcoatRoughnessMap,
                        tt = q && !!s.iridescenceMap,
                        et = q && !!s.iridescenceThicknessMap,
                        nt = Y && !!s.sheenColorMap,
                        it = Y && !!s.sheenRoughnessMap,
                        rt = !!s.specularMap,
                        st = !!s.specularColorMap,
                        ot = !!s.specularIntensityMap,
                        at = K && !!s.transmissionMap,
                        lt = K && !!s.thicknessMap,
                        ct = !!s.gradientMap,
                        ut = !!s.alphaMap,
                        ht = s.alphaTest > 0,
                        dt = !!s.alphaHash,
                        ft = !!s.extensions,
                        pt = !!y.attributes.uv1,
                        mt = !!y.attributes.uv2,
                        gt = !!y.attributes.uv3;
                    let vt = lu;
                    return s.toneMapped && (null !== L && !0 !== L.isXRRenderTarget || (vt = t.toneMapping)), {
                        isWebGL2: u,
                        shaderID: E,
                        shaderType: s.type,
                        shaderName: s.name,
                        vertexShader: T,
                        fragmentShader: A,
                        defines: s.defines,
                        customVertexShaderID: P,
                        customFragmentShaderID: C,
                        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                        glslVersion: s.glslVersion,
                        precision: f,
                        batching: I,
                        instancing: O,
                        instancingColor: O && null !== v.instanceColor,
                        supportsVertexTextures: d,
                        outputColorSpace: null === L ? t.outputColorSpace : !0 === L.isXRRenderTarget ? L.texture.colorSpace : th,
                        map: D,
                        matcap: N,
                        envMap: U,
                        envMapMode: U && b.mapping,
                        envMapCubeUVHeight: S,
                        aoMap: k,
                        lightMap: F,
                        bumpMap: z,
                        normalMap: B,
                        displacementMap: d && H,
                        emissiveMap: V,
                        normalMapObjectSpace: B && 1 === s.normalMapType,
                        normalMapTangentSpace: B && 0 === s.normalMapType,
                        metalnessMap: G,
                        roughnessMap: W,
                        anisotropy: j,
                        anisotropyMap: Z,
                        clearcoat: X,
                        clearcoatMap: J,
                        clearcoatNormalMap: $,
                        clearcoatRoughnessMap: Q,
                        iridescence: q,
                        iridescenceMap: tt,
                        iridescenceThicknessMap: et,
                        sheen: Y,
                        sheenColorMap: nt,
                        sheenRoughnessMap: it,
                        specularMap: rt,
                        specularColorMap: st,
                        specularIntensityMap: ot,
                        transmission: K,
                        transmissionMap: at,
                        thicknessMap: lt,
                        gradientMap: ct,
                        opaque: !1 === s.transparent && 1 === s.blending,
                        alphaMap: ut,
                        alphaTest: ht,
                        alphaHash: dt,
                        combine: s.combine,
                        mapUv: D && m(s.map.channel),
                        aoMapUv: k && m(s.aoMap.channel),
                        lightMapUv: F && m(s.lightMap.channel),
                        bumpMapUv: z && m(s.bumpMap.channel),
                        normalMapUv: B && m(s.normalMap.channel),
                        displacementMapUv: H && m(s.displacementMap.channel),
                        emissiveMapUv: V && m(s.emissiveMap.channel),
                        metalnessMapUv: G && m(s.metalnessMap.channel),
                        roughnessMapUv: W && m(s.roughnessMap.channel),
                        anisotropyMapUv: Z && m(s.anisotropyMap.channel),
                        clearcoatMapUv: J && m(s.clearcoatMap.channel),
                        clearcoatNormalMapUv: $ && m(s.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: Q && m(s.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: tt && m(s.iridescenceMap.channel),
                        iridescenceThicknessMapUv: et && m(s.iridescenceThicknessMap.channel),
                        sheenColorMapUv: nt && m(s.sheenColorMap.channel),
                        sheenRoughnessMapUv: it && m(s.sheenRoughnessMap.channel),
                        specularMapUv: rt && m(s.specularMap.channel),
                        specularColorMapUv: st && m(s.specularColorMap.channel),
                        specularIntensityMapUv: ot && m(s.specularIntensityMap.channel),
                        transmissionMapUv: at && m(s.transmissionMap.channel),
                        thicknessMapUv: lt && m(s.thicknessMap.channel),
                        alphaMapUv: ut && m(s.alphaMap.channel),
                        vertexTangents: !!y.attributes.tangent && (B || j),
                        vertexColors: s.vertexColors,
                        vertexAlphas: !0 === s.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                        vertexUv1s: pt,
                        vertexUv2s: mt,
                        vertexUv3s: gt,
                        pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (D || ut),
                        fog: !!_,
                        useFog: !0 === s.fog,
                        fogExp2: _ && _.isFogExp2,
                        flatShading: !0 === s.flatShading,
                        sizeAttenuation: !0 === s.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: !0 === v.isSkinnedMesh,
                        morphTargets: void 0 !== y.morphAttributes.position,
                        morphNormals: void 0 !== y.morphAttributes.normal,
                        morphColors: void 0 !== y.morphAttributes.color,
                        morphTargetsCount: w,
                        morphTextureStride: R,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numSpotLightMaps: a.spotLightMap.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
                        numLightProbes: a.numLightProbes,
                        numClippingPlanes: o.numPlanes,
                        numClipIntersection: o.numIntersection,
                        dithering: s.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: vt,
                        useLegacyLights: t._useLegacyLights,
                        decodeVideoTexture: D && !0 === s.map.isVideoTexture && zh.getTransfer(s.map.colorSpace) === rh,
                        premultipliedAlpha: s.premultipliedAlpha,
                        doubleSided: 2 === s.side,
                        flipSided: s.side === iu,
                        useDepthPacking: s.depthPacking >= 0,
                        depthPacking: s.depthPacking || 0,
                        index0AttributeName: s.index0AttributeName,
                        extensionDerivatives: ft && !0 === s.extensions.derivatives,
                        extensionFragDepth: ft && !0 === s.extensions.fragDepth,
                        extensionDrawBuffers: ft && !0 === s.extensions.drawBuffers,
                        extensionShaderTextureLOD: ft && !0 === s.extensions.shaderTextureLOD,
                        extensionClipCullDistance: ft && s.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                        rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
                        rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: s.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function (e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    return !1 === e.isRawShaderMaterial && (! function (t, e) {
                        t.push(e.precision), t.push(e.outputColorSpace), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.mapUv), t.push(e.alphaMapUv), t.push(e.lightMapUv), t.push(e.aoMapUv), t.push(e.bumpMapUv), t.push(e.normalMapUv), t.push(e.displacementMapUv), t.push(e.emissiveMapUv), t.push(e.metalnessMapUv), t.push(e.roughnessMapUv), t.push(e.anisotropyMapUv), t.push(e.clearcoatMapUv), t.push(e.clearcoatNormalMapUv), t.push(e.clearcoatRoughnessMapUv), t.push(e.iridescenceMapUv), t.push(e.iridescenceThicknessMapUv), t.push(e.sheenColorMapUv), t.push(e.sheenRoughnessMapUv), t.push(e.specularMapUv), t.push(e.specularColorMapUv), t.push(e.specularIntensityMapUv), t.push(e.transmissionMapUv), t.push(e.thicknessMapUv), t.push(e.combine), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.numLightProbes), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking)
                    }(n, e), function (t, e) {
                        a.disableAll(), e.isWebGL2 && a.enable(0);
                        e.supportsVertexTextures && a.enable(1);
                        e.instancing && a.enable(2);
                        e.instancingColor && a.enable(3);
                        e.matcap && a.enable(4);
                        e.envMap && a.enable(5);
                        e.normalMapObjectSpace && a.enable(6);
                        e.normalMapTangentSpace && a.enable(7);
                        e.clearcoat && a.enable(8);
                        e.iridescence && a.enable(9);
                        e.alphaTest && a.enable(10);
                        e.vertexColors && a.enable(11);
                        e.vertexAlphas && a.enable(12);
                        e.vertexUv1s && a.enable(13);
                        e.vertexUv2s && a.enable(14);
                        e.vertexUv3s && a.enable(15);
                        e.vertexTangents && a.enable(16);
                        e.anisotropy && a.enable(17);
                        e.alphaHash && a.enable(18);
                        e.batching && a.enable(19);
                        t.push(a.mask), a.disableAll(), e.fog && a.enable(0);
                        e.useFog && a.enable(1);
                        e.flatShading && a.enable(2);
                        e.logarithmicDepthBuffer && a.enable(3);
                        e.skinning && a.enable(4);
                        e.morphTargets && a.enable(5);
                        e.morphNormals && a.enable(6);
                        e.morphColors && a.enable(7);
                        e.premultipliedAlpha && a.enable(8);
                        e.shadowMapEnabled && a.enable(9);
                        e.useLegacyLights && a.enable(10);
                        e.doubleSided && a.enable(11);
                        e.flipSided && a.enable(12);
                        e.useDepthPacking && a.enable(13);
                        e.dithering && a.enable(14);
                        e.transmission && a.enable(15);
                        e.sheen && a.enable(16);
                        e.opaque && a.enable(17);
                        e.pointsUvs && a.enable(18);
                        e.decodeVideoTexture && a.enable(19);
                        t.push(a.mask)
                    }(n, e), n.push(t.outputColorSpace)), n.push(e.customProgramCacheKey), n.join()
                },
                getUniforms: function (t) {
                    const e = p[t.type];
                    let n;
                    if (e) {
                        const t = Ip[e];
                        n = fp.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                },
                acquireProgram: function (e, n) {
                    let i;
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        if (e.cacheKey === n) {
                            i = e, ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Ug(t, n, e, s), c.push(i)), i
                },
                releaseProgram: function (t) {
                    if (0 == --t.usedTimes) {
                        const e = c.indexOf(t);
                        c[e] = c[c.length - 1], c.pop(), t.destroy()
                    }
                },
                releaseShaderCache: function (t) {
                    l.remove(t)
                },
                programs: c,
                dispose: function () {
                    l.dispose()
                }
            }
        }

        function Hg() {
            let t = new WeakMap;
            return {
                get: function (e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                },
                remove: function (e) {
                    t.delete(e)
                },
                update: function (e, n, i) {
                    t.get(e)[n] = i
                },
                dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function Vg(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Gg(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Wg() {
            const t = [];
            let e = 0;
            const n = [],
                i = [],
                r = [];

            function s(n, i, r, s, o, a) {
                let l = t[e];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: o,
                    group: a
                }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = o, l.group = a), e++, l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function () {
                    e = 0, n.length = 0, i.length = 0, r.length = 0
                },
                push: function (t, e, o, a, l, c) {
                    const u = s(t, e, o, a, l, c);
                    o.transmission > 0 ? i.push(u) : !0 === o.transparent ? r.push(u) : n.push(u)
                },
                unshift: function (t, e, o, a, l, c) {
                    const u = s(t, e, o, a, l, c);
                    o.transmission > 0 ? i.unshift(u) : !0 === o.transparent ? r.unshift(u) : n.unshift(u)
                },
                finish: function () {
                    for (let n = e, i = t.length; n < i; n++) {
                        const e = t[n];
                        if (null === e.id) break;
                        e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                    }
                },
                sort: function (t, e) {
                    n.length > 1 && n.sort(t || Vg), i.length > 1 && i.sort(e || Gg), r.length > 1 && r.sort(e || Gg)
                }
            }
        }

        function jg() {
            let t = new WeakMap;
            return {
                get: function (e, n) {
                    const i = t.get(e);
                    let r;
                    return void 0 === i ? (r = new Wg, t.set(e, [r])) : n >= i.length ? (r = new Wg, i.push(r)) : r = i[n], r
                },
                dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function Xg() {
            const t = {};
            return {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new ed,
                                color: new xf
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new ed,
                                direction: new ed,
                                color: new xf,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new ed,
                                color: new xf,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new ed,
                                skyColor: new xf,
                                groundColor: new xf
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new xf,
                                position: new ed,
                                halfWidth: new ed,
                                halfHeight: new ed
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }
        let qg = 0;

        function Yg(t, e) {
            return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
        }

        function Kg(t, e) {
            const n = new Xg,
                i = function () {
                    const t = {};
                    return {
                        get: function (e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Ah
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Ah,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }(),
                r = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1,
                        numLightProbes: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0,
                    numLightProbes: 0
                };
            for (let t = 0; t < 9; t++) r.probe.push(new ed);
            const s = new ed,
                o = new Ld,
                a = new Ld;
            return {
                setup: function (s, o) {
                    let a = 0,
                        l = 0,
                        c = 0;
                    for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                    let u = 0,
                        h = 0,
                        d = 0,
                        f = 0,
                        p = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        _ = 0,
                        y = 0,
                        x = 0;
                    s.sort(Yg);
                    const b = !0 === o ? Math.PI : 1;
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t],
                            o = e.color,
                            S = e.intensity,
                            E = e.distance,
                            M = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) a += o.r * S * b, l += o.g * S * b, c += o.b * S * b;
                        else if (e.isLightProbe) {
                            for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], S);
                            x++
                        } else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * b), e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[u] = n, r.directionalShadowMap[u] = M, r.directionalShadowMatrix[u] = e.shadow.matrix, m++
                            }
                            r.directional[u] = t, u++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(o).multiplyScalar(S * b), t.distance = E, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, r.spot[d] = t;
                            const s = e.shadow;
                            if (e.map && (r.spotLightMap[_] = e.map, _++, s.updateMatrices(e), e.castShadow && y++), r.spotLightMatrix[d] = s.matrix, e.castShadow) {
                                const t = i.get(e);
                                t.shadowBias = s.bias, t.shadowNormalBias = s.normalBias, t.shadowRadius = s.radius, t.shadowMapSize = s.mapSize, r.spotShadow[d] = t, r.spotShadowMap[d] = M, v++
                            }
                            d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(o).multiplyScalar(S), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[f] = t, f++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * b), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = M, r.pointShadowMatrix[h] = e.shadow.matrix, g++
                            }
                            r.point[h] = t, h++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(S * b), t.groundColor.copy(e.groundColor).multiplyScalar(S * b), r.hemi[p] = t, p++
                        }
                    }
                    f > 0 && (e.isWebGL2 ? !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Op.LTC_FLOAT_1, r.rectAreaLTC2 = Op.LTC_FLOAT_2) : (r.rectAreaLTC1 = Op.LTC_HALF_1, r.rectAreaLTC2 = Op.LTC_HALF_2) : !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Op.LTC_FLOAT_1, r.rectAreaLTC2 = Op.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") && (r.rectAreaLTC1 = Op.LTC_HALF_1, r.rectAreaLTC2 = Op.LTC_HALF_2)), r.ambient[0] = a, r.ambient[1] = l, r.ambient[2] = c;
                    const S = r.hash;
                    S.directionalLength === u && S.pointLength === h && S.spotLength === d && S.rectAreaLength === f && S.hemiLength === p && S.numDirectionalShadows === m && S.numPointShadows === g && S.numSpotShadows === v && S.numSpotMaps === _ && S.numLightProbes === x || (r.directional.length = u, r.spot.length = d, r.rectArea.length = f, r.point.length = h, r.hemi.length = p, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotLightMatrix.length = v + _ - y, r.spotLightMap.length = _, r.numSpotLightShadowsWithMaps = y, r.numLightProbes = x, S.directionalLength = u, S.pointLength = h, S.spotLength = d, S.rectAreaLength = f, S.hemiLength = p, S.numDirectionalShadows = m, S.numPointShadows = g, S.numSpotShadows = v, S.numSpotMaps = _, S.numLightProbes = x, r.version = qg++)
                },
                setupView: function (t, e) {
                    let n = 0,
                        i = 0,
                        l = 0,
                        c = 0,
                        u = 0;
                    const h = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = r.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), n++
                        } else if (d.isSpotLight) {
                            const t = r.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), l++
                        } else if (d.isRectAreaLight) {
                            const t = r.rectArea[c];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), a.identity(), o.copy(d.matrixWorld), o.premultiply(h), a.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++
                        } else if (d.isPointLight) {
                            const t = r.point[i];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), i++
                        } else if (d.isHemisphereLight) {
                            const t = r.hemi[u];
                            t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(h), u++
                        }
                    }
                },
                state: r
            }
        }

        function Zg(t, e) {
            const n = new Kg(t, e),
                i = [],
                r = [];
            return {
                init: function () {
                    i.length = 0, r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function (t) {
                    n.setup(i, t)
                },
                setupLightsView: function (t) {
                    n.setupView(i, t)
                },
                pushLight: function (t) {
                    i.push(t)
                },
                pushShadow: function (t) {
                    r.push(t)
                }
            }
        }

        function Jg(t, e) {
            let n = new WeakMap;
            return {
                get: function (i, r = 0) {
                    const s = n.get(i);
                    let o;
                    return void 0 === s ? (o = new Zg(t, e), n.set(i, [o])) : r >= s.length ? (o = new Zg(t, e), s.push(o)) : o = s[r], o
                },
                dispose: function () {
                    n = new WeakMap
                }
            }
        }
        class $g extends Ef {
            constructor(t) {
                super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }
        }
        class Qg extends Ef {
            constructor(t) {
                super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }
        }

        function tv(t, e, n) {
            let i = new Ap;
            const r = new Ah,
                s = new Ah,
                o = new Kh,
                a = new $g({
                    depthPacking: 3201
                }),
                l = new Qg,
                c = {},
                u = n.maxTextureSize,
                h = {
                    [nu]: iu,
                    [iu]: nu,
                    2: 2
                },
                d = new pp({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Ah
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                f = d.clone();
            f.defines.HORIZONTAL_PASS = 1;
            const p = new Gf;
            p.setAttribute("position", new Of(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const m = new ap(p, d),
                g = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Qc;
            let v = this.type;

            function _(n, i) {
                const s = e.update(m);
                d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), null === n.mapPass && (n.mapPass = new Jh(r.x, r.y)), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, s, d, m, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, s, f, m, null)
            }

            function y(e, n, i, r) {
                let s = null;
                const o = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (void 0 !== o) s = o;
                else if (s = !0 === i.isPointLight ? l : a, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const t = s.uuid,
                        e = n.uuid;
                    let i = c[t];
                    void 0 === i && (i = {}, c[t] = i);
                    let r = i[e];
                    void 0 === r && (r = s.clone(), i[e] = r, n.addEventListener("dispose", b)), s = r
                }
                if (s.visible = n.visible, s.wireframe = n.wireframe, s.side = r === eu ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], s.alphaMap = n.alphaMap, s.alphaTest = n.alphaTest, s.map = n.map, s.clipShadows = n.clipShadows, s.clippingPlanes = n.clippingPlanes, s.clipIntersection = n.clipIntersection, s.displacementMap = n.displacementMap, s.displacementScale = n.displacementScale, s.displacementBias = n.displacementBias, s.wireframeLinewidth = n.wireframeLinewidth, s.linewidth = n.linewidth, !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial) {
                    t.properties.get(s).light = i
                }
                return s
            }

            function x(n, r, s, o, a) {
                if (!1 === n.visible) return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === eu) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n),
                        l = n.material;
                    if (Array.isArray(l)) {
                        const e = i.groups;
                        for (let c = 0, u = e.length; c < u; c++) {
                            const u = e[c],
                                h = l[u.materialIndex];
                            if (h && h.visible) {
                                const e = y(n, h, o, a);
                                n.onBeforeShadow(t, n, r, s, i, e, u), t.renderBufferDirect(s, null, i, e, n, u), n.onAfterShadow(t, n, r, s, i, e, u)
                            }
                        }
                    } else if (l.visible) {
                        const e = y(n, l, o, a);
                        n.onBeforeShadow(t, n, r, s, i, e, null), t.renderBufferDirect(s, null, i, e, n, null), n.onAfterShadow(t, n, r, s, i, e, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++) x(l[t], r, s, o, a)
            }

            function b(t) {
                t.target.removeEventListener("dispose", b);
                for (const e in c) {
                    const n = c[e],
                        i = t.target.uuid;
                    if (i in n) {
                        n[i].dispose(), delete n[i]
                    }
                }
            }
            this.render = function (e, n, a) {
                if (!1 === g.enabled) return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                if (0 === e.length) return;
                const l = t.getRenderTarget(),
                    c = t.getActiveCubeFace(),
                    h = t.getActiveMipmapLevel(),
                    d = t.state;
                d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                const f = v !== eu && this.type === eu,
                    p = v === eu && this.type !== eu;
                for (let l = 0, c = e.length; l < c; l++) {
                    const c = e[l],
                        h = c.shadow;
                    if (void 0 === h) continue;
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                    r.copy(h.mapSize);
                    const m = h.getFrameExtents();
                    if (r.multiply(m), s.copy(h.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / m.x), r.x = s.x * m.x, h.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / m.y), r.y = s.y * m.y, h.mapSize.y = s.y)), null === h.map || !0 === f || !0 === p) {
                        const t = this.type !== eu ? {
                            minFilter: Mu,
                            magFilter: Mu
                        } : {};
                        null !== h.map && h.map.dispose(), h.map = new Jh(r.x, r.y, t), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(h.map), t.clear();
                    const g = h.getViewportCount();
                    for (let t = 0; t < g; t++) {
                        const e = h.getViewport(t);
                        o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), h.updateMatrices(c, t), i = h.getFrustum(), x(n, a, h.camera, c, this.type)
                    }!0 !== h.isPointLightShadow && this.type === eu && _(h, a), h.needsUpdate = !1
                }
                v = this.type, g.needsUpdate = !1, t.setRenderTarget(l, c, h)
            }
        }

        function ev(t, e, n) {
            const i = n.isWebGL2;
            const r = new function () {
                    let e = !1;
                    const n = new Kh;
                    let i = null;
                    const r = new Kh(0, 0, 0, 0);
                    return {
                        setMask: function (n) {
                            i === n || e || (t.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e, i, s, o, a) {
                            !0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n))
                        },
                        reset: function () {
                            e = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                s = new function () {
                    let e = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function (e) {
                            e ? V(t.DEPTH_TEST) : G(t.DEPTH_TEST)
                        },
                        setMask: function (i) {
                            n === i || e || (t.depthMask(i), n = i)
                        },
                        setFunc: function (e) {
                            if (i !== e) {
                                switch (e) {
                                    case 0:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case 1:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case 2:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case 3:
                                    default:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case 4:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case 5:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case 6:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case 7:
                                        t.depthFunc(t.NOTEQUAL)
                                }
                                i = e
                            }
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e) {
                            r !== e && (t.clearDepth(e), r = e)
                        },
                        reset: function () {
                            e = !1, n = null, i = null, r = null
                        }
                    }
                },
                o = new function () {
                    let e = !1,
                        n = null,
                        i = null,
                        r = null,
                        s = null,
                        o = null,
                        a = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function (n) {
                            e || (n ? V(t.STENCIL_TEST) : G(t.STENCIL_TEST))
                        },
                        setMask: function (i) {
                            n === i || e || (t.stencilMask(i), n = i)
                        },
                        setFunc: function (e, n, o) {
                            i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o)
                        },
                        setOp: function (e, n, i) {
                            o === e && a === n && l === i || (t.stencilOp(e, n, i), o = e, a = n, l = i)
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e) {
                            c !== e && (t.clearStencil(e), c = e)
                        },
                        reset: function () {
                            e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null
                        }
                    }
                },
                a = new WeakMap,
                l = new WeakMap;
            let c = {},
                u = {},
                h = new WeakMap,
                d = [],
                f = null,
                p = !1,
                m = null,
                g = null,
                v = null,
                _ = null,
                y = null,
                x = null,
                b = null,
                S = new xf(0, 0, 0),
                E = 0,
                M = !1,
                w = null,
                T = null,
                A = null,
                P = null,
                C = null;
            const R = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let L = !1,
                O = 0;
            const I = t.getParameter(t.VERSION); - 1 !== I.indexOf("WebGL") ? (O = parseFloat(/^WebGL (\d)/.exec(I)[1]), L = O >= 1) : -1 !== I.indexOf("OpenGL ES") && (O = parseFloat(/^OpenGL ES (\d)/.exec(I)[1]), L = O >= 2);
            let D = null,
                N = {};
            const U = t.getParameter(t.SCISSOR_BOX),
                k = t.getParameter(t.VIEWPORT),
                F = (new Kh).fromArray(U),
                z = (new Kh).fromArray(k);

            function B(e, n, r, s) {
                const o = new Uint8Array(4),
                    a = t.createTexture();
                t.bindTexture(e, a), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (let a = 0; a < r; a++) !i || e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY ? t.texImage2D(n + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, o) : t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, o);
                return a
            }
            const H = {};

            function V(e) {
                !0 !== c[e] && (t.enable(e), c[e] = !0)
            }

            function G(e) {
                !1 !== c[e] && (t.disable(e), c[e] = !1)
            }
            H[t.TEXTURE_2D] = B(t.TEXTURE_2D, t.TEXTURE_2D, 1), H[t.TEXTURE_CUBE_MAP] = B(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (H[t.TEXTURE_2D_ARRAY] = B(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), H[t.TEXTURE_3D] = B(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), V(t.DEPTH_TEST), s.setFunc(3), q(!1), Y(1), V(t.CULL_FACE), X(0);
            const W = {
                [ru]: t.FUNC_ADD,
                101: t.FUNC_SUBTRACT,
                102: t.FUNC_REVERSE_SUBTRACT
            };
            if (i) W[103] = t.MIN, W[104] = t.MAX;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (W[103] = t.MIN_EXT, W[104] = t.MAX_EXT)
            }
            const j = {
                200: t.ZERO,
                201: t.ONE,
                202: t.SRC_COLOR,
                204: t.SRC_ALPHA,
                210: t.SRC_ALPHA_SATURATE,
                208: t.DST_COLOR,
                206: t.DST_ALPHA,
                203: t.ONE_MINUS_SRC_COLOR,
                205: t.ONE_MINUS_SRC_ALPHA,
                209: t.ONE_MINUS_DST_COLOR,
                207: t.ONE_MINUS_DST_ALPHA,
                211: t.CONSTANT_COLOR,
                212: t.ONE_MINUS_CONSTANT_COLOR,
                213: t.CONSTANT_ALPHA,
                214: t.ONE_MINUS_CONSTANT_ALPHA
            };

            function X(e, n, i, r, s, o, a, l, c, u) {
                if (0 !== e) {
                    if (!1 === p && (V(t.BLEND), p = !0), 5 === e) s = s || n, o = o || i, a = a || r, n === g && s === y || (t.blendEquationSeparate(W[n], W[s]), g = n, y = s), i === v && r === _ && o === x && a === b || (t.blendFuncSeparate(j[i], j[r], j[o], j[a]), v = i, _ = r, x = o, b = a), !1 !== l.equals(S) && c === E || (t.blendColor(l.r, l.g, l.b, c), S.copy(l), E = c), m = e, M = !1;
                    else if (e !== m || u !== M) {
                        if (g === ru && y === ru || (t.blendEquation(t.FUNC_ADD), g = ru, y = ru), u) switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.ONE, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case 4:
                                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.SRC_ALPHA, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case 4:
                                t.blendFunc(t.ZERO, t.SRC_COLOR)
                        }
                        v = null, _ = null, x = null, b = null, S.set(0, 0, 0), E = 0, m = e, M = u
                    }
                } else !0 === p && (G(t.BLEND), p = !1)
            }

            function q(e) {
                w !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), w = e)
            }

            function Y(e) {
                0 !== e ? (V(t.CULL_FACE), e !== T && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : G(t.CULL_FACE), T = e
            }

            function K(e, n, i) {
                e ? (V(t.POLYGON_OFFSET_FILL), P === n && C === i || (t.polygonOffset(n, i), P = n, C = i)) : G(t.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: r,
                    depth: s,
                    stencil: o
                },
                enable: V,
                disable: G,
                bindFramebuffer: function (e, n) {
                    return u[e] !== n && (t.bindFramebuffer(e, n), u[e] = n, i && (e === t.DRAW_FRAMEBUFFER && (u[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (u[t.DRAW_FRAMEBUFFER] = n)), !0)
                },
                drawBuffers: function (i, r) {
                    let s = d,
                        o = !1;
                    if (i)
                        if (s = h.get(r), void 0 === s && (s = [], h.set(r, s)), i.isWebGLMultipleRenderTargets) {
                            const e = i.texture;
                            if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                                for (let n = 0, i = e.length; n < i; n++) s[n] = t.COLOR_ATTACHMENT0 + n;
                                s.length = e.length, o = !0
                            }
                        } else s[0] !== t.COLOR_ATTACHMENT0 && (s[0] = t.COLOR_ATTACHMENT0, o = !0);
                    else s[0] !== t.BACK && (s[0] = t.BACK, o = !0);
                    o && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                },
                useProgram: function (e) {
                    return f !== e && (t.useProgram(e), f = e, !0)
                },
                setBlending: X,
                setMaterial: function (e, n) {
                    2 === e.side ? G(t.CULL_FACE) : V(t.CULL_FACE);
                    let i = e.side === iu;
                    n && (i = !i), q(i), 1 === e.blending && !1 === e.transparent ? X(0) : X(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.blendColor, e.blendAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), r.setMask(e.colorWrite);
                    const a = e.stencilWrite;
                    o.setTest(a), a && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), K(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? V(t.SAMPLE_ALPHA_TO_COVERAGE) : G(t.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: q,
                setCullFace: Y,
                setLineWidth: function (e) {
                    e !== A && (L && t.lineWidth(e), A = e)
                },
                setPolygonOffset: K,
                setScissorTest: function (e) {
                    e ? V(t.SCISSOR_TEST) : G(t.SCISSOR_TEST)
                },
                activeTexture: function (e) {
                    void 0 === e && (e = t.TEXTURE0 + R - 1), D !== e && (t.activeTexture(e), D = e)
                },
                bindTexture: function (e, n, i) {
                    void 0 === i && (i = null === D ? t.TEXTURE0 + R - 1 : D);
                    let r = N[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, N[i] = r), r.type === e && r.texture === n || (D !== i && (t.activeTexture(i), D = i), t.bindTexture(e, n || H[e]), r.type = e, r.texture = n)
                },
                unbindTexture: function () {
                    const e = N[D];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                },
                compressedTexImage2D: function () {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {}
                },
                compressedTexImage3D: function () {
                    try {
                        t.compressedTexImage3D.apply(t, arguments)
                    } catch (t) {}
                },
                texImage2D: function () {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {}
                },
                texImage3D: function () {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {}
                },
                updateUBOMapping: function (e, n) {
                    let i = l.get(n);
                    void 0 === i && (i = new WeakMap, l.set(n, i));
                    let r = i.get(e);
                    void 0 === r && (r = t.getUniformBlockIndex(n, e.name), i.set(e, r))
                },
                uniformBlockBinding: function (e, n) {
                    const i = l.get(n).get(e);
                    a.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), a.set(n, i))
                },
                texStorage2D: function () {
                    try {
                        t.texStorage2D.apply(t, arguments)
                    } catch (t) {}
                },
                texStorage3D: function () {
                    try {
                        t.texStorage3D.apply(t, arguments)
                    } catch (t) {}
                },
                texSubImage2D: function () {
                    try {
                        t.texSubImage2D.apply(t, arguments)
                    } catch (t) {}
                },
                texSubImage3D: function () {
                    try {
                        t.texSubImage3D.apply(t, arguments)
                    } catch (t) {}
                },
                compressedTexSubImage2D: function () {
                    try {
                        t.compressedTexSubImage2D.apply(t, arguments)
                    } catch (t) {}
                },
                compressedTexSubImage3D: function () {
                    try {
                        t.compressedTexSubImage3D.apply(t, arguments)
                    } catch (t) {}
                },
                scissor: function (e) {
                    !1 === F.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), F.copy(e))
                },
                viewport: function (e) {
                    !1 === z.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), z.copy(e))
                },
                reset: function () {
                    t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.blendColor(0, 0, 0, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === i && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), c = {}, D = null, N = {}, u = {}, h = new WeakMap, d = [], f = null, p = !1, m = null, g = null, v = null, _ = null, y = null, x = null, b = null, S = new xf(0, 0, 0), E = 0, M = !1, w = null, T = null, A = null, P = null, C = null, F.set(0, 0, t.canvas.width, t.canvas.height), z.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), o.reset()
                }
            }
        }

        function nv(t, e, n, i, r, s, o) {
            const a = r.isWebGL2,
                l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                u = new WeakMap;
            let h;
            const d = new WeakMap;
            let f = !1;
            try {
                f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {}

            function p(t, e) {
                return f ? new OffscreenCanvas(t, e) : Lh("canvas")
            }

            function m(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? Eh : Math.floor,
                            s = i(r * t.width),
                            o = i(r * t.height);
                        void 0 === h && (h = p(s, o));
                        const a = n ? p(s, o) : h;
                        a.width = s, a.height = o;
                        return a.getContext("2d").drawImage(t, 0, 0, s, o), a
                    }
                    return t
                }
                return t
            }

            function g(t) {
                return Sh(t.width) && Sh(t.height)
            }

            function v(t, e) {
                return t.generateMipmaps && e && t.minFilter !== Mu && t.minFilter !== Au
            }

            function _(e) {
                t.generateMipmap(e)
            }

            function y(n, i, r, s, o = !1) {
                if (!1 === a) return i;
                if (null !== n && void 0 !== t[n]) return t[n];
                let l = i;
                if (i === t.RED && (r === t.FLOAT && (l = t.R32F), r === t.HALF_FLOAT && (l = t.R16F), r === t.UNSIGNED_BYTE && (l = t.R8)), i === t.RED_INTEGER && (r === t.UNSIGNED_BYTE && (l = t.R8UI), r === t.UNSIGNED_SHORT && (l = t.R16UI), r === t.UNSIGNED_INT && (l = t.R32UI), r === t.BYTE && (l = t.R8I), r === t.SHORT && (l = t.R16I), r === t.INT && (l = t.R32I)), i === t.RG && (r === t.FLOAT && (l = t.RG32F), r === t.HALF_FLOAT && (l = t.RG16F), r === t.UNSIGNED_BYTE && (l = t.RG8)), i === t.RGBA) {
                    const e = o ? ih : zh.getTransfer(s);
                    r === t.FLOAT && (l = t.RGBA32F), r === t.HALF_FLOAT && (l = t.RGBA16F), r === t.UNSIGNED_BYTE && (l = e === rh ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)
                }
                return l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
            }

            function x(t, e, n) {
                return !0 === v(t, n) || t.isFramebufferTexture && t.minFilter !== Mu && t.minFilter !== Au ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
            }

            function b(e) {
                return e === Mu || e === wu || e === Tu ? t.NEAREST : t.LINEAR
            }

            function S(t) {
                const e = t.target;
                e.removeEventListener("dispose", S),
                    function (t) {
                        const e = i.get(t);
                        if (void 0 === e.__webglInit) return;
                        const n = t.source,
                            r = d.get(n);
                        if (r) {
                            const i = r[e.__cacheKey];
                            i.usedTimes--, 0 === i.usedTimes && M(t), 0 === Object.keys(r).length && d.delete(n)
                        }
                        i.remove(t)
                    }(e), e.isVideoTexture && u.delete(e)
            }

            function E(e) {
                const n = e.target;
                n.removeEventListener("dispose", E),
                    function (e) {
                        const n = e.texture,
                            r = i.get(e),
                            s = i.get(n);
                        void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--);
                        e.depthTexture && e.depthTexture.dispose();
                        if (e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++) {
                                if (Array.isArray(r.__webglFramebuffer[e]))
                                    for (let n = 0; n < r.__webglFramebuffer[e].length; n++) t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
                                else t.deleteFramebuffer(r.__webglFramebuffer[e]);
                                r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e])
                            } else {
                                if (Array.isArray(r.__webglFramebuffer))
                                    for (let e = 0; e < r.__webglFramebuffer.length; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]);
                                else t.deleteFramebuffer(r.__webglFramebuffer);
                                if (r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer)
                                    for (let e = 0; e < r.__webglColorRenderbuffer.length; e++) r.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                                r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                            }
                        if (e.isWebGLMultipleRenderTargets)
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = i.get(n[e]);
                                r.__webglTexture && (t.deleteTexture(r.__webglTexture), o.memory.textures--), i.remove(n[e])
                            }
                        i.remove(n), i.remove(e)
                    }(n)
            }

            function M(e) {
                const n = i.get(e);
                t.deleteTexture(n.__webglTexture);
                const r = e.source;
                delete d.get(r)[n.__cacheKey], o.memory.textures--
            }
            let w = 0;

            function T(e, r) {
                const s = i.get(e);
                if (e.isVideoTexture && function (t) {
                        const e = o.render.frame;
                        u.get(t) !== e && (u.set(t, e), t.update())
                    }(e), !1 === e.isRenderTargetTexture && e.version > 0 && s.__version !== e.version) {
                    const t = e.image;
                    if (null === t);
                    else if (!1 !== t.complete) return void O(s, e, r)
                }
                n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r)
            }
            const A = {
                    [bu]: t.REPEAT,
                    [Su]: t.CLAMP_TO_EDGE,
                    [Eu]: t.MIRRORED_REPEAT
                },
                P = {
                    [Mu]: t.NEAREST,
                    [wu]: t.NEAREST_MIPMAP_NEAREST,
                    [Tu]: t.NEAREST_MIPMAP_LINEAR,
                    [Au]: t.LINEAR,
                    [Pu]: t.LINEAR_MIPMAP_NEAREST,
                    [Cu]: t.LINEAR_MIPMAP_LINEAR
                },
                C = {
                    512: t.NEVER,
                    519: t.ALWAYS,
                    513: t.LESS,
                    515: t.LEQUAL,
                    514: t.EQUAL,
                    518: t.GEQUAL,
                    516: t.GREATER,
                    517: t.NOTEQUAL
                };

            function R(n, s, o) {
                if (o ? (t.texParameteri(n, t.TEXTURE_WRAP_S, A[s.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, A[s.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, A[s.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, P[s.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, P[s.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), s.wrapS !== Su || s.wrapT, t.texParameteri(n, t.TEXTURE_MAG_FILTER, b(s.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, b(s.minFilter)), s.minFilter !== Mu && s.minFilter), s.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, C[s.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const o = e.get("EXT_texture_filter_anisotropic");
                    if (s.magFilter === Mu) return;
                    if (s.minFilter !== Tu && s.minFilter !== Cu) return;
                    if (s.type === Du && !1 === e.has("OES_texture_float_linear")) return;
                    if (!1 === a && s.type === Nu && !1 === e.has("OES_texture_half_float_linear")) return;
                    (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                }
            }

            function L(e, n) {
                let i = !1;
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S));
                const r = n.source;
                let s = d.get(r);
                void 0 === s && (s = {}, d.set(r, s));
                const a = function (t) {
                    const e = [];
                    return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.colorSpace), e.join()
                }(n);
                if (a !== e.__cacheKey) {
                    void 0 === s[a] && (s[a] = {
                        texture: t.createTexture(),
                        usedTimes: 0
                    }, o.memory.textures++, i = !0), s[a].usedTimes++;
                    const r = s[e.__cacheKey];
                    void 0 !== r && (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && M(n)), e.__cacheKey = a, e.__webglTexture = s[a].texture
                }
                return i
            }

            function O(e, o, l) {
                let c = t.TEXTURE_2D;
                (o.isDataArrayTexture || o.isCompressedArrayTexture) && (c = t.TEXTURE_2D_ARRAY), o.isData3DTexture && (c = t.TEXTURE_3D);
                const u = L(e, o),
                    h = o.source;
                n.bindTexture(c, e.__webglTexture, t.TEXTURE0 + l);
                const d = i.get(h);
                if (h.version !== d.__version || !0 === u) {
                    n.activeTexture(t.TEXTURE0 + l);
                    const e = zh.getPrimaries(zh.workingColorSpace),
                        i = o.colorSpace === $u ? null : zh.getPrimaries(o.colorSpace),
                        f = o.colorSpace === $u || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, o.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, o.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, f);
                    const p = function (t) {
                        return !a && (t.wrapS !== Su || t.wrapT !== Su || t.minFilter !== Mu && t.minFilter !== Au)
                    }(o) && !1 === g(o.image);
                    let b = m(o.image, p, !1, r.maxTextureSize);
                    b = F(o, b);
                    const S = g(b) || a,
                        E = s.convert(o.format, o.colorSpace);
                    let M, w = s.convert(o.type),
                        T = y(o.internalFormat, E, w, o.colorSpace, o.isVideoTexture);
                    R(c, o, S);
                    const A = o.mipmaps,
                        P = a && !0 !== o.isVideoTexture && 36196 !== T,
                        C = void 0 === d.__version || !0 === u,
                        L = x(o, b, S);
                    if (o.isDepthTexture) T = t.DEPTH_COMPONENT, a ? T = o.type === Du ? t.DEPTH_COMPONENT32F : o.type === Iu ? t.DEPTH_COMPONENT24 : o.type === Uu ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : o.type, o.format === Fu && T === t.DEPTH_COMPONENT && o.type !== Lu && o.type !== Iu && (o.type = Iu, w = s.convert(o.type)), o.format === zu && T === t.DEPTH_COMPONENT && (T = t.DEPTH_STENCIL, o.type !== Uu && (o.type = Uu, w = s.convert(o.type))), C && (P ? n.texStorage2D(t.TEXTURE_2D, 1, T, b.width, b.height) : n.texImage2D(t.TEXTURE_2D, 0, T, b.width, b.height, 0, E, w, null));
                    else if (o.isDataTexture)
                        if (A.length > 0 && S) {
                            P && C && n.texStorage2D(t.TEXTURE_2D, L, T, A[0].width, A[0].height);
                            for (let e = 0, i = A.length; e < i; e++) M = A[e], P ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, M.width, M.height, E, w, M.data) : n.texImage2D(t.TEXTURE_2D, e, T, M.width, M.height, 0, E, w, M.data);
                            o.generateMipmaps = !1
                        } else P ? (C && n.texStorage2D(t.TEXTURE_2D, L, T, b.width, b.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, b.width, b.height, E, w, b.data)) : n.texImage2D(t.TEXTURE_2D, 0, T, b.width, b.height, 0, E, w, b.data);
                    else if (o.isCompressedTexture)
                        if (o.isCompressedArrayTexture) {
                            P && C && n.texStorage3D(t.TEXTURE_2D_ARRAY, L, T, A[0].width, A[0].height, b.depth);
                            for (let e = 0, i = A.length; e < i; e++) M = A[e], o.format !== ku ? null !== E && (P ? n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, M.width, M.height, b.depth, E, M.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, T, M.width, M.height, b.depth, 0, M.data, 0, 0)) : P ? n.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, M.width, M.height, b.depth, E, w, M.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, e, T, M.width, M.height, b.depth, 0, E, w, M.data)
                        } else {
                            P && C && n.texStorage2D(t.TEXTURE_2D, L, T, A[0].width, A[0].height);
                            for (let e = 0, i = A.length; e < i; e++) M = A[e], o.format !== ku ? null !== E && (P ? n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, M.width, M.height, E, M.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, T, M.width, M.height, 0, M.data)) : P ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, M.width, M.height, E, w, M.data) : n.texImage2D(t.TEXTURE_2D, e, T, M.width, M.height, 0, E, w, M.data)
                        }
                    else if (o.isDataArrayTexture) P ? (C && n.texStorage3D(t.TEXTURE_2D_ARRAY, L, T, b.width, b.height, b.depth), n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, b.width, b.height, b.depth, E, w, b.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, T, b.width, b.height, b.depth, 0, E, w, b.data);
                    else if (o.isData3DTexture) P ? (C && n.texStorage3D(t.TEXTURE_3D, L, T, b.width, b.height, b.depth), n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, b.width, b.height, b.depth, E, w, b.data)) : n.texImage3D(t.TEXTURE_3D, 0, T, b.width, b.height, b.depth, 0, E, w, b.data);
                    else if (o.isFramebufferTexture) {
                        if (C)
                            if (P) n.texStorage2D(t.TEXTURE_2D, L, T, b.width, b.height);
                            else {
                                let e = b.width,
                                    i = b.height;
                                for (let r = 0; r < L; r++) n.texImage2D(t.TEXTURE_2D, r, T, e, i, 0, E, w, null), e >>= 1, i >>= 1
                            }
                    } else if (A.length > 0 && S) {
                        P && C && n.texStorage2D(t.TEXTURE_2D, L, T, A[0].width, A[0].height);
                        for (let e = 0, i = A.length; e < i; e++) M = A[e], P ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, E, w, M) : n.texImage2D(t.TEXTURE_2D, e, T, E, w, M);
                        o.generateMipmaps = !1
                    } else P ? (C && n.texStorage2D(t.TEXTURE_2D, L, T, b.width, b.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, E, w, b)) : n.texImage2D(t.TEXTURE_2D, 0, T, E, w, b);
                    v(o, S) && _(c), d.__version = h.version, o.onUpdate && o.onUpdate(o)
                }
                e.__version = o.version
            }

            function I(e, r, o, a, c, u) {
                const h = s.convert(o.format, o.colorSpace),
                    d = s.convert(o.type),
                    f = y(o.internalFormat, h, d, o.colorSpace);
                if (!i.get(r).__hasExternalTextures) {
                    const e = Math.max(1, r.width >> u),
                        i = Math.max(1, r.height >> u);
                    c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, f, e, i, r.depth, 0, h, d, null) : n.texImage2D(c, u, f, e, i, 0, h, d, null)
                }
                n.bindFramebuffer(t.FRAMEBUFFER, e), k(r) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, a, c, i.get(o).__webglTexture, 0, U(r)) : (c === t.TEXTURE_2D || c >= t.TEXTURE_CUBE_MAP_POSITIVE_X && c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, a, c, i.get(o).__webglTexture, u), n.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function D(e, n, i) {
                if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                    let r = !0 === a ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
                    if (i || k(n)) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === Du ? r = t.DEPTH_COMPONENT32F : e.type === Iu && (r = t.DEPTH_COMPONENT24));
                        const i = U(n);
                        k(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
                    } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = U(n);
                    i && !1 === k(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : k(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                    for (let r = 0; r < e.length; r++) {
                        const o = e[r],
                            a = s.convert(o.format, o.colorSpace),
                            c = s.convert(o.type),
                            u = y(o.internalFormat, a, c, o.colorSpace),
                            h = U(n);
                        i && !1 === k(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, h, u, n.width, n.height) : k(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, h, u, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, u, n.width, n.height)
                    }
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null)
            }

            function N(e) {
                const r = i.get(e),
                    s = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function (e, r) {
                        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(t.FRAMEBUFFER, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), T(r.depthTexture, 0);
                        const s = i.get(r.depthTexture).__webglTexture,
                            o = U(r);
                        if (r.depthTexture.format === Fu) k(r) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, o) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
                        else {
                            if (r.depthTexture.format !== zu) throw new Error("Unknown depthTexture format");
                            k(r) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, o) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (s) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++) n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), D(r.__webglDepthbuffer[i], e, !1)
                } else n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), D(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function U(t) {
                return Math.min(r.maxSamples, t.samples)
            }

            function k(t) {
                const n = i.get(t);
                return a && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }

            function F(t, n) {
                const i = t.colorSpace,
                    r = t.format;
                t.type;
                return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === uh || i !== th && i !== $u && zh.getTransfer(i) === rh && !1 === a && (!0 === e.has("EXT_sRGB") && r === ku ? (t.format = uh, t.minFilter = Au, t.generateMipmaps = !1) : n = Gh.sRGBToLinear(n)), n
            }
            this.allocateTextureUnit = function () {
                const t = w;
                return r.maxTextures, w += 1, t
            }, this.resetTextureUnits = function () {
                w = 0
            }, this.setTexture2D = T, this.setTexture2DArray = function (e, r) {
                const s = i.get(e);
                e.version > 0 && s.__version !== e.version ? O(s, e, r) : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r)
            }, this.setTexture3D = function (e, r) {
                const s = i.get(e);
                e.version > 0 && s.__version !== e.version ? O(s, e, r) : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r)
            }, this.setTextureCube = function (e, o) {
                const l = i.get(e);
                e.version > 0 && l.__version !== e.version ? function (e, o, l) {
                    if (6 !== o.image.length) return;
                    const c = L(e, o),
                        u = o.source;
                    n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + l);
                    const h = i.get(u);
                    if (u.version !== h.__version || !0 === c) {
                        n.activeTexture(t.TEXTURE0 + l);
                        const e = zh.getPrimaries(zh.workingColorSpace),
                            i = o.colorSpace === $u ? null : zh.getPrimaries(o.colorSpace),
                            d = o.colorSpace === $u || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, o.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, o.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                        const f = o.isCompressedTexture || o.image[0].isCompressedTexture,
                            p = o.image[0] && o.image[0].isDataTexture,
                            b = [];
                        for (let t = 0; t < 6; t++) b[t] = f || p ? p ? o.image[t].image : o.image[t] : m(o.image[t], !1, !0, r.maxCubemapSize), b[t] = F(o, b[t]);
                        const S = b[0],
                            E = g(S) || a,
                            M = s.convert(o.format, o.colorSpace),
                            w = s.convert(o.type),
                            T = y(o.internalFormat, M, w, o.colorSpace),
                            A = a && !0 !== o.isVideoTexture,
                            P = void 0 === h.__version || !0 === c;
                        let C, L = x(o, S, E);
                        if (R(t.TEXTURE_CUBE_MAP, o, E), f) {
                            A && P && n.texStorage2D(t.TEXTURE_CUBE_MAP, L, T, S.width, S.height);
                            for (let e = 0; e < 6; e++) {
                                C = b[e].mipmaps;
                                for (let i = 0; i < C.length; i++) {
                                    const r = C[i];
                                    o.format !== ku ? null !== M && (A ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, r.width, r.height, M, r.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, T, r.width, r.height, 0, r.data)) : A ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, r.width, r.height, M, w, r.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, T, r.width, r.height, 0, M, w, r.data)
                                }
                            }
                        } else {
                            C = o.mipmaps, A && P && (C.length > 0 && L++, n.texStorage2D(t.TEXTURE_CUBE_MAP, L, T, b[0].width, b[0].height));
                            for (let e = 0; e < 6; e++)
                                if (p) {
                                    A ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, b[e].width, b[e].height, M, w, b[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, T, b[e].width, b[e].height, 0, M, w, b[e].data);
                                    for (let i = 0; i < C.length; i++) {
                                        const r = C[i].image[e].image;
                                        A ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, r.width, r.height, M, w, r.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, T, r.width, r.height, 0, M, w, r.data)
                                    }
                                } else {
                                    A ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, M, w, b[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, T, M, w, b[e]);
                                    for (let i = 0; i < C.length; i++) {
                                        const r = C[i];
                                        A ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, M, w, r.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, T, M, w, r.image[e])
                                    }
                                }
                        }
                        v(o, E) && _(t.TEXTURE_CUBE_MAP), h.__version = u.version, o.onUpdate && o.onUpdate(o)
                    }
                    e.__version = o.version
                }(l, e, o) : n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture, t.TEXTURE0 + o)
            }, this.rebindTextures = function (e, n, r) {
                const s = i.get(e);
                void 0 !== n && I(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), void 0 !== r && N(e)
            }, this.setupRenderTarget = function (e) {
                const l = e.texture,
                    c = i.get(e),
                    u = i.get(l);
                e.addEventListener("dispose", E), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = t.createTexture()), u.__version = l.version, o.memory.textures++);
                const h = !0 === e.isWebGLCubeRenderTarget,
                    d = !0 === e.isWebGLMultipleRenderTargets,
                    f = g(e) || a;
                if (h) {
                    c.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        if (a && l.mipmaps && l.mipmaps.length > 0) {
                            c.__webglFramebuffer[e] = [];
                            for (let n = 0; n < l.mipmaps.length; n++) c.__webglFramebuffer[e][n] = t.createFramebuffer()
                        } else c.__webglFramebuffer[e] = t.createFramebuffer()
                } else {
                    if (a && l.mipmaps && l.mipmaps.length > 0) {
                        c.__webglFramebuffer = [];
                        for (let e = 0; e < l.mipmaps.length; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
                    } else c.__webglFramebuffer = t.createFramebuffer();
                    if (d && r.drawBuffers) {
                        const n = e.texture;
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = i.get(n[e]);
                            void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), o.memory.textures++)
                        }
                    }
                    if (a && e.samples > 0 && !1 === k(e)) {
                        const i = d ? l : [l];
                        c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                        for (let n = 0; n < i.length; n++) {
                            const r = i[n];
                            c.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                            const o = s.convert(r.format, r.colorSpace),
                                a = s.convert(r.type),
                                l = y(r.internalFormat, o, a, r.colorSpace, !0 === e.isXRRenderTarget),
                                u = U(e);
                            t.renderbufferStorageMultisample(t.RENDERBUFFER, u, l, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n, t.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                        }
                        t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), D(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                }
                if (h) {
                    n.bindTexture(t.TEXTURE_CUBE_MAP, u.__webglTexture), R(t.TEXTURE_CUBE_MAP, l, f);
                    for (let n = 0; n < 6; n++)
                        if (a && l.mipmaps && l.mipmaps.length > 0)
                            for (let i = 0; i < l.mipmaps.length; i++) I(c.__webglFramebuffer[n][i], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                        else I(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    v(l, f) && _(t.TEXTURE_CUBE_MAP), n.unbindTexture()
                } else if (d) {
                    const r = e.texture;
                    for (let s = 0, o = r.length; s < o; s++) {
                        const o = r[s],
                            a = i.get(o);
                        n.bindTexture(t.TEXTURE_2D, a.__webglTexture), R(t.TEXTURE_2D, o, f), I(c.__webglFramebuffer, e, o, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D, 0), v(o, f) && _(t.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let i = t.TEXTURE_2D;
                    if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && a && (i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY), n.bindTexture(i, u.__webglTexture), R(i, l, f), a && l.mipmaps && l.mipmaps.length > 0)
                        for (let n = 0; n < l.mipmaps.length; n++) I(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
                    else I(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
                    v(l, f) && _(i), n.unbindTexture()
                }
                e.depthBuffer && N(e)
            }, this.updateRenderTargetMipmap = function (e) {
                const r = g(e) || a,
                    s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                for (let o = 0, a = s.length; o < a; o++) {
                    const a = s[o];
                    if (v(a, r)) {
                        const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                            s = i.get(a).__webglTexture;
                        n.bindTexture(r, s), _(r), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function (e) {
                if (a && e.samples > 0 && !1 === k(e)) {
                    const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
                        s = e.width,
                        o = e.height;
                    let a = t.COLOR_BUFFER_BIT;
                    const l = [],
                        u = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                        h = i.get(e),
                        d = !0 === e.isWebGLMultipleRenderTargets;
                    if (d)
                        for (let e = 0; e < r.length; e++) n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                    n.bindFramebuffer(t.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
                    for (let n = 0; n < r.length; n++) {
                        l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(u);
                        const f = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                        if (!1 === f && (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT)), d && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, h.__webglColorRenderbuffer[n]), !0 === f && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [u]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [u])), d) {
                            const e = i.get(r[n]).__webglTexture;
                            t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                        }
                        t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, t.NEAREST), c && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l)
                    }
                    if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), d)
                        for (let e = 0; e < r.length; e++) {
                            n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, h.__webglColorRenderbuffer[e]);
                            const s = i.get(r[e]).__webglTexture;
                            n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, s, 0)
                        }
                    n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
                }
            }, this.setupDepthRenderbuffer = N, this.setupFrameBufferTexture = I, this.useMultisampledRTT = k
        }

        function iv(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function (n, r = "") {
                    let s;
                    const o = zh.getTransfer(r);
                    if (n === Ru) return t.UNSIGNED_BYTE;
                    if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
                    if (1010 === n) return t.BYTE;
                    if (1011 === n) return t.SHORT;
                    if (n === Lu) return t.UNSIGNED_SHORT;
                    if (n === Ou) return t.INT;
                    if (n === Iu) return t.UNSIGNED_INT;
                    if (n === Du) return t.FLOAT;
                    if (n === Nu) return i ? t.HALF_FLOAT : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
                    if (1021 === n) return t.ALPHA;
                    if (n === ku) return t.RGBA;
                    if (1024 === n) return t.LUMINANCE;
                    if (1025 === n) return t.LUMINANCE_ALPHA;
                    if (n === Fu) return t.DEPTH_COMPONENT;
                    if (n === zu) return t.DEPTH_STENCIL;
                    if (n === uh) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
                    if (1028 === n) return t.RED;
                    if (1029 === n) return t.RED_INTEGER;
                    if (1030 === n) return t.RG;
                    if (1031 === n) return t.RG_INTEGER;
                    if (1033 === n) return t.RGBA_INTEGER;
                    if (n === Bu || n === Hu || n === Vu || n === Gu)
                        if (o === rh) {
                            if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
                            if (n === Bu) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === Hu) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === Vu) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === Gu) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (s = e.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
                            if (n === Bu) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === Hu) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === Vu) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === Gu) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        } if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                        if (s = e.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
                        if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === n) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (37492 === n || 37496 === n) {
                        if (s = e.get("WEBGL_compressed_texture_etc"), null === s) return null;
                        if (37492 === n) return o === rh ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                        if (37496 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                        if (s = e.get("WEBGL_compressed_texture_astc"), null === s) return null;
                        if (37808 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (37812 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === n) return o === rh ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === Wu || 36494 === n || 36495 === n) {
                        if (s = e.get("EXT_texture_compression_bptc"), null === s) return null;
                        if (n === Wu) return o === rh ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (36494 === n) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (36495 === n) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                        if (s = e.get("EXT_texture_compression_rgtc"), null === s) return null;
                        if (n === Wu) return s.COMPRESSED_RED_RGTC1_EXT;
                        if (36284 === n) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (36285 === n) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (36286 === n) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === Uu ? i ? t.UNSIGNED_INT_24_8 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null
                }
            }
        }
        class rv extends gp {
            constructor(t = []) {
                super(), this.isArrayCamera = !0, this.cameras = t
            }
        }
        class sv extends nf {
            constructor() {
                super(), this.isGroup = !0, this.type = "Group"
            }
        }
        const ov = {
            type: "move"
        };
        class av {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new sv, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new sv, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ed, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ed), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new sv, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ed, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ed), this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            }
            connect(t) {
                if (t && t.hand) {
                    const e = this._hand;
                    if (e)
                        for (const n of t.hand.values()) this._getHandJoint(e, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: t
                }), this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(t, e, n) {
                let i = null,
                    r = null,
                    s = null;
                const o = this._targetRay,
                    a = this._grip,
                    l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState) {
                    if (l && t.hand) {
                        s = !0;
                        for (const i of t.hand.values()) {
                            const t = e.getJointPose(i, n),
                                r = this._getHandJoint(l, i);
                            null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = t.radius), r.visible = null !== t
                        }
                        const i = l.joints["index-finger-tip"],
                            r = l.joints["thumb-tip"],
                            o = i.position.distanceTo(r.position),
                            a = .02,
                            c = .005;
                        l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                    null !== o && (i = e.getPose(t.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(ov)))
                }
                return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this
            }
            _getHandJoint(t, e) {
                if (void 0 === t.joints[e.jointName]) {
                    const n = new sv;
                    n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n)
                }
                return t.joints[e.jointName]
            }
        }
        class lv extends fh {
            constructor(t, e) {
                super();
                const n = this;
                let i = null,
                    r = 1,
                    s = null,
                    o = "local-floor",
                    a = 1,
                    l = null,
                    c = null,
                    u = null,
                    h = null,
                    d = null,
                    f = null;
                const p = e.getContextAttributes();
                let m = null,
                    g = null;
                const v = [],
                    _ = [],
                    y = new Ah;
                let x = null;
                const b = new gp;
                b.layers.enable(1), b.viewport = new Kh;
                const S = new gp;
                S.layers.enable(2), S.viewport = new Kh;
                const E = [b, S],
                    M = new rv;
                M.layers.enable(1), M.layers.enable(2);
                let w = null,
                    T = null;

                function A(t) {
                    const e = _.indexOf(t.inputSource);
                    if (-1 === e) return;
                    const n = v[e];
                    void 0 !== n && (n.update(t.inputSource, t.frame, l || s), n.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    }))
                }

                function P() {
                    i.removeEventListener("select", A), i.removeEventListener("selectstart", A), i.removeEventListener("selectend", A), i.removeEventListener("squeeze", A), i.removeEventListener("squeezestart", A), i.removeEventListener("squeezeend", A), i.removeEventListener("end", P), i.removeEventListener("inputsourceschange", C);
                    for (let t = 0; t < v.length; t++) {
                        const e = _[t];
                        null !== e && (_[t] = null, v[t].disconnect(e))
                    }
                    w = null, T = null, t.setRenderTarget(m), d = null, h = null, u = null, i = null, g = null, D.stop(), n.isPresenting = !1, t.setPixelRatio(x), t.setSize(y.width, y.height, !1), n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function C(t) {
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e],
                            i = _.indexOf(n);
                        i >= 0 && (_[i] = null, v[i].disconnect(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e];
                        let i = _.indexOf(n);
                        if (-1 === i) {
                            for (let t = 0; t < v.length; t++) {
                                if (t >= _.length) {
                                    _.push(n), i = t;
                                    break
                                }
                                if (null === _[t]) {
                                    _[t] = n, i = t;
                                    break
                                }
                            }
                            if (-1 === i) break
                        }
                        const r = v[i];
                        r && r.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new av, v[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new av, v[t] = e), e.getGripSpace()
                }, this.getHand = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new av, v[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function (t) {
                    r = t, n.isPresenting
                }, this.setReferenceSpaceType = function (t) {
                    o = t, n.isPresenting
                }, this.getReferenceSpace = function () {
                    return l || s
                }, this.setReferenceSpace = function (t) {
                    l = t
                }, this.getBaseLayer = function () {
                    return null !== h ? h : d
                }, this.getBinding = function () {
                    return u
                }, this.getFrame = function () {
                    return f
                }, this.getSession = function () {
                    return i
                }, this.setSession = async function (c) {
                    if (i = c, null !== i) {
                        if (m = t.getRenderTarget(), i.addEventListener("select", A), i.addEventListener("selectstart", A), i.addEventListener("selectend", A), i.addEventListener("squeeze", A), i.addEventListener("squeezestart", A), i.addEventListener("squeezeend", A), i.addEventListener("end", P), i.addEventListener("inputsourceschange", C), !0 !== p.xrCompatible && await e.makeXRCompatible(), x = t.getPixelRatio(), t.getSize(y), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== i.renderState.layers || p.antialias,
                                alpha: !0,
                                depth: p.depth,
                                stencil: p.stencil,
                                framebufferScaleFactor: r
                            };
                            d = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                baseLayer: d
                            }), t.setPixelRatio(1), t.setSize(d.framebufferWidth, d.framebufferHeight, !1), g = new Jh(d.framebufferWidth, d.framebufferHeight, {
                                format: ku,
                                type: Ru,
                                colorSpace: t.outputColorSpace,
                                stencilBuffer: p.stencil
                            })
                        } else {
                            let n = null,
                                s = null,
                                o = null;
                            p.depth && (o = p.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = p.stencil ? zu : Fu, s = p.stencil ? Uu : Iu);
                            const a = {
                                colorFormat: e.RGBA8,
                                depthFormat: o,
                                scaleFactor: r
                            };
                            u = new XRWebGLBinding(i, e), h = u.createProjectionLayer(a), i.updateRenderState({
                                layers: [h]
                            }), t.setPixelRatio(1), t.setSize(h.textureWidth, h.textureHeight, !1), g = new Jh(h.textureWidth, h.textureHeight, {
                                format: ku,
                                type: Ru,
                                depthTexture: new fm(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: p.stencil,
                                colorSpace: t.outputColorSpace,
                                samples: p.antialias ? 4 : 0
                            });
                            t.properties.get(g).__ignoreDepthValues = h.ignoreDepthValues
                        }
                        g.isXRRenderTarget = !0, this.setFoveation(a), l = null, s = await i.requestReferenceSpace(o), D.setContext(i), D.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }, this.getEnvironmentBlendMode = function () {
                    if (null !== i) return i.environmentBlendMode
                };
                const R = new ed,
                    L = new ed;

                function O(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function (t) {
                    if (null === i) return;
                    M.near = S.near = b.near = t.near, M.far = S.far = b.far = t.far, w === M.near && T === M.far || (i.updateRenderState({
                        depthNear: M.near,
                        depthFar: M.far
                    }), w = M.near, T = M.far);
                    const e = t.parent,
                        n = M.cameras;
                    O(M, e);
                    for (let t = 0; t < n.length; t++) O(n[t], e);
                    2 === n.length ? function (t, e, n) {
                            R.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(n.matrixWorld);
                            const i = R.distanceTo(L),
                                r = e.projectionMatrix.elements,
                                s = n.projectionMatrix.elements,
                                o = r[14] / (r[10] - 1),
                                a = r[14] / (r[10] + 1),
                                l = (r[9] + 1) / r[5],
                                c = (r[9] - 1) / r[5],
                                u = (r[8] - 1) / r[0],
                                h = (s[8] + 1) / s[0],
                                d = o * u,
                                f = o * h,
                                p = i / (-u + h),
                                m = p * -u;
                            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(p), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                            const g = o + p,
                                v = a + p,
                                _ = d - m,
                                y = f + (i - m),
                                x = l * a / v * g,
                                b = c * a / v * g;
                            t.projectionMatrix.makePerspective(_, y, x, b, g, v), t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                        }(M, b, S) : M.projectionMatrix.copy(b.projectionMatrix),
                        function (t, e, n) {
                            null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld), t.matrix.invert(), t.matrix.multiply(e.matrixWorld));
                            t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(!0), t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse), t.isPerspectiveCamera && (t.fov = 2 * vh * Math.atan(1 / t.projectionMatrix.elements[5]), t.zoom = 1)
                        }(t, M, e)
                }, this.getCamera = function () {
                    return M
                }, this.getFoveation = function () {
                    if (null !== h || null !== d) return a
                }, this.setFoveation = function (t) {
                    a = t, null !== h && (h.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
                };
                let I = null;
                const D = new Pp;
                D.setAnimationLoop((function (e, i) {
                    if (c = i.getViewerPose(l || s), f = i, null !== c) {
                        const e = c.views;
                        null !== d && (t.setRenderTargetFramebuffer(g, d.framebuffer), t.setRenderTarget(g));
                        let n = !1;
                        e.length !== M.cameras.length && (M.cameras.length = 0, n = !0);
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            let s = null;
                            if (null !== d) s = d.getViewport(r);
                            else {
                                const e = u.getViewSubImage(h, r);
                                s = e.viewport, 0 === i && (t.setRenderTargetTextures(g, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                            }
                            let o = E[i];
                            void 0 === o && (o = new gp, o.layers.enable(i), o.viewport = new Kh, E[i] = o), o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.quaternion, o.scale), o.projectionMatrix.fromArray(r.projectionMatrix), o.projectionMatrixInverse.copy(o.projectionMatrix).invert(), o.viewport.set(s.x, s.y, s.width, s.height), 0 === i && (M.matrix.copy(o.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), !0 === n && M.cameras.push(o)
                        }
                    }
                    for (let t = 0; t < v.length; t++) {
                        const e = _[t],
                            n = v[t];
                        null !== e && void 0 !== n && n.update(e, i, l || s)
                    }
                    I && I(e, i), i.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: i
                    }), f = null
                })), this.setAnimationLoop = function (t) {
                    I = t
                }, this.dispose = function () {}
            }
        }

        function cv(t, e) {
            function n(t, e) {
                !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix)
            }

            function i(i, r) {
                i.opacity.value = r.opacity, r.color && i.diffuse.value.copy(r.color), r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (i.map.value = r.map, n(r.map, i.mapTransform)), r.alphaMap && (i.alphaMap.value = r.alphaMap, n(r.alphaMap, i.alphaMapTransform)), r.bumpMap && (i.bumpMap.value = r.bumpMap, n(r.bumpMap, i.bumpMapTransform), i.bumpScale.value = r.bumpScale, r.side === iu && (i.bumpScale.value *= -1)), r.normalMap && (i.normalMap.value = r.normalMap, n(r.normalMap, i.normalMapTransform), i.normalScale.value.copy(r.normalScale), r.side === iu && i.normalScale.value.negate()), r.displacementMap && (i.displacementMap.value = r.displacementMap, n(r.displacementMap, i.displacementMapTransform), i.displacementScale.value = r.displacementScale, i.displacementBias.value = r.displacementBias), r.emissiveMap && (i.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, i.emissiveMapTransform)), r.specularMap && (i.specularMap.value = r.specularMap, n(r.specularMap, i.specularMapTransform)), r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
                const s = e.get(r).envMap;
                if (s && (i.envMap.value = s, i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = r.reflectivity, i.ior.value = r.ior, i.refractionRatio.value = r.refractionRatio), r.lightMap) {
                    i.lightMap.value = r.lightMap;
                    const e = !0 === t._useLegacyLights ? Math.PI : 1;
                    i.lightMapIntensity.value = r.lightMapIntensity * e, n(r.lightMap, i.lightMapTransform)
                }
                r.aoMap && (i.aoMap.value = r.aoMap, i.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, i.aoMapTransform))
            }
            return {
                refreshFogUniforms: function (e, n) {
                    n.color.getRGB(e.fogColor.value, dp(t)), n.isFog ? (e.fogNear.value = n.near, e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function (t, r, s, o, a) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(t, r) : r.isMeshToonMaterial ? (i(t, r), function (t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(t, r)) : r.isMeshPhongMaterial ? (i(t, r), function (t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                    }(t, r)) : r.isMeshStandardMaterial ? (i(t, r), function (t, i) {
                        t.metalness.value = i.metalness, i.metalnessMap && (t.metalnessMap.value = i.metalnessMap, n(i.metalnessMap, t.metalnessMapTransform));
                        t.roughness.value = i.roughness, i.roughnessMap && (t.roughnessMap.value = i.roughnessMap, n(i.roughnessMap, t.roughnessMapTransform));
                        const r = e.get(i).envMap;
                        r && (t.envMapIntensity.value = i.envMapIntensity)
                    }(t, r), r.isMeshPhysicalMaterial && function (t, e, i) {
                        t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap, n(e.sheenColorMap, t.sheenColorMapTransform)), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap, n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform)));
                        e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap, n(e.clearcoatMap, t.clearcoatMapTransform)), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap, n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform), t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), e.side === iu && t.clearcoatNormalScale.value.negate()));
                        e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap, n(e.iridescenceMap, t.iridescenceMapTransform)), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap, n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform)));
                        e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap, n(e.transmissionMap, t.transmissionMapTransform)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap, n(e.thicknessMap, t.thicknessMapTransform)), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor));
                        e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap, n(e.anisotropyMap, t.anisotropyMapTransform)));
                        t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap, n(e.specularColorMap, t.specularColorMapTransform));
                        e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap, n(e.specularIntensityMap, t.specularIntensityMapTransform))
                    }(t, r, a)) : r.isMeshMatcapMaterial ? (i(t, r), function (t, e) {
                        e.matcap && (t.matcap.value = e.matcap)
                    }(t, r)) : r.isMeshDepthMaterial ? i(t, r) : r.isMeshDistanceMaterial ? (i(t, r), function (t, n) {
                        const i = e.get(n).light;
                        t.referencePosition.value.setFromMatrixPosition(i.matrixWorld), t.nearDistance.value = i.shadow.camera.near, t.farDistance.value = i.shadow.camera.far
                    }(t, r)) : r.isMeshNormalMaterial ? i(t, r) : r.isLineBasicMaterial ? (function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, e.map && (t.map.value = e.map, n(e.map, t.mapTransform))
                    }(t, r), r.isLineDashedMaterial && function (t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(t, r)) : r.isPointsMaterial ? function (t, e, i, r) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * r, e.map && (t.map.value = e.map, n(e.map, t.uvTransform));
                        e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform));
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                    }(t, r, s, o) : r.isSpriteMaterial ? function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map, n(e.map, t.mapTransform));
                        e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform));
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                    }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }

        function uv(t, e, n, i) {
            let r = {},
                s = {},
                o = [];
            const a = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

            function l(t, e, n, i) {
                const r = t.value,
                    s = e + "_" + n;
                if (void 0 === i[s]) return i[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0; {
                    const t = i[s];
                    if ("number" == typeof r || "boolean" == typeof r) {
                        if (t !== r) return i[s] = r, !0
                    } else if (!1 === t.equals(r)) return t.copy(r), !0
                }
                return !1
            }

            function c(t) {
                const e = {
                    boundary: 0,
                    storage: 0
                };
                return "number" == typeof t || "boolean" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture, e
            }

            function u(e) {
                const n = e.target;
                n.removeEventListener("dispose", u);
                const i = o.indexOf(n.__bindingPointIndex);
                o.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id]
            }
            return {
                bind: function (t, e) {
                    const n = e.program;
                    i.uniformBlockBinding(t, n)
                },
                update: function (n, h) {
                    let d = r[n.id];
                    void 0 === d && (! function (t) {
                        const e = t.uniforms;
                        let n = 0;
                        const i = 16;
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = Array.isArray(e[t]) ? e[t] : [e[t]];
                            for (let t = 0, e = r.length; t < e; t++) {
                                const e = r[t],
                                    s = Array.isArray(e.value) ? e.value : [e.value];
                                for (let t = 0, r = s.length; t < r; t++) {
                                    const r = c(s[t]),
                                        o = n % i;
                                    0 !== o && i - o < r.boundary && (n += i - o), e.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), e.__offset = n, n += r.storage
                                }
                            }
                        }
                        const r = n % i;
                        r > 0 && (n += i - r);
                        t.__size = n, t.__cache = {}
                    }(n), d = function (e) {
                        const n = function () {
                            for (let t = 0; t < a; t++)
                                if (-1 === o.indexOf(t)) return o.push(t), t;
                            return 0
                        }();
                        e.__bindingPointIndex = n;
                        const i = t.createBuffer(),
                            r = e.__size,
                            s = e.usage;
                        return t.bindBuffer(t.UNIFORM_BUFFER, i), t.bufferData(t.UNIFORM_BUFFER, r, s), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, n, i), i
                    }(n), r[n.id] = d, n.addEventListener("dispose", u));
                    const f = h.program;
                    i.updateUBOMapping(n, f);
                    const p = e.render.frame;
                    s[n.id] !== p && (! function (e) {
                        const n = r[e.id],
                            i = e.uniforms,
                            s = e.__cache;
                        t.bindBuffer(t.UNIFORM_BUFFER, n);
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = Array.isArray(i[e]) ? i[e] : [i[e]];
                            for (let i = 0, r = n.length; i < r; i++) {
                                const r = n[i];
                                if (!0 === l(r, e, i, s)) {
                                    const e = r.__offset,
                                        n = Array.isArray(r.value) ? r.value : [r.value];
                                    let i = 0;
                                    for (let s = 0; s < n.length; s++) {
                                        const o = n[s],
                                            a = c(o);
                                        "number" == typeof o || "boolean" == typeof o ? (r.__data[0] = o, t.bufferSubData(t.UNIFORM_BUFFER, e + i, r.__data)) : o.isMatrix3 ? (r.__data[0] = o.elements[0], r.__data[1] = o.elements[1], r.__data[2] = o.elements[2], r.__data[3] = 0, r.__data[4] = o.elements[3], r.__data[5] = o.elements[4], r.__data[6] = o.elements[5], r.__data[7] = 0, r.__data[8] = o.elements[6], r.__data[9] = o.elements[7], r.__data[10] = o.elements[8], r.__data[11] = 0) : (o.toArray(r.__data, i), i += a.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    t.bufferSubData(t.UNIFORM_BUFFER, e, r.__data)
                                }
                            }
                        }
                        t.bindBuffer(t.UNIFORM_BUFFER, null)
                    }(n), s[n.id] = p)
                },
                dispose: function () {
                    for (const e in r) t.deleteBuffer(r[e]);
                    o = [], r = {}, s = {}
                }
            }
        }
        class hv {
            constructor(t = {}) {
                const {
                    canvas: e = Oh(),
                    context: n = null,
                    depth: i = !0,
                    stencil: r = !0,
                    alpha: s = !1,
                    antialias: o = !1,
                    premultipliedAlpha: a = !0,
                    preserveDrawingBuffer: l = !1,
                    powerPreference: c = "default",
                    failIfMajorPerformanceCaveat: u = !1
                } = t;
                let h;
                this.isWebGLRenderer = !0, h = null !== n ? n.getContextAttributes().alpha : s;
                const d = new Uint32Array(4),
                    f = new Int32Array(4);
                let p = null,
                    m = null;
                const g = [],
                    v = [];
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Qu, this._useLegacyLights = !1, this.toneMapping = lu, this.toneMappingExposure = 1;
                const _ = this;
                let y = !1,
                    x = 0,
                    b = 0,
                    S = null,
                    E = -1,
                    M = null;
                const w = new Kh,
                    T = new Kh;
                let A = null;
                const P = new xf(0);
                let C = 0,
                    R = e.width,
                    L = e.height,
                    O = 1,
                    I = null,
                    D = null;
                const N = new Kh(0, 0, R, L),
                    U = new Kh(0, 0, R, L);
                let k = !1;
                const F = new Ap;
                let z = !1,
                    B = !1,
                    H = null;
                const V = new Ld,
                    G = new Ah,
                    W = new ed,
                    j = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function X() {
                    return null === S ? O : 1
                }
                let q, Y, K, Z, J, $, Q, tt, et, nt, it, rt, st, ot, at, lt, ct, ut, ht, dt, ft, pt, mt, gt, vt = n;

                function _t(t, n) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i],
                            s = e.getContext(r, n);
                        if (null !== s) return s
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: !0,
                        depth: i,
                        stencil: r,
                        antialias: o,
                        premultipliedAlpha: a,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u
                    };
                    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${$c}`), e.addEventListener("webglcontextlost", bt, !1), e.addEventListener("webglcontextrestored", St, !1), e.addEventListener("webglcontextcreationerror", Et, !1), null === vt) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === _.isWebGL1Renderer && e.shift(), vt = _t(e, t), null === vt) throw _t(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    "undefined" != typeof WebGLRenderingContext && WebGLRenderingContext, void 0 === vt.getShaderPrecisionFormat && (vt.getShaderPrecisionFormat = function () {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    throw t
                }

                function yt() {
                    q = new sm(vt), Y = new Fp(vt, q, t), q.init(Y), pt = new iv(vt, q, Y), K = new ev(vt, q, Y), Z = new lm(vt), J = new Hg, $ = new nv(vt, q, K, J, Y, pt, Z), Q = new Bp(_), tt = new rm(_), et = new Cp(vt, Y), mt = new Up(vt, q, et, Y), nt = new om(vt, et, Z, mt), it = new dm(vt, nt, et, Z), ht = new hm(vt, Y, $), lt = new zp(J), rt = new Bg(_, Q, tt, q, Y, mt, lt), st = new cv(_, J), ot = new jg, at = new Jg(q, Y), ut = new Np(_, Q, tt, K, it, h, a), ct = new tv(_, it, Y), gt = new uv(vt, Z, Y, K), dt = new kp(vt, q, Z, Y), ft = new am(vt, q, Z, Y), Z.programs = rt.programs, _.capabilities = Y, _.extensions = q, _.properties = J, _.renderLists = ot, _.shadowMap = ct, _.state = K, _.info = Z
                }
                yt();
                const xt = new lv(_, vt);

                function bt(t) {
                    t.preventDefault(), y = !0
                }

                function St() {
                    y = !1;
                    const t = Z.autoReset,
                        e = ct.enabled,
                        n = ct.autoUpdate,
                        i = ct.needsUpdate,
                        r = ct.type;
                    yt(), Z.autoReset = t, ct.enabled = e, ct.autoUpdate = n, ct.needsUpdate = i, ct.type = r
                }

                function Et(t) {}

                function Mt(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", Mt),
                        function (t) {
                            (function (t) {
                                const e = J.get(t).programs;
                                void 0 !== e && (e.forEach((function (t) {
                                    rt.releaseProgram(t)
                                })), t.isShaderMaterial && rt.releaseShaderCache(t))
                            })(t), J.remove(t)
                        }(e)
                }

                function wt(t, e, n) {
                    !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass ? (t.side = iu, t.needsUpdate = !0, Dt(t, e, n), t.side = nu, t.needsUpdate = !0, Dt(t, e, n), t.side = 2) : Dt(t, e, n)
                }
                this.xr = xt, this.getContext = function () {
                    return vt
                }, this.getContextAttributes = function () {
                    return vt.getContextAttributes()
                }, this.forceContextLoss = function () {
                    const t = q.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function () {
                    const t = q.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function () {
                    return O
                }, this.setPixelRatio = function (t) {
                    void 0 !== t && (O = t, this.setSize(R, L, !1))
                }, this.getSize = function (t) {
                    return t.set(R, L)
                }, this.setSize = function (t, n, i = !0) {
                    xt.isPresenting || (R = t, L = n, e.width = Math.floor(t * O), e.height = Math.floor(n * O), !0 === i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function (t) {
                    return t.set(R * O, L * O).floor()
                }, this.setDrawingBufferSize = function (t, n, i) {
                    R = t, L = n, O = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function (t) {
                    return t.copy(w)
                }, this.getViewport = function (t) {
                    return t.copy(N)
                }, this.setViewport = function (t, e, n, i) {
                    t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), K.viewport(w.copy(N).multiplyScalar(O).floor())
                }, this.getScissor = function (t) {
                    return t.copy(U)
                }, this.setScissor = function (t, e, n, i) {
                    t.isVector4 ? U.set(t.x, t.y, t.z, t.w) : U.set(t, e, n, i), K.scissor(T.copy(U).multiplyScalar(O).floor())
                }, this.getScissorTest = function () {
                    return k
                }, this.setScissorTest = function (t) {
                    K.setScissorTest(k = t)
                }, this.setOpaqueSort = function (t) {
                    I = t
                }, this.setTransparentSort = function (t) {
                    D = t
                }, this.getClearColor = function (t) {
                    return t.copy(ut.getClearColor())
                }, this.setClearColor = function () {
                    ut.setClearColor.apply(ut, arguments)
                }, this.getClearAlpha = function () {
                    return ut.getClearAlpha()
                }, this.setClearAlpha = function () {
                    ut.setClearAlpha.apply(ut, arguments)
                }, this.clear = function (t = !0, e = !0, n = !0) {
                    let i = 0;
                    if (t) {
                        let t = !1;
                        if (null !== S) {
                            const e = S.texture.format;
                            t = 1033 === e || 1031 === e || 1029 === e
                        }
                        if (t) {
                            const t = S.texture.type,
                                e = t === Ru || t === Iu || t === Lu || t === Uu || 1017 === t || 1018 === t,
                                n = ut.getClearColor(),
                                i = ut.getClearAlpha(),
                                r = n.r,
                                s = n.g,
                                o = n.b;
                            e ? (d[0] = r, d[1] = s, d[2] = o, d[3] = i, vt.clearBufferuiv(vt.COLOR, 0, d)) : (f[0] = r, f[1] = s, f[2] = o, f[3] = i, vt.clearBufferiv(vt.COLOR, 0, f))
                        } else i |= vt.COLOR_BUFFER_BIT
                    }
                    e && (i |= vt.DEPTH_BUFFER_BIT), n && (i |= vt.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), vt.clear(i)
                }, this.clearColor = function () {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function () {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function () {
                    this.clear(!1, !1, !0)
                }, this.dispose = function () {
                    e.removeEventListener("webglcontextlost", bt, !1), e.removeEventListener("webglcontextrestored", St, !1), e.removeEventListener("webglcontextcreationerror", Et, !1), ot.dispose(), at.dispose(), J.dispose(), Q.dispose(), tt.dispose(), it.dispose(), mt.dispose(), gt.dispose(), rt.dispose(), xt.dispose(), xt.removeEventListener("sessionstart", At), xt.removeEventListener("sessionend", Pt), H && (H.dispose(), H = null), Ct.stop()
                }, this.renderBufferDirect = function (t, e, n, i, r, s) {
                    null === e && (e = j);
                    const o = r.isMesh && r.matrixWorld.determinant() < 0,
                        a = function (t, e, n, i, r) {
                            !0 !== e.isScene && (e = j);
                            $.resetTextureUnits();
                            const s = e.fog,
                                o = i.isMeshStandardMaterial ? e.environment : null,
                                a = null === S ? _.outputColorSpace : !0 === S.isXRRenderTarget ? S.texture.colorSpace : th,
                                l = (i.isMeshStandardMaterial ? tt : Q).get(i.envMap || o),
                                c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                u = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                                h = !!n.morphAttributes.position,
                                d = !!n.morphAttributes.normal,
                                f = !!n.morphAttributes.color;
                            let p = lu;
                            i.toneMapped && (null !== S && !0 !== S.isXRRenderTarget || (p = _.toneMapping));
                            const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                v = void 0 !== g ? g.length : 0,
                                y = J.get(i),
                                x = m.state.lights;
                            if (!0 === z && (!0 === B || t !== M)) {
                                const e = t === M && i.id === E;
                                lt.setState(i, t, e)
                            }
                            let b = !1;
                            i.version === y.__version ? y.needsLights && y.lightsStateVersion !== x.state.version || y.outputColorSpace !== a || r.isBatchedMesh && !1 === y.batching ? b = !0 : r.isBatchedMesh || !0 !== y.batching ? r.isInstancedMesh && !1 === y.instancing ? b = !0 : r.isInstancedMesh || !0 !== y.instancing ? r.isSkinnedMesh && !1 === y.skinning ? b = !0 : r.isSkinnedMesh || !0 !== y.skinning ? r.isInstancedMesh && !0 === y.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === y.instancingColor && null !== r.instanceColor || y.envMap !== l || !0 === i.fog && y.fog !== s ? b = !0 : void 0 === y.numClippingPlanes || y.numClippingPlanes === lt.numPlanes && y.numIntersection === lt.numIntersection ? (y.vertexAlphas !== c || y.vertexTangents !== u || y.morphTargets !== h || y.morphNormals !== d || y.morphColors !== f || y.toneMapping !== p || !0 === Y.isWebGL2 && y.morphTargetsCount !== v) && (b = !0) : b = !0 : b = !0 : b = !0 : b = !0 : (b = !0, y.__version = i.version);
                            let w = y.currentProgram;
                            !0 === b && (w = Dt(i, e, r));
                            let T = !1,
                                A = !1,
                                P = !1;
                            const C = w.getUniforms(),
                                R = y.uniforms;
                            K.useProgram(w.program) && (T = !0, A = !0, P = !0);
                            i.id !== E && (E = i.id, A = !0);
                            if (T || M !== t) {
                                C.setValue(vt, "projectionMatrix", t.projectionMatrix), C.setValue(vt, "viewMatrix", t.matrixWorldInverse);
                                const e = C.map.cameraPosition;
                                void 0 !== e && e.setValue(vt, W.setFromMatrixPosition(t.matrixWorld)), Y.logarithmicDepthBuffer && C.setValue(vt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && C.setValue(vt, "isOrthographic", !0 === t.isOrthographicCamera), M !== t && (M = t, A = !0, P = !0)
                            }
                            if (r.isSkinnedMesh) {
                                C.setOptional(vt, r, "bindMatrix"), C.setOptional(vt, r, "bindMatrixInverse");
                                const t = r.skeleton;
                                t && Y.floatVertexTextures && (null === t.boneTexture && t.computeBoneTexture(), C.setValue(vt, "boneTexture", t.boneTexture, $))
                            }
                            r.isBatchedMesh && (C.setOptional(vt, r, "batchingTexture"), C.setValue(vt, "batchingTexture", r._matricesTexture, $));
                            const I = n.morphAttributes;
                            (void 0 !== I.position || void 0 !== I.normal || void 0 !== I.color && !0 === Y.isWebGL2) && ht.update(r, n, w);
                            (A || y.receiveShadow !== r.receiveShadow) && (y.receiveShadow = r.receiveShadow, C.setValue(vt, "receiveShadow", r.receiveShadow));
                            i.isMeshGouraudMaterial && null !== i.envMap && (R.envMap.value = l, R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                            A && (C.setValue(vt, "toneMappingExposure", _.toneMappingExposure), y.needsLights && (N = P, (D = R).ambientLightColor.needsUpdate = N, D.lightProbe.needsUpdate = N, D.directionalLights.needsUpdate = N, D.directionalLightShadows.needsUpdate = N, D.pointLights.needsUpdate = N, D.pointLightShadows.needsUpdate = N, D.spotLights.needsUpdate = N, D.spotLightShadows.needsUpdate = N, D.rectAreaLights.needsUpdate = N, D.hemisphereLights.needsUpdate = N), s && !0 === i.fog && st.refreshFogUniforms(R, s), st.refreshMaterialUniforms(R, i, O, L, H), _g.upload(vt, Nt(y), R, $));
                            var D, N;
                            i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (_g.upload(vt, Nt(y), R, $), i.uniformsNeedUpdate = !1);
                            i.isSpriteMaterial && C.setValue(vt, "center", r.center);
                            if (C.setValue(vt, "modelViewMatrix", r.modelViewMatrix), C.setValue(vt, "normalMatrix", r.normalMatrix), C.setValue(vt, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                                const t = i.uniformsGroups;
                                for (let e = 0, n = t.length; e < n; e++)
                                    if (Y.isWebGL2) {
                                        const n = t[e];
                                        gt.update(n, w), gt.bind(n, w)
                                    }
                            }
                            return w
                        }(t, e, n, i, r);
                    K.setMaterial(i, o);
                    let l = n.index,
                        c = 1;
                    if (!0 === i.wireframe) {
                        if (l = nt.getWireframeAttribute(n), void 0 === l) return;
                        c = 2
                    }
                    const u = n.drawRange,
                        h = n.attributes.position;
                    let d = u.start * c,
                        f = (u.start + u.count) * c;
                    null !== s && (d = Math.max(d, s.start * c), f = Math.min(f, (s.start + s.count) * c)), null !== l ? (d = Math.max(d, 0), f = Math.min(f, l.count)) : null != h && (d = Math.max(d, 0), f = Math.min(f, h.count));
                    const p = f - d;
                    if (p < 0 || p === 1 / 0) return;
                    let g;
                    mt.setup(r, i, a, n, l);
                    let v = dt;
                    if (null !== l && (g = et.get(l), v = ft, v.setIndex(g)), r.isMesh) !0 === i.wireframe ? (K.setLineWidth(i.wireframeLinewidth * X()), v.setMode(vt.LINES)) : v.setMode(vt.TRIANGLES);
                    else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1), K.setLineWidth(t * X()), r.isLineSegments ? v.setMode(vt.LINES) : r.isLineLoop ? v.setMode(vt.LINE_LOOP) : v.setMode(vt.LINE_STRIP)
                    } else r.isPoints ? v.setMode(vt.POINTS) : r.isSprite && v.setMode(vt.TRIANGLES);
                    if (r.isBatchedMesh) v.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                    else if (r.isInstancedMesh) v.renderInstances(d, p, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                            e = Math.min(n.instanceCount, t);
                        v.renderInstances(d, p, e)
                    } else v.render(d, p)
                }, this.compile = function (t, e, n = null) {
                    null === n && (n = t), m = at.get(n), m.init(), v.push(m), n.traverseVisible((function (t) {
                        t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t))
                    })), t !== n && t.traverseVisible((function (t) {
                        t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t))
                    })), m.setupLights(_._useLegacyLights);
                    const i = new Set;
                    return t.traverse((function (t) {
                        const e = t.material;
                        if (e)
                            if (Array.isArray(e))
                                for (let r = 0; r < e.length; r++) {
                                    const s = e[r];
                                    wt(s, n, t), i.add(s)
                                } else wt(e, n, t), i.add(e)
                    })), v.pop(), m = null, i
                }, this.compileAsync = function (t, e, n = null) {
                    const i = this.compile(t, e, n);
                    return new Promise((e => {
                        function n() {
                            i.forEach((function (t) {
                                J.get(t).currentProgram.isReady() && i.delete(t)
                            })), 0 !== i.size ? setTimeout(n, 10) : e(t)
                        }
                        null !== q.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }))
                };
                let Tt = null;

                function At() {
                    Ct.stop()
                }

                function Pt() {
                    Ct.start()
                }
                const Ct = new Pp;

                function Rt(t, e, n, i) {
                    if (!1 === t.visible) return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || F.intersectsSprite(t)) {
                            i && W.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
                            const e = it.update(t),
                                r = t.material;
                            r.visible && p.push(t, e, r, n, W.z, null)
                        }
                    } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || F.intersectsObject(t))) {
                        const e = it.update(t),
                            r = t.material;
                        if (i && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(), W.copy(t.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(), W.copy(e.boundingSphere.center)), W.applyMatrix4(t.matrixWorld).applyMatrix4(V)), Array.isArray(r)) {
                            const i = e.groups;
                            for (let s = 0, o = i.length; s < o; s++) {
                                const o = i[s],
                                    a = r[o.materialIndex];
                                a && a.visible && p.push(t, e, a, n, W.z, o)
                            }
                        } else r.visible && p.push(t, e, r, n, W.z, null)
                    }
                    const r = t.children;
                    for (let t = 0, s = r.length; t < s; t++) Rt(r[t], e, n, i)
                }

                function Lt(t, e, n, i) {
                    const r = t.opaque,
                        s = t.transmissive,
                        o = t.transparent;
                    m.setupLightsView(n), !0 === z && lt.setGlobalState(_.clippingPlanes, n), s.length > 0 && function (t, e, n, i) {
                        const r = !0 === n.isScene ? n.overrideMaterial : null;
                        if (null !== r) return;
                        const s = Y.isWebGL2;
                        null === H && (H = new Jh(1, 1, {
                            generateMipmaps: !0,
                            type: q.has("EXT_color_buffer_half_float") ? Nu : Ru,
                            minFilter: Cu,
                            samples: s ? 4 : 0
                        }));
                        _.getDrawingBufferSize(G), s ? H.setSize(G.x, G.y) : H.setSize(Eh(G.x), Eh(G.y));
                        const o = _.getRenderTarget();
                        _.setRenderTarget(H), _.getClearColor(P), C = _.getClearAlpha(), C < 1 && _.setClearColor(16777215, .5);
                        _.clear();
                        const a = _.toneMapping;
                        _.toneMapping = lu, Ot(t, n, i), $.updateMultisampleRenderTarget(H), $.updateRenderTargetMipmap(H);
                        let l = !1;
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = e[t],
                                s = r.object,
                                o = r.geometry,
                                a = r.material,
                                c = r.group;
                            if (2 === a.side && s.layers.test(i.layers)) {
                                const t = a.side;
                                a.side = iu, a.needsUpdate = !0, It(s, n, i, o, a, c), a.side = t, a.needsUpdate = !0, l = !0
                            }
                        }!0 === l && ($.updateMultisampleRenderTarget(H), $.updateRenderTargetMipmap(H));
                        _.setRenderTarget(o), _.setClearColor(P, C), _.toneMapping = a
                    }(r, s, e, n), i && K.viewport(w.copy(i)), r.length > 0 && Ot(r, e, n), s.length > 0 && Ot(s, e, n), o.length > 0 && Ot(o, e, n), K.buffers.depth.setTest(!0), K.buffers.depth.setMask(!0), K.buffers.color.setMask(!0), K.setPolygonOffset(!1)
                }

                function Ot(t, e, n) {
                    const i = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r],
                            o = s.object,
                            a = s.geometry,
                            l = null === i ? s.material : i,
                            c = s.group;
                        o.layers.test(n.layers) && It(o, e, n, a, l, c)
                    }
                }

                function It(t, e, n, i, r, s) {
                    t.onBeforeRender(_, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(_, e, n, i, t, s), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = iu, r.needsUpdate = !0, _.renderBufferDirect(n, e, i, r, t, s), r.side = nu, r.needsUpdate = !0, _.renderBufferDirect(n, e, i, r, t, s), r.side = 2) : _.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(_, e, n, i, r, s)
                }

                function Dt(t, e, n) {
                    !0 !== e.isScene && (e = j);
                    const i = J.get(t),
                        r = m.state.lights,
                        s = m.state.shadowsArray,
                        o = r.state.version,
                        a = rt.getParameters(t, r.state, s, e, n),
                        l = rt.getProgramCacheKey(a);
                    let c = i.programs;
                    i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? tt : Q).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Mt), c = new Map, i.programs = c);
                    let u = c.get(l);
                    if (void 0 !== u) {
                        if (i.currentProgram === u && i.lightsStateVersion === o) return Ut(t, a), u
                    } else a.uniforms = rt.getUniforms(t), t.onBuild(n, a, _), t.onBeforeCompile(a, _), u = rt.acquireProgram(a, l), c.set(l, u), i.uniforms = a.uniforms;
                    const h = i.uniforms;
                    return (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = lt.uniform), Ut(t, a), i.needsLights = function (t) {
                        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t), i.lightsStateVersion = o, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotLightMatrix.value = r.state.spotLightMatrix, h.spotLightMap.value = r.state.spotLightMap, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix), i.currentProgram = u, i.uniformsList = null, u
                }

                function Nt(t) {
                    if (null === t.uniformsList) {
                        const e = t.currentProgram.getUniforms();
                        t.uniformsList = _g.seqWithValue(e.seq, t.uniforms)
                    }
                    return t.uniformsList
                }

                function Ut(t, e) {
                    const n = J.get(t);
                    n.outputColorSpace = e.outputColorSpace, n.batching = e.batching, n.instancing = e.instancing, n.instancingColor = e.instancingColor, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
                }
                Ct.setAnimationLoop((function (t) {
                    Tt && Tt(t)
                })), "undefined" != typeof self && Ct.setContext(self), this.setAnimationLoop = function (t) {
                    Tt = t, xt.setAnimationLoop(t), null === t ? Ct.stop() : Ct.start()
                }, xt.addEventListener("sessionstart", At), xt.addEventListener("sessionend", Pt), this.render = function (t, e) {
                    if (void 0 !== e && !0 !== e.isCamera) return;
                    if (!0 === y) return;
                    !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === xt.enabled && !0 === xt.isPresenting && (!0 === xt.cameraAutoUpdate && xt.updateCamera(e), e = xt.getCamera()), !0 === t.isScene && t.onBeforeRender(_, t, e, S), m = at.get(t, v.length), m.init(), v.push(m), V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), F.setFromProjectionMatrix(V), B = this.localClippingEnabled, z = lt.init(this.clippingPlanes, B), p = ot.get(t, g.length), p.init(), g.push(p), Rt(t, e, 0, _.sortObjects), p.finish(), !0 === _.sortObjects && p.sort(I, D), this.info.render.frame++, !0 === z && lt.beginShadows();
                    const n = m.state.shadowsArray;
                    if (ct.render(n, t, e), !0 === z && lt.endShadows(), !0 === this.info.autoReset && this.info.reset(), ut.render(p, t), m.setupLights(_._useLegacyLights), e.isArrayCamera) {
                        const n = e.cameras;
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            Lt(p, t, i, i.viewport)
                        }
                    } else Lt(p, t, e);
                    null !== S && ($.updateMultisampleRenderTarget(S), $.updateRenderTargetMipmap(S)), !0 === t.isScene && t.onAfterRender(_, t, e), mt.resetDefaultState(), E = -1, M = null, v.pop(), m = v.length > 0 ? v[v.length - 1] : null, g.pop(), p = g.length > 0 ? g[g.length - 1] : null
                }, this.getActiveCubeFace = function () {
                    return x
                }, this.getActiveMipmapLevel = function () {
                    return b
                }, this.getRenderTarget = function () {
                    return S
                }, this.setRenderTargetTextures = function (t, e, n) {
                    J.get(t.texture).__webglTexture = e, J.get(t.depthTexture).__webglTexture = n;
                    const i = J.get(t);
                    i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === q.has("WEBGL_multisampled_render_to_texture") && (i.__useRenderToTexture = !1))
                }, this.setRenderTargetFramebuffer = function (t, e) {
                    const n = J.get(t);
                    n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
                }, this.setRenderTarget = function (t, e = 0, n = 0) {
                    S = t, x = e, b = n;
                    let i = !0,
                        r = null,
                        s = !1,
                        o = !1;
                    if (t) {
                        const a = J.get(t);
                        void 0 !== a.__useDefaultFramebuffer ? (K.bindFramebuffer(vt.FRAMEBUFFER, null), i = !1) : void 0 === a.__webglFramebuffer ? $.setupRenderTarget(t) : a.__hasExternalTextures && $.rebindTextures(t, J.get(t.texture).__webglTexture, J.get(t.depthTexture).__webglTexture);
                        const l = t.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (o = !0);
                        const c = J.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (r = Array.isArray(c[e]) ? c[e][n] : c[e], s = !0) : r = Y.isWebGL2 && t.samples > 0 && !1 === $.useMultisampledRTT(t) ? J.get(t).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, w.copy(t.viewport), T.copy(t.scissor), A = t.scissorTest
                    } else w.copy(N).multiplyScalar(O).floor(), T.copy(U).multiplyScalar(O).floor(), A = k;
                    if (K.bindFramebuffer(vt.FRAMEBUFFER, r) && Y.drawBuffers && i && K.drawBuffers(t, r), K.viewport(w), K.scissor(T), K.setScissorTest(A), s) {
                        const i = J.get(t.texture);
                        vt.framebufferTexture2D(vt.FRAMEBUFFER, vt.COLOR_ATTACHMENT0, vt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
                    } else if (o) {
                        const i = J.get(t.texture),
                            r = e || 0;
                        vt.framebufferTextureLayer(vt.FRAMEBUFFER, vt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                    }
                    E = -1
                }, this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
                    if (!t || !t.isWebGLRenderTarget) return;
                    let a = J.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                        K.bindFramebuffer(vt.FRAMEBUFFER, a);
                        try {
                            const o = t.texture,
                                a = o.format,
                                l = o.type;
                            if (a !== ku && pt.convert(a) !== vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_FORMAT)) return;
                            const c = l === Nu && (q.has("EXT_color_buffer_half_float") || Y.isWebGL2 && q.has("EXT_color_buffer_float"));
                            if (!(l === Ru || pt.convert(l) === vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_TYPE) || l === Du && (Y.isWebGL2 || q.has("OES_texture_float") || q.has("WEBGL_color_buffer_float")) || c)) return;
                            e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && vt.readPixels(e, n, i, r, pt.convert(a), pt.convert(l), s)
                        } finally {
                            const t = null !== S ? J.get(S).__webglFramebuffer : null;
                            K.bindFramebuffer(vt.FRAMEBUFFER, t)
                        }
                    }
                }, this.copyFramebufferToTexture = function (t, e, n = 0) {
                    const i = Math.pow(2, -n),
                        r = Math.floor(e.image.width * i),
                        s = Math.floor(e.image.height * i);
                    $.setTexture2D(e, 0), vt.copyTexSubImage2D(vt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s), K.unbindTexture()
                }, this.copyTextureToTexture = function (t, e, n, i = 0) {
                    const r = e.image.width,
                        s = e.image.height,
                        o = pt.convert(n.format),
                        a = pt.convert(n.type);
                    $.setTexture2D(n, 0), vt.pixelStorei(vt.UNPACK_FLIP_Y_WEBGL, n.flipY), vt.pixelStorei(vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), vt.pixelStorei(vt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? vt.texSubImage2D(vt.TEXTURE_2D, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? vt.compressedTexSubImage2D(vt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : vt.texSubImage2D(vt.TEXTURE_2D, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && vt.generateMipmap(vt.TEXTURE_2D), K.unbindTexture()
                }, this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
                    if (_.isWebGL1Renderer) return;
                    const s = t.max.x - t.min.x + 1,
                        o = t.max.y - t.min.y + 1,
                        a = t.max.z - t.min.z + 1,
                        l = pt.convert(i.format),
                        c = pt.convert(i.type);
                    let u;
                    if (i.isData3DTexture) $.setTexture3D(i, 0), u = vt.TEXTURE_3D;
                    else {
                        if (!i.isDataArrayTexture && !i.isCompressedArrayTexture) return;
                        $.setTexture2DArray(i, 0), u = vt.TEXTURE_2D_ARRAY
                    }
                    vt.pixelStorei(vt.UNPACK_FLIP_Y_WEBGL, i.flipY), vt.pixelStorei(vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), vt.pixelStorei(vt.UNPACK_ALIGNMENT, i.unpackAlignment);
                    const h = vt.getParameter(vt.UNPACK_ROW_LENGTH),
                        d = vt.getParameter(vt.UNPACK_IMAGE_HEIGHT),
                        f = vt.getParameter(vt.UNPACK_SKIP_PIXELS),
                        p = vt.getParameter(vt.UNPACK_SKIP_ROWS),
                        m = vt.getParameter(vt.UNPACK_SKIP_IMAGES),
                        g = n.isCompressedTexture ? n.mipmaps[r] : n.image;
                    vt.pixelStorei(vt.UNPACK_ROW_LENGTH, g.width), vt.pixelStorei(vt.UNPACK_IMAGE_HEIGHT, g.height), vt.pixelStorei(vt.UNPACK_SKIP_PIXELS, t.min.x), vt.pixelStorei(vt.UNPACK_SKIP_ROWS, t.min.y), vt.pixelStorei(vt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isData3DTexture ? vt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g.data) : n.isCompressedArrayTexture ? vt.compressedTexSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, g.data) : vt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g), vt.pixelStorei(vt.UNPACK_ROW_LENGTH, h), vt.pixelStorei(vt.UNPACK_IMAGE_HEIGHT, d), vt.pixelStorei(vt.UNPACK_SKIP_PIXELS, f), vt.pixelStorei(vt.UNPACK_SKIP_ROWS, p), vt.pixelStorei(vt.UNPACK_SKIP_IMAGES, m), 0 === r && i.generateMipmaps && vt.generateMipmap(u), K.unbindTexture()
                }, this.initTexture = function (t) {
                    t.isCubeTexture ? $.setTextureCube(t, 0) : t.isData3DTexture ? $.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? $.setTexture2DArray(t, 0) : $.setTexture2D(t, 0), K.unbindTexture()
                }, this.resetState = function () {
                    x = 0, b = 0, S = null, K.reset(), mt.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            get coordinateSystem() {
                return hh
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(t) {
                this._outputColorSpace = t;
                const e = this.getContext();
                e.drawingBufferColorSpace = t === eh ? "display-p3" : "srgb", e.unpackColorSpace = zh.workingColorSpace === nh ? "display-p3" : "srgb"
            }
            get outputEncoding() {
                return this.outputColorSpace === Qu ? Ju : 3e3
            }
            set outputEncoding(t) {
                this.outputColorSpace = t === Ju ? Qu : th
            }
            get useLegacyLights() {
                return this._useLegacyLights
            }
            set useLegacyLights(t) {
                this._useLegacyLights = t
            }
        }(class extends hv {}).prototype.isWebGL1Renderer = !0;
        class dv extends nf {
            constructor() {
                super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e
            }
        }
        class fv {
            constructor(t, e) {
                this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = lh, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.version = 0, this.uuid = _h()
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            get updateRange() {
                return this._updateRange
            }
            setUsage(t) {
                return this.usage = t, this
            }
            addUpdateRange(t, e) {
                this.updateRanges.push({
                    start: t,
                    count: e
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
            }
            copyAt(t, e, n) {
                t *= this.stride, n *= e.stride;
                for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = _h()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(e, this.stride);
                return n.setUsage(this.usage), n
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = _h()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const pv = new ed;
        class mv {
            constructor(t, e, n, i = !1) {
                this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++) pv.fromBufferAttribute(this, e), pv.applyMatrix4(t), this.setXYZ(e, pv.x, pv.y, pv.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) pv.fromBufferAttribute(this, e), pv.applyNormalMatrix(t), this.setXYZ(e, pv.x, pv.y, pv.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) pv.fromBufferAttribute(this, e), pv.transformDirection(t), this.setXYZ(e, pv.x, pv.y, pv.z);
                return this
            }
            setX(t, e) {
                return this.normalized && (e = wh(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
            }
            setY(t, e) {
                return this.normalized && (e = wh(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
            }
            setZ(t, e) {
                return this.normalized && (e = wh(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
            }
            setW(t, e) {
                return this.normalized && (e = wh(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
            }
            getX(t) {
                let e = this.data.array[t * this.data.stride + this.offset];
                return this.normalized && (e = Mh(e, this.array)), e
            }
            getY(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 1];
                return this.normalized && (e = Mh(e, this.array)), e
            }
            getZ(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 2];
                return this.normalized && (e = Mh(e, this.array)), e
            }
            getW(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 3];
                return this.normalized && (e = Mh(e, this.array)), e
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = wh(e, this.array), n = wh(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
            }
            setXYZ(t, e, n, i) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = wh(e, this.array), n = wh(n, this.array), i = wh(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
            }
            setXYZW(t, e, n, i, r) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = wh(e, this.array), n = wh(n, this.array), i = wh(i, this.array), r = wh(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
            }
            clone(t) {
                if (void 0 === t) {
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return new Of(new this.array.constructor(t), this.itemSize, this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new mv(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(t) {
                if (void 0 === t) {
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const gv = new ed,
            vv = new Kh,
            _v = new Kh,
            yv = new ed,
            xv = new Ld,
            bv = new ed,
            Sv = new Sd,
            Ev = new Ld,
            Mv = new Rd;
        class wv extends ap {
            constructor(t, e) {
                super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = mu, this.bindMatrix = new Ld, this.bindMatrixInverse = new Ld, this.boundingBox = null, this.boundingSphere = null
            }
            computeBoundingBox() {
                const t = this.geometry;
                null === this.boundingBox && (this.boundingBox = new rd), this.boundingBox.makeEmpty();
                const e = t.getAttribute("position");
                for (let t = 0; t < e.count; t++) this.getVertexPosition(t, bv), this.boundingBox.expandByPoint(bv)
            }
            computeBoundingSphere() {
                const t = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new Sd), this.boundingSphere.makeEmpty();
                const e = t.getAttribute("position");
                for (let t = 0; t < e.count; t++) this.getVertexPosition(t, bv), this.boundingSphere.expandByPoint(bv)
            }
            copy(t, e) {
                return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            }
            raycast(t, e) {
                const n = this.material,
                    i = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), Sv.copy(this.boundingSphere), Sv.applyMatrix4(i), !1 !== t.ray.intersectsSphere(Sv) && (Ev.copy(i).invert(), Mv.copy(t.ray).applyMatrix4(Ev), null !== this.boundingBox && !1 === Mv.intersectsBox(this.boundingBox) || this._computeIntersections(t, e, Mv)))
            }
            getVertexPosition(t, e) {
                return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
            }
            bind(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new Kh,
                    e = this.geometry.attributes.skinWeight;
                for (let n = 0, i = e.count; n < i; n++) {
                    t.fromBufferAttribute(e, n);
                    const i = 1 / t.manhattanLength();
                    i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.bindMode === mu ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
            }
            applyBoneTransform(t, e) {
                const n = this.skeleton,
                    i = this.geometry;
                vv.fromBufferAttribute(i.attributes.skinIndex, t), _v.fromBufferAttribute(i.attributes.skinWeight, t), gv.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const i = _v.getComponent(t);
                    if (0 !== i) {
                        const r = vv.getComponent(t);
                        xv.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(yv.copy(gv).applyMatrix4(xv), i)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
            boneTransform(t, e) {
                return this.applyBoneTransform(t, e)
            }
        }
        class Tv extends nf {
            constructor() {
                super(), this.isBone = !0, this.type = "Bone"
            }
        }
        class Av extends Yh {
            constructor(t = null, e = 1, n = 1, i, r, s, o, a, l = 1003, c = 1003, u, h) {
                super(null, s, o, a, l, c, i, r, u, h), this.isDataTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        const Pv = new Ld,
            Cv = new Ld;
        class Rv {
            constructor(t = [], e = []) {
                this.uuid = _h(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init()
            }
            init() {
                const t = this.bones,
                    e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                else if (t.length !== e.length) {
                    this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Ld)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new Ld;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                }
            }
            pose() {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            }
            update() {
                const t = this.bones,
                    e = this.boneInverses,
                    n = this.boneMatrices,
                    i = this.boneTexture;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i] ? t[i].matrixWorld : Cv;
                    Pv.multiplyMatrices(r, e[i]), Pv.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new Rv(this.bones, this.boneInverses)
            }
            computeBoneTexture() {
                let t = Math.sqrt(4 * this.bones.length);
                t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
                const e = new Float32Array(t * t * 4);
                e.set(this.boneMatrices);
                const n = new Av(e, t, t, ku, Du);
                return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this
            }
            getBoneByName(t) {
                for (let e = 0, n = this.bones.length; e < n; e++) {
                    const n = this.bones[e];
                    if (n.name === t) return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
            }
            fromJSON(t, e) {
                this.uuid = t.uuid;
                for (let n = 0, i = t.bones.length; n < i; n++) {
                    let i = e[t.bones[n]];
                    void 0 === i && (i = new Tv), this.bones.push(i), this.boneInverses.push((new Ld).fromArray(t.boneInverses[n]))
                }
                return this.init(), this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones,
                    n = this.boneInverses;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i];
                    t.bones.push(r.uuid);
                    const s = n[i];
                    t.boneInverses.push(s.toArray())
                }
                return t
            }
        }
        class Lv extends Of {
            constructor(t, e, n, i = 1) {
                super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
            }
            copy(t) {
                return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
            }
            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }
        const Ov = new Ld,
            Iv = new Ld,
            Dv = [],
            Nv = new rd,
            Uv = new Ld,
            kv = new ap,
            Fv = new Sd;
        class zv extends ap {
            constructor(t, e, n) {
                super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new Lv(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                for (let t = 0; t < n; t++) this.setMatrixAt(t, Uv)
            }
            computeBoundingBox() {
                const t = this.geometry,
                    e = this.count;
                null === this.boundingBox && (this.boundingBox = new rd), null === t.boundingBox && t.computeBoundingBox(), this.boundingBox.makeEmpty();
                for (let n = 0; n < e; n++) this.getMatrixAt(n, Ov), Nv.copy(t.boundingBox).applyMatrix4(Ov), this.boundingBox.union(Nv)
            }
            computeBoundingSphere() {
                const t = this.geometry,
                    e = this.count;
                null === this.boundingSphere && (this.boundingSphere = new Sd), null === t.boundingSphere && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                for (let n = 0; n < e; n++) this.getMatrixAt(n, Ov), Fv.copy(t.boundingSphere).applyMatrix4(Ov), this.boundingSphere.union(Fv)
            }
            copy(t, e) {
                return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            raycast(t, e) {
                const n = this.matrixWorld,
                    i = this.count;
                if (kv.geometry = this.geometry, kv.material = this.material, void 0 !== kv.material && (null === this.boundingSphere && this.computeBoundingSphere(), Fv.copy(this.boundingSphere), Fv.applyMatrix4(n), !1 !== t.ray.intersectsSphere(Fv)))
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, Ov), Iv.multiplyMatrices(n, Ov), kv.matrixWorld = Iv, kv.raycast(t, Dv);
                        for (let t = 0, n = Dv.length; t < n; t++) {
                            const n = Dv[t];
                            n.instanceId = r, n.object = this, e.push(n)
                        }
                        Dv.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new Lv(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Bv extends Ef {
            constructor(t) {
                super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new xf(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
            }
        }
        const Hv = new ed,
            Vv = new ed,
            Gv = new Ld,
            Wv = new Rd,
            jv = new Sd;
        class Xv extends nf {
            constructor(t = new Gf, e = new Bv) {
                super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [0];
                    for (let t = 1, i = e.count; t < i; t++) Hv.fromBufferAttribute(e, t - 1), Vv.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Hv.distanceTo(Vv);
                    t.setAttribute("lineDistance", new Nf(n, 1))
                }
                return this
            }
            raycast(t, e) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = t.params.Line.threshold,
                    s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), jv.copy(n.boundingSphere), jv.applyMatrix4(i), jv.radius += r, !1 === t.ray.intersectsSphere(jv)) return;
                Gv.copy(i).invert(), Wv.copy(t.ray).applyMatrix4(Gv);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = o * o,
                    l = new ed,
                    c = new ed,
                    u = new ed,
                    h = new ed,
                    d = this.isLineSegments ? 2 : 1,
                    f = n.index,
                    p = n.attributes.position;
                if (null !== f) {
                    for (let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1; n < i; n += d) {
                        const i = f.getX(n),
                            r = f.getX(n + 1);
                        l.fromBufferAttribute(p, i), c.fromBufferAttribute(p, r);
                        if (Wv.distanceSqToSegment(l, c, h, u) > a) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const s = t.ray.origin.distanceTo(h);
                        s < t.near || s > t.far || e.push({
                            distance: s,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    for (let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1; n < i; n += d) {
                        l.fromBufferAttribute(p, n), c.fromBufferAttribute(p, n + 1);
                        if (Wv.distanceSqToSegment(l, c, h, u) > a) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const i = t.ray.origin.distanceTo(h);
                        i < t.near || i > t.far || e.push({
                            distance: i,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }
        const qv = new ed,
            Yv = new ed;
        class Kv extends Xv {
            constructor(t, e) {
                super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [];
                    for (let t = 0, i = e.count; t < i; t += 2) qv.fromBufferAttribute(e, t), Yv.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + qv.distanceTo(Yv);
                    t.setAttribute("lineDistance", new Nf(n, 1))
                }
                return this
            }
        }
        class Zv extends Xv {
            constructor(t, e) {
                super(t, e), this.isLineLoop = !0, this.type = "LineLoop"
            }
        }
        class Jv extends Ef {
            constructor(t) {
                super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new xf(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
            }
        }
        const $v = new Ld,
            Qv = new Rd,
            t_ = new Sd,
            e_ = new ed;
        class n_ extends nf {
            constructor(t = new Gf, e = new Jv) {
                super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
            }
            raycast(t, e) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = t.params.Points.threshold,
                    s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), t_.copy(n.boundingSphere), t_.applyMatrix4(i), t_.radius += r, !1 === t.ray.intersectsSphere(t_)) return;
                $v.copy(i).invert(), Qv.copy(t.ray).applyMatrix4($v);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = o * o,
                    l = n.index,
                    c = n.attributes.position;
                if (null !== l) {
                    for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) {
                        const r = l.getX(n);
                        e_.fromBufferAttribute(c, r), i_(e_, r, a, i, t, e, this)
                    }
                } else {
                    for (let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count); n < r; n++) e_.fromBufferAttribute(c, n), i_(e_, n, a, i, t, e, this)
                }
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }

        function i_(t, e, n, i, r, s, o) {
            const a = Qv.distanceSqToPoint(t);
            if (a < n) {
                const n = new ed;
                Qv.closestPointToPoint(t, n), n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far) return;
                s.push({
                    distance: l,
                    distanceToRay: Math.sqrt(a),
                    point: n,
                    index: e,
                    face: null,
                    object: o
                })
            }
        }
        class r_ extends Yh {
            constructor(t, e, n, i, r, s, o, a, l) {
                super(t, e, n, i, r, s, o, a, l), this.isVideoTexture = !0, this.minFilter = void 0 !== s ? s : Au, this.magFilter = void 0 !== r ? r : Au, this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                    c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                }))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const t = this.image;
                !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class s_ extends Ef {
            constructor(t) {
                super(), this.isMeshStandardMaterial = !0, this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new xf(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xf(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ah(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
            }
        }
        class o_ extends s_ {
            constructor(t) {
                super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ah(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function () {
                        return yh(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function (t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new xf(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new xf(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new xf(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(t) {
                this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(t) {
                this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(t) {
                this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t
            }
            get sheen() {
                return this._sheen
            }
            set sheen(t) {
                this._sheen > 0 != t > 0 && this.version++, this._sheen = t
            }
            get transmission() {
                return this._transmission
            }
            set transmission(t) {
                this._transmission > 0 != t > 0 && this.version++, this._transmission = t
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
            }
        }

        function a_(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        }

        function l_(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        }

        function c_(t) {
            const e = t.length,
                n = new Array(e);
            for (let t = 0; t !== e; ++t) n[t] = t;
            return n.sort((function (e, n) {
                return t[e] - t[n]
            })), n
        }

        function u_(t, e, n) {
            const i = t.length,
                r = new t.constructor(i);
            for (let s = 0, o = 0; o !== i; ++s) {
                const i = n[s] * e;
                for (let n = 0; n !== e; ++n) r[o++] = t[i + n]
            }
            return r
        }

        function h_(t, e, n, i) {
            let r = 1,
                s = t[0];
            for (; void 0 !== s && void 0 === s[i];) s = t[r++];
            if (void 0 === s) return;
            let o = s[i];
            if (void 0 !== o)
                if (Array.isArray(o))
                    do {
                        o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++]
                    } while (void 0 !== s);
                else if (void 0 !== o.toArray)
                do {
                    o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++]
                } while (void 0 !== s);
            else
                do {
                    o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++]
                } while (void 0 !== s)
        }
        class d_ {
            constructor(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex,
                    i = e[n],
                    r = e[n - 1];
                t: {
                    e: {
                        let s;n: {
                            i: if (!(t < i)) {
                                for (let s = n + 2;;) {
                                    if (void 0 === i) {
                                        if (t < r) break i;
                                        return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                    }
                                    if (n === s) break;
                                    if (r = i, i = e[++n], t < i) break e
                                }
                                s = e.length;
                                break n
                            }if (t >= r) break t; {
                                const o = e[1];
                                t < o && (n = 2, r = o);
                                for (let s = n - 2;;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (n === s) break;
                                    if (i = r, r = e[--n - 1], t >= r) break e
                                }
                                s = n, n = 0
                            }
                        }
                        for (; n < s;) {
                            const i = n + s >>> 1;
                            t < e[i] ? s = i : n = i + 1
                        }
                        if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0,
                        this.copySampleValue_(0);
                        if (void 0 === i) return n = e.length,
                        this._cachedIndex = n,
                        this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = t * i;
                for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class f_ extends d_ {
            constructor(t, e, n, i) {
                super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: Yu,
                    endingEnd: Yu
                }
            }
            intervalChanged_(t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2,
                    s = t + 1,
                    o = i[r],
                    a = i[s];
                if (void 0 === o) switch (this.getSettings_().endingStart) {
                    case Ku:
                        r = t, o = 2 * e - n;
                        break;
                    case Zu:
                        r = i.length - 2, o = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t, o = n
                }
                if (void 0 === a) switch (this.getSettings_().endingEnd) {
                    case Ku:
                        s = t, a = 2 * n - e;
                        break;
                    case Zu:
                        s = 1, a = n + i[1] - i[0];
                        break;
                    default:
                        s = t - 1, a = e
                }
                const l = .5 * (n - e),
                    c = this.valueSize;
                this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = s * c
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = t * o,
                    l = a - o,
                    c = this._offsetPrev,
                    u = this._offsetNext,
                    h = this._weightPrev,
                    d = this._weightNext,
                    f = (n - e) / (i - e),
                    p = f * f,
                    m = p * f,
                    g = -h * m + 2 * h * p - h * f,
                    v = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1,
                    _ = (-1 - d) * m + (1.5 + d) * p + .5 * f,
                    y = d * m - d * p;
                for (let t = 0; t !== o; ++t) r[t] = g * s[c + t] + v * s[l + t] + _ * s[a + t] + y * s[u + t];
                return r
            }
        }
        class p_ extends d_ {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = t * o,
                    l = a - o,
                    c = (n - e) / (i - e),
                    u = 1 - c;
                for (let t = 0; t !== o; ++t) r[t] = s[l + t] * u + s[a + t] * c;
                return r
            }
        }
        class m_ extends d_ {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class g_ {
            constructor(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = a_(e, this.TimeBufferType), this.values = a_(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: a_(t.times, Array),
                        values: a_(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new m_(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new p_(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new f_(this.times, this.values, this.getValueSize(), t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                    case ju:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case Xu:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case qu:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return this
                }
                return this.createInterpolant = e, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return ju;
                    case this.InterpolantFactoryMethodLinear:
                        return Xu;
                    case this.InterpolantFactoryMethodSmooth:
                        return qu
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times,
                    i = n.length;
                let r = 0,
                    s = i - 1;
                for (; r !== i && n[r] < t;) ++r;
                for (; - 1 !== s && n[s] > e;) --s;
                if (++s, 0 !== r || s !== i) {
                    r >= s && (s = Math.max(s, 1), r = s - 1);
                    const t = this.getValueSize();
                    this.times = n.slice(r, s), this.values = this.values.slice(r * t, s * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (t = !1);
                const n = this.times,
                    i = this.values,
                    r = n.length;
                0 === r && (t = !1);
                let s = null;
                for (let e = 0; e !== r; e++) {
                    const i = n[e];
                    if ("number" == typeof i && isNaN(i)) {
                        t = !1;
                        break
                    }
                    if (null !== s && s > i) {
                        t = !1;
                        break
                    }
                    s = i
                }
                if (void 0 !== i && l_(i))
                    for (let e = 0, n = i.length; e !== n; ++e) {
                        const n = i[e];
                        if (isNaN(n)) {
                            t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = this.times.slice(),
                    e = this.values.slice(),
                    n = this.getValueSize(),
                    i = this.getInterpolation() === qu,
                    r = t.length - 1;
                let s = 1;
                for (let o = 1; o < r; ++o) {
                    let r = !1;
                    const a = t[o];
                    if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                        if (i) r = !0;
                        else {
                            const t = o * n,
                                i = t - n,
                                s = t + n;
                            for (let o = 0; o !== n; ++o) {
                                const n = e[t + o];
                                if (n !== e[i + o] || n !== e[s + o]) {
                                    r = !0;
                                    break
                                }
                            }
                        } if (r) {
                        if (o !== s) {
                            t[s] = t[o];
                            const i = o * n,
                                r = s * n;
                            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                        }++s
                    }
                }
                if (r > 0) {
                    t[s] = t[r];
                    for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];
                    ++s
                }
                return s !== t.length ? (this.times = t.slice(0, s), this.values = e.slice(0, s * n)) : (this.times = t, this.values = e), this
            }
            clone() {
                const t = this.times.slice(),
                    e = this.values.slice(),
                    n = new(0, this.constructor)(this.name, t, e);
                return n.createInterpolant = this.createInterpolant, n
            }
        }
        g_.prototype.TimeBufferType = Float32Array, g_.prototype.ValueBufferType = Float32Array, g_.prototype.DefaultInterpolation = Xu;
        class v_ extends g_ {}
        v_.prototype.ValueTypeName = "bool", v_.prototype.ValueBufferType = Array, v_.prototype.DefaultInterpolation = ju, v_.prototype.InterpolantFactoryMethodLinear = void 0, v_.prototype.InterpolantFactoryMethodSmooth = void 0;
        class __ extends g_ {}
        __.prototype.ValueTypeName = "color";
        class y_ extends g_ {}
        y_.prototype.ValueTypeName = "number";
        class x_ extends d_ {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = (n - e) / (i - e);
                let l = t * o;
                for (let t = l + o; l !== t; l += 4) td.slerpFlat(r, 0, s, l - o, s, l, a);
                return r
            }
        }
        class b_ extends g_ {
            InterpolantFactoryMethodLinear(t) {
                return new x_(this.times, this.values, this.getValueSize(), t)
            }
        }
        b_.prototype.ValueTypeName = "quaternion", b_.prototype.DefaultInterpolation = Xu, b_.prototype.InterpolantFactoryMethodSmooth = void 0;
        class S_ extends g_ {}
        S_.prototype.ValueTypeName = "string", S_.prototype.ValueBufferType = Array, S_.prototype.DefaultInterpolation = ju, S_.prototype.InterpolantFactoryMethodLinear = void 0, S_.prototype.InterpolantFactoryMethodSmooth = void 0;
        class E_ extends g_ {}
        E_.prototype.ValueTypeName = "vector";
        class M_ {
            constructor(t, e = -1, n, i = 2500) {
                this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = _h(), this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = [],
                    n = t.tracks,
                    i = 1 / (t.fps || 1);
                for (let t = 0, r = n.length; t !== r; ++t) e.push(w_(n[t]).scale(i));
                const r = new this(t.name, t.duration, e, t.blendMode);
                return r.uuid = t.uuid, r
            }
            static toJSON(t) {
                const e = [],
                    n = t.tracks,
                    i = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                        blendMode: t.blendMode
                    };
                for (let t = 0, i = n.length; t !== i; ++t) e.push(g_.toJSON(n[t]));
                return i
            }
            static CreateFromMorphTargetSequence(t, e, n, i) {
                const r = e.length,
                    s = [];
                for (let t = 0; t < r; t++) {
                    let o = [],
                        a = [];
                    o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                    const l = c_(o);
                    o = u_(o, 1, l), a = u_(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new y_(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
                }
                return new this(t, -1, s)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e) return n[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const i = {},
                    r = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e],
                        s = n.name.match(r);
                    if (s && s.length > 1) {
                        const t = s[1];
                        let e = i[t];
                        e || (i[t] = e = []), e.push(n)
                    }
                }
                const s = [];
                for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                return s
            }
            static parseAnimation(t, e) {
                if (!t) return null;
                const n = function (t, e, n, i, r) {
                        if (0 !== n.length) {
                            const s = [],
                                o = [];
                            h_(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                        }
                    },
                    i = [],
                    r = t.name || "default",
                    s = t.fps || 30,
                    o = t.blendMode;
                let a = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const r = l[t].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < r.length; e++)
                                if (r[e].morphTargets)
                                    for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = [],
                                    s = [];
                                for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                    const i = r[e];
                                    t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new y_(".morphTargetInfluence[" + n + "]", t, s))
                            }
                            a = t.length * s
                        } else {
                            const s = ".bones[" + e[t].name + "]";
                            n(E_, s + ".position", r, "pos", i), n(b_, s + ".quaternion", r, "rot", i), n(E_, s + ".scale", r, "scl", i)
                        }
                }
                if (0 === i.length) return null;
                return new this(r, a, i, o)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t, this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new this.constructor(this.name, this.duration, t, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function w_(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function (t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return y_;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return E_;
                    case "color":
                        return __;
                    case "quaternion":
                        return b_;
                    case "bool":
                    case "boolean":
                        return v_;
                    case "string":
                        return S_
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = [],
                    n = [];
                h_(t.keys, e, n, "value"), t.times = e, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }
        const T_ = {
            enabled: !1,
            files: {},
            add: function (t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function (t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function (t) {
                delete this.files[t]
            },
            clear: function () {
                this.files = {}
            }
        };
        class A_ {
            constructor(t, e, n) {
                const i = this;
                let r, s = !1,
                    o = 0,
                    a = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
                    a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), s = !0
                }, this.itemEnd = function (t) {
                    o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (s = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function (t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function (t) {
                    return r ? r(t) : t
                }, this.setURLModifier = function (t) {
                    return r = t, this
                }, this.addHandler = function (t, e) {
                    return l.push(t, e), this
                }, this.removeHandler = function (t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2), this
                }, this.getHandler = function (t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e],
                            i = l[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return i
                    }
                    return null
                }
            }
        }
        const P_ = new A_;
        class C_ {
            constructor(t) {
                this.manager = void 0 !== t ? t : P_, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function (i, r) {
                    n.load(t, i, e, r)
                }))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t, this
            }
            setWithCredentials(t) {
                return this.withCredentials = t, this
            }
            setPath(t) {
                return this.path = t, this
            }
            setResourcePath(t) {
                return this.resourcePath = t, this
            }
            setRequestHeader(t) {
                return this.requestHeader = t, this
            }
        }
        C_.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const R_ = {};
        class L_ extends Error {
            constructor(t, e) {
                super(t), this.response = e
            }
        }
        class O_ extends C_ {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = T_.get(t);
                if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                    e && e(r), this.manager.itemEnd(t)
                }), 0), r;
                if (void 0 !== R_[t]) return void R_[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
                R_[t] = [], R_[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
                const s = new Request(t, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    }),
                    o = this.mimeType,
                    a = this.responseType;
                fetch(s).then((e => {
                    if (200 === e.status || 0 === e.status) {
                        if (e.status, "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                        const n = R_[t],
                            i = e.body.getReader(),
                            r = e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
                            s = r ? parseInt(r) : 0,
                            o = 0 !== s;
                        let a = 0;
                        const l = new ReadableStream({
                            start(t) {
                                ! function e() {
                                    i.read().then((({
                                        done: i,
                                        value: r
                                    }) => {
                                        if (i) t.close();
                                        else {
                                            a += r.byteLength;
                                            const i = new ProgressEvent("progress", {
                                                lengthComputable: o,
                                                loaded: a,
                                                total: s
                                            });
                                            for (let t = 0, e = n.length; t < e; t++) {
                                                const e = n[t];
                                                e.onProgress && e.onProgress(i)
                                            }
                                            t.enqueue(r), e()
                                        }
                                    }))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new L_(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
                })).then((t => {
                    switch (a) {
                        case "arraybuffer":
                            return t.arrayBuffer();
                        case "blob":
                            return t.blob();
                        case "document":
                            return t.text().then((t => (new DOMParser).parseFromString(t, o)));
                        case "json":
                            return t.json();
                        default:
                            if (void 0 === o) return t.text(); {
                                const e = /charset="?([^;"\s]*)"?/i.exec(o),
                                    n = e && e[1] ? e[1].toLowerCase() : void 0,
                                    i = new TextDecoder(n);
                                return t.arrayBuffer().then((t => i.decode(t)))
                            }
                    }
                })).then((e => {
                    T_.add(t, e);
                    const n = R_[t];
                    delete R_[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onLoad && i.onLoad(e)
                    }
                })).catch((e => {
                    const n = R_[t];
                    if (void 0 === n) throw this.manager.itemError(t), e;
                    delete R_[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    this.manager.itemError(t)
                })).finally((() => {
                    this.manager.itemEnd(t)
                })), this.manager.itemStart(t)
            }
            setResponseType(t) {
                return this.responseType = t, this
            }
            setMimeType(t) {
                return this.mimeType = t, this
            }
        }
        class I_ extends C_ {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this,
                    s = T_.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                const o = Lh("img");

                function a() {
                    c(), T_.add(t, this), e && e(this), r.manager.itemEnd(t)
                }

                function l(e) {
                    c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                }

                function c() {
                    o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1)
                }
                return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
            }
        }
        class D_ extends C_ {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = this,
                    s = new Av,
                    o = new O_(this.manager);
                return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(t, (function (t) {
                    let n;
                    try {
                        n = r.parse(t)
                    } catch (t) {
                        if (void 0 === i) return;
                        i(t)
                    }
                    void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : Su, s.wrapT = void 0 !== n.wrapT ? n.wrapT : Su, s.magFilter = void 0 !== n.magFilter ? n.magFilter : Au, s.minFilter = void 0 !== n.minFilter ? n.minFilter : Au, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace ? s.colorSpace = n.colorSpace : void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = Cu), 1 === n.mipmapCount && (s.minFilter = Au), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n)
                }), n, i), s
            }
        }
        class N_ extends C_ {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = new Yh,
                    s = new I_(this.manager);
                return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function (t) {
                    r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                }), n, i), r
            }
        }
        class U_ extends nf {
            constructor(t, e = 1) {
                super(), this.isLight = !0, this.type = "Light", this.color = new xf(t), this.intensity = e
            }
            dispose() {}
            copy(t, e) {
                return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }
        const k_ = new Ld,
            F_ = new ed,
            z_ = new ed;
        class B_ {
            constructor(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ah(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ld, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ap, this._frameExtents = new Ah(1, 1), this._viewportCount = 1, this._viewports = [new Kh(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = this.matrix;
                F_.setFromMatrixPosition(t.matrixWorld), e.position.copy(F_), z_.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(z_), e.updateMatrixWorld(), k_.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(k_), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(k_)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }
        class H_ extends B_ {
            constructor() {
                super(new gp(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = 2 * vh * t.angle * this.focus,
                    i = this.mapSize.width / this.mapSize.height,
                    r = t.distance || e.far;
                n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t), this.focus = t.focus, this
            }
        }
        class V_ extends U_ {
            constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 2) {
                super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(nf.DEFAULT_UP), this.updateMatrix(), this.target = new nf, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.map = null, this.shadow = new H_
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t, e) {
                return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }
        const G_ = new Ld,
            W_ = new ed,
            j_ = new ed;
        class X_ extends B_ {
            constructor() {
                super(new gp(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ah(4, 2), this._viewportCount = 6, this._viewports = [new Kh(2, 1, 1, 1), new Kh(0, 1, 1, 1), new Kh(3, 1, 1, 1), new Kh(1, 1, 1, 1), new Kh(3, 0, 1, 1), new Kh(1, 0, 1, 1)], this._cubeDirections = [new ed(1, 0, 0), new ed(-1, 0, 0), new ed(0, 0, 1), new ed(0, 0, -1), new ed(0, 1, 0), new ed(0, -1, 0)], this._cubeUps = [new ed(0, 1, 0), new ed(0, 1, 0), new ed(0, 1, 0), new ed(0, 1, 0), new ed(0, 0, 1), new ed(0, 0, -1)]
            }
            updateMatrices(t, e = 0) {
                const n = this.camera,
                    i = this.matrix,
                    r = t.distance || n.far;
                r !== n.far && (n.far = r, n.updateProjectionMatrix()), W_.setFromMatrixPosition(t.matrixWorld), n.position.copy(W_), j_.copy(n.position), j_.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(j_), n.updateMatrixWorld(), i.makeTranslation(-W_.x, -W_.y, -W_.z), G_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(G_)
            }
        }
        class q_ extends U_ {
            constructor(t, e, n = 0, i = 2) {
                super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new X_
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t, e) {
                return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }
        class Y_ extends B_ {
            constructor() {
                super(new Hp(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
            }
        }
        class K_ extends U_ {
            constructor(t, e) {
                super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(nf.DEFAULT_UP), this.updateMatrix(), this.target = new nf, this.shadow = new Y_
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }
        class Z_ extends U_ {
            constructor(t, e) {
                super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight"
            }
        }
        class J_ {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                let e = "";
                for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            }
            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.slice(0, e + 1)
            }
            static resolveURL(t, e) {
                return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }
        }
        class $_ extends C_ {
            constructor(t) {
                super(t), this.isImageBitmapLoader = !0, this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t, this
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this,
                    s = T_.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), s.then ? void s.then((n => {
                    e && e(n), r.manager.itemEnd(t)
                })).catch((t => {
                    i && i(t)
                })) : (setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s);
                const o = {};
                o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader;
                const a = fetch(t, o).then((function (t) {
                    return t.blob()
                })).then((function (t) {
                    return createImageBitmap(t, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                })).then((function (n) {
                    return T_.add(t, n), e && e(n), r.manager.itemEnd(t), n
                })).catch((function (e) {
                    i && i(e), T_.remove(t), r.manager.itemError(t), r.manager.itemEnd(t)
                }));
                T_.add(t, a), r.manager.itemStart(t)
            }
        }
        const Q_ = "\\[\\]\\.:\\/",
            ty = new RegExp("[" + Q_ + "]", "g"),
            ey = "[^" + Q_ + "]",
            ny = "[^" + Q_.replace("\\.", "") + "]",
            iy = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", ey) + /(WCOD+)?/.source.replace("WCOD", ny) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ey) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ey) + "$"),
            ry = ["material", "materials", "bones", "map"];
        class sy {
            constructor(t, e, n) {
                this.path = e, this.parsedPath = n || sy.parseTrackName(e), this.node = sy.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new sy.Composite(t, e, n) : new sy(t, e, n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(ty, "")
            }
            static parseTrackName(t) {
                const e = iy.exec(t);
                if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1); - 1 !== ry.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    const n = function (t) {
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                if (r.name === e || r.uuid === e) return r;
                                const s = n(r.children);
                                if (s) return s
                            }
                            return null
                        },
                        i = n(t.children);
                    if (i) return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(), this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(), this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath,
                    n = e.objectName,
                    i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = sy.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return;
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return;
                            if (!t.material.materials) return;
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return;
                            t = t.skeleton.bones;
                            for (let e = 0; e < t.length; e++)
                                if (t[e].name === i) {
                                    i = e;
                                    break
                                } break;
                        case "map":
                            if ("map" in t) {
                                t = t.map;
                                break
                            }
                            if (!t.material) return;
                            if (!t.material.map) return;
                            t = t.material.map;
                            break;
                        default:
                            if (void 0 === t[n]) return;
                            t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i]) return;
                        t = t[i]
                    }
                }
                const s = t[i];
                if (void 0 === s) {
                    e.nodeName;
                    return
                }
                let o = this.Versioning.None;
                this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                let a = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry) return;
                        if (!t.geometry.morphAttributes) return;
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        sy.Composite = class {
            constructor(t, e, n) {
                const i = n || sy.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
            }
        }, sy.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, sy.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, sy.prototype.GetterByBindingType = [sy.prototype._getValue_direct, sy.prototype._getValue_array, sy.prototype._getValue_arrayElement, sy.prototype._getValue_toArray], sy.prototype.SetterByBindingTypeAndVersioning = [[sy.prototype._setValue_direct, sy.prototype._setValue_direct_setNeedsUpdate, sy.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [sy.prototype._setValue_array, sy.prototype._setValue_array_setNeedsUpdate, sy.prototype._setValue_array_setMatrixWorldNeedsUpdate], [sy.prototype._setValue_arrayElement, sy.prototype._setValue_arrayElement_setNeedsUpdate, sy.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [sy.prototype._setValue_fromArray, sy.prototype._setValue_fromArray_setNeedsUpdate, sy.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        new Float32Array(1);

        function oy(t, e) {
            if (0 === e) return t;
            if (2 === e || 1 === e) {
                let n = t.getIndex();
                if (null === n) {
                    const e = [],
                        i = t.getAttribute("position");
                    if (void 0 === i) return t;
                    for (let t = 0; t < i.count; t++) e.push(t);
                    t.setIndex(e), n = t.getIndex()
                }
                const i = n.count - 2,
                    r = [];
                if (2 === e)
                    for (let t = 1; t <= i; t++) r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1));
                else
                    for (let t = 0; t < i; t++) t % 2 == 0 ? (r.push(n.getX(t)), r.push(n.getX(t + 1)), r.push(n.getX(t + 2))) : (r.push(n.getX(t + 2)), r.push(n.getX(t + 1)), r.push(n.getX(t)));
                r.length;
                const s = t.clone();
                return s.setIndex(r), s.clearGroups(), s
            }
            return t
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: $c
            }
        })), "undefined" != typeof window && (window.__THREE__ || (window.__THREE__ = $c));
        class ay extends C_ {
            constructor(t) {
                super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (t) {
                    return new fy(t)
                })), this.register((function (t) {
                    return new Sy(t)
                })), this.register((function (t) {
                    return new Ey(t)
                })), this.register((function (t) {
                    return new My(t)
                })), this.register((function (t) {
                    return new my(t)
                })), this.register((function (t) {
                    return new gy(t)
                })), this.register((function (t) {
                    return new vy(t)
                })), this.register((function (t) {
                    return new _y(t)
                })), this.register((function (t) {
                    return new dy(t)
                })), this.register((function (t) {
                    return new yy(t)
                })), this.register((function (t) {
                    return new py(t)
                })), this.register((function (t) {
                    return new by(t)
                })), this.register((function (t) {
                    return new xy(t)
                })), this.register((function (t) {
                    return new uy(t)
                })), this.register((function (t) {
                    return new wy(t)
                })), this.register((function (t) {
                    return new Ty(t)
                }))
            }
            load(t, e, n, i) {
                const r = this;
                let s;
                if ("" !== this.resourcePath) s = this.resourcePath;
                else if ("" !== this.path) {
                    const e = J_.extractUrlBase(t);
                    s = J_.resolveURL(e, this.path)
                } else s = J_.extractUrlBase(t);
                this.manager.itemStart(t);
                const o = function (e) {
                        i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    },
                    a = new O_(this.manager);
                a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function (n) {
                    try {
                        r.parse(n, s, (function (n) {
                            e(n), r.manager.itemEnd(t)
                        }), o)
                    } catch (t) {
                        o(t)
                    }
                }), n, o)
            }
            setDRACOLoader(t) {
                return this.dracoLoader = t, this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(t) {
                return this.ktx2Loader = t, this
            }
            setMeshoptDecoder(t) {
                return this.meshoptDecoder = t, this
            }
            register(t) {
                return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
            }
            unregister(t) {
                return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
            }
            parse(t, e, n, i) {
                let r;
                const s = {},
                    o = {},
                    a = new TextDecoder;
                if ("string" == typeof t) r = JSON.parse(t);
                else if (t instanceof ArrayBuffer) {
                    if (a.decode(new Uint8Array(t, 0, 4)) === Ay) {
                        try {
                            s[cy.KHR_BINARY_GLTF] = new Ry(t)
                        } catch (t) {
                            return void(i && i(t))
                        }
                        r = JSON.parse(s[cy.KHR_BINARY_GLTF].content)
                    } else r = JSON.parse(a.decode(t))
                } else r = t;
                if (void 0 === r.asset || r.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const l = new nx(r, {
                    path: e || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                l.fileLoader.setRequestHeader(this.requestHeader);
                for (let t = 0; t < this.pluginCallbacks.length; t++) {
                    const e = this.pluginCallbacks[t](l);
                    e.name, o[e.name] = e, s[e.name] = !0
                }
                if (r.extensionsUsed)
                    for (let t = 0; t < r.extensionsUsed.length; ++t) {
                        const e = r.extensionsUsed[t],
                            n = r.extensionsRequired || [];
                        switch (e) {
                            case cy.KHR_MATERIALS_UNLIT:
                                s[e] = new hy;
                                break;
                            case cy.KHR_DRACO_MESH_COMPRESSION:
                                s[e] = new Ly(r, this.dracoLoader);
                                break;
                            case cy.KHR_TEXTURE_TRANSFORM:
                                s[e] = new Oy;
                                break;
                            case cy.KHR_MESH_QUANTIZATION:
                                s[e] = new Iy;
                                break;
                            default:
                                n.indexOf(e) >= 0 && o[e]
                        }
                    }
                l.setExtensions(s), l.setPlugins(o), l.parse(n, i)
            }
            parseAsync(t, e) {
                const n = this;
                return new Promise((function (i, r) {
                    n.parse(t, e, i, r)
                }))
            }
        }

        function ly() {
            let t = {};
            return {
                get: function (e) {
                    return t[e]
                },
                add: function (e, n) {
                    t[e] = n
                },
                remove: function (e) {
                    delete t[e]
                },
                removeAll: function () {
                    t = {}
                }
            }
        }
        const cy = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class uy {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const t = this.parser,
                    e = this.parser.json.nodes || [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(t) {
                const e = this.parser,
                    n = "light:" + t;
                let i = e.cache.get(n);
                if (i) return i;
                const r = e.json,
                    s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
                let o;
                const a = new xf(16777215);
                void 0 !== s.color && a.setRGB(s.color[0], s.color[1], s.color[2], th);
                const l = void 0 !== s.range ? s.range : 0;
                switch (s.type) {
                    case "directional":
                        o = new K_(a), o.target.position.set(0, 0, -1), o.add(o.target);
                        break;
                    case "point":
                        o = new q_(a), o.distance = l;
                        break;
                    case "spot":
                        o = new V_(a), o.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, o.angle = s.spot.outerConeAngle, o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                }
                return o.position.set(0, 0, 0), o.decay = 2, Zy(o, s), void 0 !== s.intensity && (o.intensity = s.intensity), o.name = e.createUniqueName(s.name || "light_" + t), i = Promise.resolve(o), e.cache.add(n, i), i
            }
            getDependency(t, e) {
                if ("light" === t) return this._loadLight(e)
            }
            createNodeAttachment(t) {
                const e = this,
                    n = this.parser,
                    i = n.json.nodes[t],
                    r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function (t) {
                    return n._getNodeRef(e.cache, r, t)
                }))
            }
        }
        class hy {
            constructor() {
                this.name = cy.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return Mf
            }
            extendParams(t, e, n) {
                const i = [];
                t.color = new xf(1, 1, 1), t.opacity = 1;
                const r = e.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const e = r.baseColorFactor;
                        t.color.setRGB(e[0], e[1], e[2], th), t.opacity = e[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture, Qu))
                }
                return Promise.all(i)
            }
        }
        class dy {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve()
            }
        }
        class fy {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                    const t = s.clearcoatNormalTexture.scale;
                    e.clearcoatNormalScale = new Ah(t, t)
                }
                return Promise.all(r)
            }
        }
        class py {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return void 0 !== s.iridescenceFactor && (e.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && r.push(n.assignTexture(e, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (e.iridescenceIOR = s.iridescenceIor), void 0 === e.iridescenceThicknessRange && (e.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (e.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (e.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(e, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(r)
            }
        }
        class my {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_SHEEN
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [];
                e.sheenColor = new xf(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
                const s = i.extensions[this.name];
                if (void 0 !== s.sheenColorFactor) {
                    const t = s.sheenColorFactor;
                    e.sheenColor.setRGB(t[0], t[1], t[2], th)
                }
                return void 0 !== s.sheenRoughnessFactor && (e.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && r.push(n.assignTexture(e, "sheenColorMap", s.sheenColorTexture, Qu)), void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(r)
            }
        }
        class gy {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(r)
            }
        }
        class vy {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_VOLUME
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)), e.attenuationDistance = s.attenuationDistance || 1 / 0;
                const o = s.attenuationColor || [1, 1, 1];
                return e.attenuationColor = (new xf).setRGB(o[0], o[1], o[2], th), Promise.all(r)
            }
        }
        class _y {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_IOR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name];
                return e.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
            }
        }
        class yy {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                e.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && r.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture));
                const o = s.specularColorFactor || [1, 1, 1];
                return e.specularColor = (new xf).setRGB(o[0], o[1], o[2], th), void 0 !== s.specularColorTexture && r.push(n.assignTexture(e, "specularColorMap", s.specularColorTexture, Qu)), Promise.all(r)
            }
        }
        class xy {
            constructor(t) {
                this.parser = t, this.name = cy.EXT_MATERIALS_BUMP
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return e.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1, void 0 !== s.bumpTexture && r.push(n.assignTexture(e, "bumpMap", s.bumpTexture)), Promise.all(r)
            }
        }
        class by {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? o_ : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return void 0 !== s.anisotropyStrength && (e.anisotropy = s.anisotropyStrength), void 0 !== s.anisotropyRotation && (e.anisotropyRotation = s.anisotropyRotation), void 0 !== s.anisotropyTexture && r.push(n.assignTexture(e, "anisotropyMap", s.anisotropyTexture)), Promise.all(r)
            }
        }
        class Sy {
            constructor(t) {
                this.parser = t, this.name = cy.KHR_TEXTURE_BASISU
            }
            loadTexture(t) {
                const e = this.parser,
                    n = e.json,
                    i = n.textures[t];
                if (!i.extensions || !i.extensions[this.name]) return null;
                const r = i.extensions[this.name],
                    s = e.options.ktx2Loader;
                if (!s) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return e.loadTextureImage(t, r.source, s)
            }
        }
        class Ey {
            constructor(t) {
                this.parser = t, this.name = cy.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name,
                    n = this.parser,
                    i = n.json,
                    r = i.textures[t];
                if (!r.extensions || !r.extensions[e]) return null;
                const s = r.extensions[e],
                    o = i.images[s.source];
                let a = n.textureLoader;
                if (o.uri) {
                    const t = n.options.manager.getHandler(o.uri);
                    null !== t && (a = t)
                }
                return this.detectSupport().then((function (r) {
                    if (r) return n.loadTextureImage(t, s.source, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(t)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function (t) {
                    const e = new Image;
                    e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function () {
                        t(1 === e.height)
                    }
                }))), this.isSupported
            }
        }
        class My {
            constructor(t) {
                this.parser = t, this.name = cy.EXT_TEXTURE_AVIF, this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name,
                    n = this.parser,
                    i = n.json,
                    r = i.textures[t];
                if (!r.extensions || !r.extensions[e]) return null;
                const s = r.extensions[e],
                    o = i.images[s.source];
                let a = n.textureLoader;
                if (o.uri) {
                    const t = n.options.manager.getHandler(o.uri);
                    null !== t && (a = t)
                }
                return this.detectSupport().then((function (r) {
                    if (r) return n.loadTextureImage(t, s.source, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(t)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function (t) {
                    const e = new Image;
                    e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function () {
                        t(1 === e.height)
                    }
                }))), this.isSupported
            }
        }
        class wy {
            constructor(t) {
                this.name = cy.EXT_MESHOPT_COMPRESSION, this.parser = t
            }
            loadBufferView(t) {
                const e = this.parser.json,
                    n = e.bufferViews[t];
                if (n.extensions && n.extensions[this.name]) {
                    const t = n.extensions[this.name],
                        i = this.parser.getDependency("buffer", t.buffer),
                        r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return i.then((function (e) {
                        const n = t.byteOffset || 0,
                            i = t.byteLength || 0,
                            s = t.count,
                            o = t.byteStride,
                            a = new Uint8Array(e, n, i);
                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(s, o, a, t.mode, t.filter).then((function (t) {
                            return t.buffer
                        })) : r.ready.then((function () {
                            const e = new ArrayBuffer(s * o);
                            return r.decodeGltfBuffer(new Uint8Array(e), s, o, a, t.mode, t.filter), e
                        }))
                    }))
                }
                return null
            }
        }
        class Ty {
            constructor(t) {
                this.name = cy.EXT_MESH_GPU_INSTANCING, this.parser = t
            }
            createNodeMesh(t) {
                const e = this.parser.json,
                    n = e.nodes[t];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
                const i = e.meshes[n.mesh];
                for (const t of i.primitives)
                    if (t.mode !== ky.TRIANGLES && t.mode !== ky.TRIANGLE_STRIP && t.mode !== ky.TRIANGLE_FAN && void 0 !== t.mode) return null;
                const r = n.extensions[this.name].attributes,
                    s = [],
                    o = {};
                for (const t in r) s.push(this.parser.getDependency("accessor", r[t]).then((e => (o[t] = e, o[t]))));
                return s.length < 1 ? null : (s.push(this.parser.createNodeMesh(t)), Promise.all(s).then((t => {
                    const e = t.pop(),
                        n = e.isGroup ? e.children : [e],
                        i = t[0].count,
                        r = [];
                    for (const t of n) {
                        const e = new Ld,
                            n = new ed,
                            s = new td,
                            a = new ed(1, 1, 1),
                            l = new zv(t.geometry, t.material, i);
                        for (let t = 0; t < i; t++) o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, t), o.ROTATION && s.fromBufferAttribute(o.ROTATION, t), o.SCALE && a.fromBufferAttribute(o.SCALE, t), l.setMatrixAt(t, e.compose(n, s, a));
                        for (const e in o)
                            if ("_COLOR_0" === e) {
                                const t = o[e];
                                l.instanceColor = new Lv(t.array, t.itemSize, t.normalized)
                            } else "TRANSLATION" !== e && "ROTATION" !== e && "SCALE" !== e && t.geometry.setAttribute(e, o[e]);
                        nf.prototype.copy.call(l, t), this.parser.assignFinalMaterial(l), r.push(l)
                    }
                    return e.isGroup ? (e.clear(), e.add(...r), e) : r[0]
                })))
            }
        }
        const Ay = "glTF",
            Py = 1313821514,
            Cy = 5130562;
        class Ry {
            constructor(t) {
                this.name = cy.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const e = new DataView(t, 0, 12),
                    n = new TextDecoder;
                if (this.header = {
                        magic: n.decode(new Uint8Array(t.slice(0, 4))),
                        version: e.getUint32(4, !0),
                        length: e.getUint32(8, !0)
                    }, this.header.magic !== Ay) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const i = this.header.length - 12,
                    r = new DataView(t, 12);
                let s = 0;
                for (; s < i;) {
                    const e = r.getUint32(s, !0);
                    s += 4;
                    const i = r.getUint32(s, !0);
                    if (s += 4, i === Py) {
                        const i = new Uint8Array(t, 12 + s, e);
                        this.content = n.decode(i)
                    } else if (i === Cy) {
                        const n = 12 + s;
                        this.body = t.slice(n, n + e)
                    }
                    s += e
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class Ly {
            constructor(t, e) {
                if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = cy.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
            }
            decodePrimitive(t, e) {
                const n = this.json,
                    i = this.dracoLoader,
                    r = t.extensions[this.name].bufferView,
                    s = t.extensions[this.name].attributes,
                    o = {},
                    a = {},
                    l = {};
                for (const t in s) {
                    const e = Vy[t] || t.toLowerCase();
                    o[e] = s[t]
                }
                for (const e in t.attributes) {
                    const i = Vy[e] || e.toLowerCase();
                    if (void 0 !== s[e]) {
                        const r = n.accessors[t.attributes[e]],
                            s = Fy[r.componentType];
                        l[i] = s.name, a[i] = !0 === r.normalized
                    }
                }
                return e.getDependency("bufferView", r).then((function (t) {
                    return new Promise((function (e, n) {
                        i.decodeDracoFile(t, (function (t) {
                            for (const e in t.attributes) {
                                const n = t.attributes[e],
                                    i = a[e];
                                void 0 !== i && (n.normalized = i)
                            }
                            e(t)
                        }), o, l, th, n)
                    }))
                }))
            }
        }
        class Oy {
            constructor() {
                this.name = cy.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(t, e) {
                return void 0 !== e.texCoord && e.texCoord !== t.channel || void 0 !== e.offset || void 0 !== e.rotation || void 0 !== e.scale ? (t = t.clone(), void 0 !== e.texCoord && (t.channel = e.texCoord), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0, t) : t
            }
        }
        class Iy {
            constructor() {
                this.name = cy.KHR_MESH_QUANTIZATION
            }
        }
        class Dy extends d_ {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = t * i * 3 + i;
                for (let t = 0; t !== i; t++) e[t] = n[r + t];
                return e
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = 2 * o,
                    l = 3 * o,
                    c = i - e,
                    u = (n - e) / c,
                    h = u * u,
                    d = h * u,
                    f = t * l,
                    p = f - l,
                    m = -2 * d + 3 * h,
                    g = d - h,
                    v = 1 - m,
                    _ = g - h + u;
                for (let t = 0; t !== o; t++) {
                    const e = s[p + t + o],
                        n = s[p + t + a] * c,
                        i = s[f + t + o],
                        l = s[f + t] * c;
                    r[t] = v * e + _ * n + m * i + g * l
                }
                return r
            }
        }
        const Ny = new td;
        class Uy extends Dy {
            interpolate_(t, e, n, i) {
                const r = super.interpolate_(t, e, n, i);
                return Ny.fromArray(r).normalize().toArray(r), r
            }
        }
        const ky = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            },
            Fy = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            zy = {
                9728: Mu,
                9729: Au,
                9984: wu,
                9985: Pu,
                9986: Tu,
                9987: Cu
            },
            By = {
                33071: Su,
                33648: Eu,
                10497: bu
            },
            Hy = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            Vy = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv1",
                TEXCOORD_2: "uv2",
                TEXCOORD_3: "uv3",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            Gy = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            Wy = {
                CUBICSPLINE: void 0,
                LINEAR: Xu,
                STEP: ju
            },
            jy = "OPAQUE",
            Xy = "MASK",
            qy = "BLEND";

        function Yy(t) {
            return void 0 === t.DefaultMaterial && (t.DefaultMaterial = new s_({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: nu
            })), t.DefaultMaterial
        }

        function Ky(t, e, n) {
            for (const i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i])
        }

        function Zy(t, e) {
            void 0 !== e.extras && "object" == typeof e.extras && Object.assign(t.userData, e.extras)
        }

        function Jy(t, e) {
            if (t.updateMorphTargets(), void 0 !== e.weights)
                for (let n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
            if (e.extras && Array.isArray(e.extras.targetNames)) {
                const n = e.extras.targetNames;
                if (t.morphTargetInfluences.length === n.length) {
                    t.morphTargetDictionary = {};
                    for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e
                }
            }
        }

        function $y(t) {
            let e;
            const n = t.extensions && t.extensions[cy.KHR_DRACO_MESH_COMPRESSION];
            if (e = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + Qy(n.attributes) : t.indices + ":" + Qy(t.attributes) + ":" + t.mode, void 0 !== t.targets)
                for (let n = 0, i = t.targets.length; n < i; n++) e += ":" + Qy(t.targets[n]);
            return e
        }

        function Qy(t) {
            let e = "";
            const n = Object.keys(t).sort();
            for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
            return e
        }

        function tx(t) {
            switch (t) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const ex = new Ld;
        class nx {
            constructor(t = {}, e = {}) {
                this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new ly, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                let n = !1,
                    i = !1,
                    r = -1;
                "undefined" != typeof navigator && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i = navigator.userAgent.indexOf("Firefox") > -1, r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new N_(this.options.manager) : this.textureLoader = new $_(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new O_(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(t) {
                this.extensions = t
            }
            setPlugins(t) {
                this.plugins = t
            }
            parse(t, e) {
                const n = this,
                    i = this.json,
                    r = this.extensions;
                this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function (t) {
                    return t._markDefs && t._markDefs()
                })), Promise.all(this._invokeAll((function (t) {
                    return t.beforeRoot && t.beforeRoot()
                }))).then((function () {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                })).then((function (e) {
                    const s = {
                        scene: e[0][i.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    return Ky(r, s, i), Zy(s, i), Promise.all(n._invokeAll((function (t) {
                        return t.afterRoot && t.afterRoot(s)
                    }))).then((function () {
                        t(s)
                    }))
                })).catch(e)
            }
            _markDefs() {
                const t = this.json.nodes || [],
                    e = this.json.skins || [],
                    n = this.json.meshes || [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n].joints;
                    for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0
                }
                for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(t, e) {
                void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
            }
            _getNodeRef(t, e, n) {
                if (t.refs[e] <= 1) return n;
                const i = n.clone(),
                    r = (t, e) => {
                        const n = this.associations.get(t);
                        null != n && this.associations.set(e, n);
                        for (const [n, i] of t.children.entries()) r(i, e.children[n])
                    };
                return r(n, i), i.name += "_instance_" + t.uses[e]++, i
            }
            _invokeOne(t) {
                const e = Object.values(this.plugins);
                e.push(this);
                for (let n = 0; n < e.length; n++) {
                    const i = t(e[n]);
                    if (i) return i
                }
                return null
            }
            _invokeAll(t) {
                const e = Object.values(this.plugins);
                e.unshift(this);
                const n = [];
                for (let i = 0; i < e.length; i++) {
                    const r = t(e[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(t, e) {
                const n = t + ":" + e;
                let i = this.cache.get(n);
                if (!i) {
                    switch (t) {
                        case "scene":
                            i = this.loadScene(e);
                            break;
                        case "node":
                            i = this._invokeOne((function (t) {
                                return t.loadNode && t.loadNode(e)
                            }));
                            break;
                        case "mesh":
                            i = this._invokeOne((function (t) {
                                return t.loadMesh && t.loadMesh(e)
                            }));
                            break;
                        case "accessor":
                            i = this.loadAccessor(e);
                            break;
                        case "bufferView":
                            i = this._invokeOne((function (t) {
                                return t.loadBufferView && t.loadBufferView(e)
                            }));
                            break;
                        case "buffer":
                            i = this.loadBuffer(e);
                            break;
                        case "material":
                            i = this._invokeOne((function (t) {
                                return t.loadMaterial && t.loadMaterial(e)
                            }));
                            break;
                        case "texture":
                            i = this._invokeOne((function (t) {
                                return t.loadTexture && t.loadTexture(e)
                            }));
                            break;
                        case "skin":
                            i = this.loadSkin(e);
                            break;
                        case "animation":
                            i = this._invokeOne((function (t) {
                                return t.loadAnimation && t.loadAnimation(e)
                            }));
                            break;
                        case "camera":
                            i = this.loadCamera(e);
                            break;
                        default:
                            if (i = this._invokeOne((function (n) {
                                    return n != this && n.getDependency && n.getDependency(t, e)
                                })), !i) throw new Error("Unknown type: " + t)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(t) {
                let e = this.cache.get(t);
                if (!e) {
                    const n = this,
                        i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                    e = Promise.all(i.map((function (e, i) {
                        return n.getDependency(t, i)
                    }))), this.cache.add(t, e)
                }
                return e
            }
            loadBuffer(t) {
                const e = this.json.buffers[t],
                    n = this.fileLoader;
                if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[cy.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise((function (t, r) {
                    n.load(J_.resolveURL(e.uri, i.path), t, void 0, (function () {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                    }))
                }))
            }
            loadBufferView(t) {
                const e = this.json.bufferViews[t];
                return this.getDependency("buffer", e.buffer).then((function (t) {
                    const n = e.byteLength || 0,
                        i = e.byteOffset || 0;
                    return t.slice(i, i + n)
                }))
            }
            loadAccessor(t) {
                const e = this,
                    n = this.json,
                    i = this.json.accessors[t];
                if (void 0 === i.bufferView && void 0 === i.sparse) {
                    const t = Hy[i.type],
                        e = Fy[i.componentType],
                        n = !0 === i.normalized,
                        r = new e(i.count * t);
                    return Promise.resolve(new Of(r, t, n))
                }
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function (t) {
                    const r = t[0],
                        s = Hy[i.type],
                        o = Fy[i.componentType],
                        a = o.BYTES_PER_ELEMENT,
                        l = a * s,
                        c = i.byteOffset || 0,
                        u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                        h = !0 === i.normalized;
                    let d, f;
                    if (u && u !== l) {
                        const t = Math.floor(c / u),
                            n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count;
                        let l = e.cache.get(n);
                        l || (d = new o(r, t * u, i.count * u / a), l = new fv(d, u / a), e.cache.add(n, l)), f = new mv(l, s, c % u / a, h)
                    } else d = null === r ? new o(i.count * s) : new o(r, c, i.count * s), f = new Of(d, s, h);
                    if (void 0 !== i.sparse) {
                        const e = Hy.SCALAR,
                            n = Fy[i.sparse.indices.componentType],
                            a = i.sparse.indices.byteOffset || 0,
                            l = i.sparse.values.byteOffset || 0,
                            c = new n(t[1], a, i.sparse.count * e),
                            u = new o(t[2], l, i.sparse.count * s);
                        null !== r && (f = new Of(f.array.slice(), f.itemSize, f.normalized));
                        for (let t = 0, e = c.length; t < e; t++) {
                            const e = c[t];
                            if (f.setX(e, u[t * s]), s >= 2 && f.setY(e, u[t * s + 1]), s >= 3 && f.setZ(e, u[t * s + 2]), s >= 4 && f.setW(e, u[t * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return f
                }))
            }
            loadTexture(t) {
                const e = this.json,
                    n = this.options,
                    i = e.textures[t].source,
                    r = e.images[i];
                let s = this.textureLoader;
                if (r.uri) {
                    const t = n.manager.getHandler(r.uri);
                    null !== t && (s = t)
                }
                return this.loadTextureImage(t, i, s)
            }
            loadTextureImage(t, e, n) {
                const i = this,
                    r = this.json,
                    s = r.textures[t],
                    o = r.images[e],
                    a = (o.uri || o.bufferView) + ":" + s.sampler;
                if (this.textureCache[a]) return this.textureCache[a];
                const l = this.loadImageSource(e, n).then((function (e) {
                    e.flipY = !1, e.name = s.name || o.name || "", "" === e.name && "string" == typeof o.uri && !1 === o.uri.startsWith("data:image/") && (e.name = o.uri);
                    const n = (r.samplers || {})[s.sampler] || {};
                    return e.magFilter = zy[n.magFilter] || Au, e.minFilter = zy[n.minFilter] || Cu, e.wrapS = By[n.wrapS] || bu, e.wrapT = By[n.wrapT] || bu, i.associations.set(e, {
                        textures: t
                    }), e
                })).catch((function () {
                    return null
                }));
                return this.textureCache[a] = l, l
            }
            loadImageSource(t, e) {
                const n = this,
                    i = this.json,
                    r = this.options;
                if (void 0 !== this.sourceCache[t]) return this.sourceCache[t].then((t => t.clone()));
                const s = i.images[t],
                    o = self.URL || self.webkitURL;
                let a = s.uri || "",
                    l = !1;
                if (void 0 !== s.bufferView) a = n.getDependency("bufferView", s.bufferView).then((function (t) {
                    l = !0;
                    const e = new Blob([t], {
                        type: s.mimeType
                    });
                    return a = o.createObjectURL(e), a
                }));
                else if (void 0 === s.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                const c = Promise.resolve(a).then((function (t) {
                    return new Promise((function (n, i) {
                        let s = n;
                        !0 === e.isImageBitmapLoader && (s = function (t) {
                            const e = new Yh(t);
                            e.needsUpdate = !0, n(e)
                        }), e.load(J_.resolveURL(t, r.path), s, void 0, i)
                    }))
                })).then((function (t) {
                    var e;
                    return !0 === l && o.revokeObjectURL(a), t.userData.mimeType = s.mimeType || ((e = s.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/) ? "image/jpeg" : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), t
                })).catch((function (t) {
                    throw t
                }));
                return this.sourceCache[t] = c, c
            }
            assignTexture(t, e, n, i) {
                const r = this;
                return this.getDependency("texture", n.index).then((function (s) {
                    if (!s) return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((s = s.clone()).channel = n.texCoord), r.extensions[cy.KHR_TEXTURE_TRANSFORM]) {
                        const t = void 0 !== n.extensions ? n.extensions[cy.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (t) {
                            const e = r.associations.get(s);
                            s = r.extensions[cy.KHR_TEXTURE_TRANSFORM].extendTexture(s, t), r.associations.set(s, e)
                        }
                    }
                    return void 0 !== i && (s.colorSpace = i), t[e] = s, s
                }))
            }
            assignFinalMaterial(t) {
                const e = t.geometry;
                let n = t.material;
                const i = void 0 === e.attributes.tangent,
                    r = void 0 !== e.attributes.color,
                    s = void 0 === e.attributes.normal;
                if (t.isPoints) {
                    const t = "PointsMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new Jv, Ef.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
                } else if (t.isLine) {
                    const t = "LineBasicMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new Bv, Ef.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, this.cache.add(t, e)), n = e
                }
                if (i || r || s) {
                    let t = "ClonedMaterial:" + n.uuid + ":";
                    i && (t += "derivative-tangents:"), r && (t += "vertex-colors:"), s && (t += "flat-shading:");
                    let e = this.cache.get(t);
                    e || (e = n.clone(), r && (e.vertexColors = !0), s && (e.flatShading = !0), i && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
                }
                t.material = n
            }
            getMaterialType() {
                return s_
            }
            loadMaterial(t) {
                const e = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.materials[t];
                let s;
                const o = {},
                    a = [];
                if ((r.extensions || {})[cy.KHR_MATERIALS_UNLIT]) {
                    const t = i[cy.KHR_MATERIALS_UNLIT];
                    s = t.getMaterialType(), a.push(t.extendParams(o, r, e))
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (o.color = new xf(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) {
                        const t = n.baseColorFactor;
                        o.color.setRGB(t[0], t[1], t[2], th), o.opacity = t[3]
                    }
                    void 0 !== n.baseColorTexture && a.push(e.assignTexture(o, "map", n.baseColorTexture, Qu)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (a.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), a.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function (e) {
                        return e.getMaterialType && e.getMaterialType(t)
                    })), a.push(Promise.all(this._invokeAll((function (e) {
                        return e.extendMaterialParams && e.extendMaterialParams(t, o)
                    }))))
                }!0 === r.doubleSided && (o.side = 2);
                const l = r.alphaMode || jy;
                if (l === qy ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, l === Xy && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== Mf && (a.push(e.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new Ah(1, 1), void 0 !== r.normalTexture.scale)) {
                    const t = r.normalTexture.scale;
                    o.normalScale.set(t, t)
                }
                if (void 0 !== r.occlusionTexture && s !== Mf && (a.push(e.assignTexture(o, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== Mf) {
                    const t = r.emissiveFactor;
                    o.emissive = (new xf).setRGB(t[0], t[1], t[2], th)
                }
                return void 0 !== r.emissiveTexture && s !== Mf && a.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture, Qu)), Promise.all(a).then((function () {
                    const n = new s(o);
                    return r.name && (n.name = r.name), Zy(n, r), e.associations.set(n, {
                        materials: t
                    }), r.extensions && Ky(i, n, r), n
                }))
            }
            createUniqueName(t) {
                const e = sy.sanitizeNodeName(t || "");
                return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e)
            }
            loadGeometries(t) {
                const e = this,
                    n = this.extensions,
                    i = this.primitiveCache;

                function r(t) {
                    return n[cy.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function (n) {
                        return ix(n, t, e)
                    }))
                }
                const s = [];
                for (let n = 0, o = t.length; n < o; n++) {
                    const o = t[n],
                        a = $y(o),
                        l = i[a];
                    if (l) s.push(l.promise);
                    else {
                        let t;
                        t = o.extensions && o.extensions[cy.KHR_DRACO_MESH_COMPRESSION] ? r(o) : ix(new Gf, o, e), i[a] = {
                            primitive: o,
                            promise: t
                        }, s.push(t)
                    }
                }
                return Promise.all(s)
            }
            loadMesh(t) {
                const e = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.meshes[t],
                    s = r.primitives,
                    o = [];
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = void 0 === s[t].material ? Yy(this.cache) : this.getDependency("material", s[t].material);
                    o.push(e)
                }
                return o.push(e.loadGeometries(s)), Promise.all(o).then((function (n) {
                    const o = n.slice(0, n.length - 1),
                        a = n[n.length - 1],
                        l = [];
                    for (let n = 0, c = a.length; n < c; n++) {
                        const c = a[n],
                            u = s[n];
                        let h;
                        const d = o[n];
                        if (u.mode === ky.TRIANGLES || u.mode === ky.TRIANGLE_STRIP || u.mode === ky.TRIANGLE_FAN || void 0 === u.mode) h = !0 === r.isSkinnedMesh ? new wv(c, d) : new ap(c, d), !0 === h.isSkinnedMesh && h.normalizeSkinWeights(), u.mode === ky.TRIANGLE_STRIP ? h.geometry = oy(h.geometry, 1) : u.mode === ky.TRIANGLE_FAN && (h.geometry = oy(h.geometry, 2));
                        else if (u.mode === ky.LINES) h = new Kv(c, d);
                        else if (u.mode === ky.LINE_STRIP) h = new Xv(c, d);
                        else if (u.mode === ky.LINE_LOOP) h = new Zv(c, d);
                        else {
                            if (u.mode !== ky.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                            h = new n_(c, d)
                        }
                        Object.keys(h.geometry.morphAttributes).length > 0 && Jy(h, r), h.name = e.createUniqueName(r.name || "mesh_" + t), Zy(h, r), u.extensions && Ky(i, h, u), e.assignFinalMaterial(h), l.push(h)
                    }
                    for (let n = 0, i = l.length; n < i; n++) e.associations.set(l[n], {
                        meshes: t,
                        primitives: n
                    });
                    if (1 === l.length) return r.extensions && Ky(i, l[0], r), l[0];
                    const c = new sv;
                    r.extensions && Ky(i, c, r), e.associations.set(c, {
                        meshes: t
                    });
                    for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
                    return c
                }))
            }
            loadCamera(t) {
                let e;
                const n = this.json.cameras[t],
                    i = n[n.type];
                if (i) return "perspective" === n.type ? e = new gp(Th.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new Hp(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), Zy(e, n), Promise.resolve(e)
            }
            loadSkin(t) {
                const e = this.json.skins[t],
                    n = [];
                for (let t = 0, i = e.joints.length; t < i; t++) n.push(this._loadNodeShallow(e.joints[t]));
                return void 0 !== e.inverseBindMatrices ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function (t) {
                    const e = t.pop(),
                        n = t,
                        i = [],
                        r = [];
                    for (let t = 0, s = n.length; t < s; t++) {
                        const s = n[t];
                        if (s) {
                            i.push(s);
                            const n = new Ld;
                            null !== e && n.fromArray(e.array, 16 * t), r.push(n)
                        }
                    }
                    return new Rv(i, r)
                }))
            }
            loadAnimation(t) {
                const e = this.json,
                    n = this,
                    i = e.animations[t],
                    r = i.name ? i.name : "animation_" + t,
                    s = [],
                    o = [],
                    a = [],
                    l = [],
                    c = [];
                for (let t = 0, e = i.channels.length; t < e; t++) {
                    const e = i.channels[t],
                        n = i.samplers[e.sampler],
                        r = e.target,
                        u = r.node,
                        h = void 0 !== i.parameters ? i.parameters[n.input] : n.input,
                        d = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                    void 0 !== r.node && (s.push(this.getDependency("node", u)), o.push(this.getDependency("accessor", h)), a.push(this.getDependency("accessor", d)), l.push(n), c.push(r))
                }
                return Promise.all([Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c)]).then((function (t) {
                    const e = t[0],
                        i = t[1],
                        s = t[2],
                        o = t[3],
                        a = t[4],
                        l = [];
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = e[t],
                            c = i[t],
                            u = s[t],
                            h = o[t],
                            d = a[t];
                        if (void 0 === r) continue;
                        r.updateMatrix && r.updateMatrix();
                        const f = n._createAnimationTracks(r, c, u, h, d);
                        if (f)
                            for (let t = 0; t < f.length; t++) l.push(f[t])
                    }
                    return new M_(r, void 0, l)
                }))
            }
            createNodeMesh(t) {
                const e = this.json,
                    n = this,
                    i = e.nodes[t];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function (t) {
                    const e = n._getNodeRef(n.meshCache, i.mesh, t);
                    return void 0 !== i.weights && e.traverse((function (t) {
                        if (t.isMesh)
                            for (let e = 0, n = i.weights.length; e < n; e++) t.morphTargetInfluences[e] = i.weights[e]
                    })), e
                }))
            }
            loadNode(t) {
                const e = this,
                    n = this.json.nodes[t],
                    i = e._loadNodeShallow(t),
                    r = [],
                    s = n.children || [];
                for (let t = 0, n = s.length; t < n; t++) r.push(e.getDependency("node", s[t]));
                const o = void 0 === n.skin ? Promise.resolve(null) : e.getDependency("skin", n.skin);
                return Promise.all([i, Promise.all(r), o]).then((function (t) {
                    const e = t[0],
                        n = t[1],
                        i = t[2];
                    null !== i && e.traverse((function (t) {
                        t.isSkinnedMesh && t.bind(i, ex)
                    }));
                    for (let t = 0, i = n.length; t < i; t++) e.add(n[t]);
                    return e
                }))
            }
            _loadNodeShallow(t) {
                const e = this.json,
                    n = this.extensions,
                    i = this;
                if (void 0 !== this.nodeCache[t]) return this.nodeCache[t];
                const r = e.nodes[t],
                    s = r.name ? i.createUniqueName(r.name) : "",
                    o = [],
                    a = i._invokeOne((function (e) {
                        return e.createNodeMesh && e.createNodeMesh(t)
                    }));
                return a && o.push(a), void 0 !== r.camera && o.push(i.getDependency("camera", r.camera).then((function (t) {
                    return i._getNodeRef(i.cameraCache, r.camera, t)
                }))), i._invokeAll((function (e) {
                    return e.createNodeAttachment && e.createNodeAttachment(t)
                })).forEach((function (t) {
                    o.push(t)
                })), this.nodeCache[t] = Promise.all(o).then((function (e) {
                    let o;
                    if (o = !0 === r.isBone ? new Tv : e.length > 1 ? new sv : 1 === e.length ? e[0] : new nf, o !== e[0])
                        for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
                    if (r.name && (o.userData.name = r.name, o.name = s), Zy(o, r), r.extensions && Ky(n, o, r), void 0 !== r.matrix) {
                        const t = new Ld;
                        t.fromArray(r.matrix), o.applyMatrix4(t)
                    } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale);
                    return i.associations.has(o) || i.associations.set(o, {}), i.associations.get(o).nodes = t, o
                })), this.nodeCache[t]
            }
            loadScene(t) {
                const e = this.extensions,
                    n = this.json.scenes[t],
                    i = this,
                    r = new sv;
                n.name && (r.name = i.createUniqueName(n.name)), Zy(r, n), n.extensions && Ky(e, r, n);
                const s = n.nodes || [],
                    o = [];
                for (let t = 0, e = s.length; t < e; t++) o.push(i.getDependency("node", s[t]));
                return Promise.all(o).then((function (t) {
                    for (let e = 0, n = t.length; e < n; e++) r.add(t[e]);
                    return i.associations = (t => {
                        const e = new Map;
                        for (const [t, n] of i.associations)(t instanceof Ef || t instanceof Yh) && e.set(t, n);
                        return t.traverse((t => {
                            const n = i.associations.get(t);
                            null != n && e.set(t, n)
                        })), e
                    })(r), r
                }))
            }
            _createAnimationTracks(t, e, n, i, r) {
                const s = [],
                    o = t.name ? t.name : t.uuid,
                    a = [];
                let l;
                switch (Gy[r.path] === Gy.weights ? t.traverse((function (t) {
                    t.morphTargetInfluences && a.push(t.name ? t.name : t.uuid)
                })) : a.push(o), Gy[r.path]) {
                    case Gy.weights:
                        l = y_;
                        break;
                    case Gy.rotation:
                        l = b_;
                        break;
                    case Gy.position:
                    case Gy.scale:
                        l = E_;
                        break;
                    default:
                        if (1 === n.itemSize) l = y_;
                        else l = E_
                }
                const c = void 0 !== i.interpolation ? Wy[i.interpolation] : Xu,
                    u = this._getArrayFromAccessor(n);
                for (let t = 0, n = a.length; t < n; t++) {
                    const n = new l(a[t] + "." + Gy[r.path], e.array, u, c);
                    "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n), s.push(n)
                }
                return s
            }
            _getArrayFromAccessor(t) {
                let e = t.array;
                if (t.normalized) {
                    const t = tx(e.constructor),
                        n = new Float32Array(e.length);
                    for (let i = 0, r = e.length; i < r; i++) n[i] = e[i] * t;
                    e = n
                }
                return e
            }
            _createCubicSplineTrackInterpolant(t) {
                t.createInterpolant = function (t) {
                    return new(this instanceof b_ ? Uy : Dy)(this.times, this.values, this.getValueSize() / 3, t)
                }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }

        function ix(t, e, n) {
            const i = e.attributes,
                r = [];

            function s(e, i) {
                return n.getDependency("accessor", e).then((function (e) {
                    t.setAttribute(i, e)
                }))
            }
            for (const e in i) {
                const n = Vy[e] || e.toLowerCase();
                n in t.attributes || r.push(s(i[e], n))
            }
            if (void 0 !== e.indices && !t.index) {
                const i = n.getDependency("accessor", e.indices).then((function (e) {
                    t.setIndex(e)
                }));
                r.push(i)
            }
            return zh.workingColorSpace, Zy(t, e),
                function (t, e, n) {
                    const i = e.attributes,
                        r = new rd;
                    if (void 0 === i.POSITION) return; {
                        const t = n.json.accessors[i.POSITION],
                            e = t.min,
                            s = t.max;
                        if (void 0 === e || void 0 === s) return;
                        if (r.set(new ed(e[0], e[1], e[2]), new ed(s[0], s[1], s[2])), t.normalized) {
                            const e = tx(Fy[t.componentType]);
                            r.min.multiplyScalar(e), r.max.multiplyScalar(e)
                        }
                    }
                    const s = e.targets;
                    if (void 0 !== s) {
                        const t = new ed,
                            e = new ed;
                        for (let i = 0, r = s.length; i < r; i++) {
                            const r = s[i];
                            if (void 0 !== r.POSITION) {
                                const i = n.json.accessors[r.POSITION],
                                    s = i.min,
                                    o = i.max;
                                if (void 0 !== s && void 0 !== o) {
                                    if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), i.normalized) {
                                        const t = tx(Fy[i.componentType]);
                                        e.multiplyScalar(t)
                                    }
                                    t.max(e)
                                }
                            }
                        }
                        r.expandByVector(t)
                    }
                    t.boundingBox = r;
                    const o = new Sd;
                    r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, t.boundingSphere = o
                }(t, e, n), Promise.all(r).then((function () {
                    return void 0 !== e.targets ? function (t, e, n) {
                        let i = !1,
                            r = !1,
                            s = !1;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (s = !0), i && r && s) break
                        }
                        if (!i && !r && !s) return Promise.resolve(t);
                        const o = [],
                            a = [],
                            l = [];
                        for (let c = 0, u = e.length; c < u; c++) {
                            const u = e[c];
                            if (i) {
                                const e = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : t.attributes.position;
                                o.push(e)
                            }
                            if (r) {
                                const e = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : t.attributes.normal;
                                a.push(e)
                            }
                            if (s) {
                                const e = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : t.attributes.color;
                                l.push(e)
                            }
                        }
                        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then((function (e) {
                            const n = e[0],
                                o = e[1],
                                a = e[2];
                            return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = o), s && (t.morphAttributes.color = a), t.morphTargetsRelative = !0, t
                        }))
                    }(t, e.targets, n) : t
                }))
        }
        class rx extends D_ {
            constructor(t) {
                super(t), this.type = Nu
            }
            parse(t) {
                const e = function (t, e) {
                        switch (t) {
                            case 1:
                                throw new Error("THREE.RGBELoader: Read Error: " + (e || ""));
                            case 2:
                                throw new Error("THREE.RGBELoader: Write Error: " + (e || ""));
                            case 3:
                                throw new Error("THREE.RGBELoader: Bad File Format: " + (e || ""));
                            default:
                                throw new Error("THREE.RGBELoader: Memory Error: " + (e || ""))
                        }
                    },
                    n = function (t, e, n) {
                        e = e || 1024;
                        let i = t.pos,
                            r = -1,
                            s = 0,
                            o = "",
                            a = String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128)));
                        for (; 0 > (r = a.indexOf("\n")) && s < e && i < t.byteLength;) o += a, s += a.length, i += 128, a += String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128)));
                        return -1 < r && (!1 !== n && (t.pos += s + r + 1), o + a.slice(0, r))
                    },
                    i = function (t, e, n, i) {
                        const r = t[e + 3],
                            s = Math.pow(2, r - 128) / 255;
                        n[i + 0] = t[e + 0] * s, n[i + 1] = t[e + 1] * s, n[i + 2] = t[e + 2] * s, n[i + 3] = 1
                    },
                    r = function (t, e, n, i) {
                        const r = t[e + 3],
                            s = Math.pow(2, r - 128) / 255;
                        n[i + 0] = Cf.toHalfFloat(Math.min(t[e + 0] * s, 65504)), n[i + 1] = Cf.toHalfFloat(Math.min(t[e + 1] * s, 65504)), n[i + 2] = Cf.toHalfFloat(Math.min(t[e + 2] * s, 65504)), n[i + 3] = Cf.toHalfFloat(1)
                    },
                    s = new Uint8Array(t);
                s.pos = 0;
                const o = function (t) {
                        const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                            r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                            s = /^\s*FORMAT=(\S+)\s*$/,
                            o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                            a = {
                                valid: 0,
                                string: "",
                                comments: "",
                                programtype: "RGBE",
                                format: "",
                                gamma: 1,
                                exposure: 1,
                                width: 0,
                                height: 0
                            };
                        let l, c;
                        for ((t.pos >= t.byteLength || !(l = n(t))) && e(1, "no header found"), (c = l.match(/^#\?(\S+)/)) || e(3, "bad initial token"), a.valid |= 1, a.programtype = c[1], a.string += l + "\n"; l = n(t), !1 !== l;)
                            if (a.string += l + "\n", "#" !== l.charAt(0)) {
                                if ((c = l.match(i)) && (a.gamma = parseFloat(c[1])), (c = l.match(r)) && (a.exposure = parseFloat(c[1])), (c = l.match(s)) && (a.valid |= 2, a.format = c[1]), (c = l.match(o)) && (a.valid |= 4, a.height = parseInt(c[1], 10), a.width = parseInt(c[2], 10)), 2 & a.valid && 4 & a.valid) break
                            } else a.comments += l + "\n";
                        return 2 & a.valid || e(3, "missing format specifier"), 4 & a.valid || e(3, "missing image size specifier"), a
                    }(s),
                    a = o.width,
                    l = o.height,
                    c = function (t, n, i) {
                        const r = n;
                        if (r < 8 || r > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2]) return new Uint8Array(t);
                        r !== (t[2] << 8 | t[3]) && e(3, "wrong scanline width");
                        const s = new Uint8Array(4 * n * i);
                        s.length || e(4, "unable to allocate buffer space");
                        let o = 0,
                            a = 0;
                        const l = 4 * r,
                            c = new Uint8Array(4),
                            u = new Uint8Array(l);
                        let h = i;
                        for (; h > 0 && a < t.byteLength;) {
                            a + 4 > t.byteLength && e(1), c[0] = t[a++], c[1] = t[a++], c[2] = t[a++], c[3] = t[a++], 2 == c[0] && 2 == c[1] && (c[2] << 8 | c[3]) == r || e(3, "bad rgbe scanline format");
                            let n, i = 0;
                            for (; i < l && a < t.byteLength;) {
                                n = t[a++];
                                const r = n > 128;
                                if (r && (n -= 128), (0 === n || i + n > l) && e(3, "bad scanline data"), r) {
                                    const e = t[a++];
                                    for (let t = 0; t < n; t++) u[i++] = e
                                } else u.set(t.subarray(a, a + n), i), i += n, a += n
                            }
                            const d = r;
                            for (let t = 0; t < d; t++) {
                                let e = 0;
                                s[o] = u[t + e], e += r, s[o + 1] = u[t + e], e += r, s[o + 2] = u[t + e], e += r, s[o + 3] = u[t + e], o += 4
                            }
                            h--
                        }
                        return s
                    }(s.subarray(s.pos), a, l);
                let u, h, d;
                switch (this.type) {
                    case Du:
                        d = c.length / 4;
                        const t = new Float32Array(4 * d);
                        for (let e = 0; e < d; e++) i(c, 4 * e, t, 4 * e);
                        u = t, h = Du;
                        break;
                    case Nu:
                        d = c.length / 4;
                        const e = new Uint16Array(4 * d);
                        for (let t = 0; t < d; t++) r(c, 4 * t, e, 4 * t);
                        u = e, h = Nu;
                        break;
                    default:
                        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
                }
                return {
                    width: a,
                    height: l,
                    data: u,
                    header: o.string,
                    gamma: o.gamma,
                    exposure: o.exposure,
                    type: h
                }
            }
            setDataType(t) {
                return this.type = t, this
            }
            load(t, e, n, i) {
                return super.load(t, (function (t, n) {
                    switch (t.type) {
                        case Du:
                        case Nu:
                            t.colorSpace = th, t.minFilter = Au, t.magFilter = Au, t.generateMipmaps = !1, t.flipY = !0
                    }
                    e && e(t, n)
                }), n, i)
            }
        }

        function sx(t) {
            return sx = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, sx(t)
        }

        function ox(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, cx(i.key), i)
            }
        }

        function ax(t, e) {
            hx(t, e), e.add(t)
        }

        function lx(t, e, n) {
            return (e = cx(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function cx(t) {
            var e = function (t, e) {
                if ("object" != sx(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" != sx(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == sx(e) ? e : String(e)
        }

        function ux(t, e, n) {
            hx(t, e), e.set(t, n)
        }

        function hx(t, e) {
            if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object")
        }

        function dx(t, e) {
            return function (t, e) {
                if (e.get) return e.get.call(t);
                return e.value
            }(t, mx(t, e, "get"))
        }

        function fx(t, e, n) {
            if (!e.has(t)) throw new TypeError("attempted to get private field on non-instance");
            return n
        }

        function px(t, e, n) {
            return function (t, e, n) {
                if (e.set) e.set.call(t, n);
                else {
                    if (!e.writable) throw new TypeError("attempted to set read only private field");
                    e.value = n
                }
            }(t, mx(t, e, "set"), n), n
        }

        function mx(t, e, n) {
            if (!e.has(t)) throw new TypeError("attempted to " + n + " private field on non-instance");
            return e.get(t)
        }
        var gx = new WeakMap,
            vx = new WeakMap,
            _x = new WeakMap,
            yx = new WeakMap,
            xx = new WeakMap,
            bx = new WeakMap,
            Sx = new WeakSet,
            Ex = new WeakSet,
            Mx = new WeakSet,
            wx = new WeakSet,
            Tx = new WeakSet,
            Ax = function () {
                function t(e) {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), ax(this, Tx), ax(this, wx), ax(this, Mx), ax(this, Ex), ax(this, Sx), ux(this, gx, {
                        writable: !0,
                        value: null
                    }), ux(this, vx, {
                        writable: !0,
                        value: null
                    }), ux(this, _x, {
                        writable: !0,
                        value: null
                    }), lx(this, "camera", null), lx(this, "cameraModel", null), lx(this, "renderer", null), lx(this, "scene", null), lx(this, "videoLayer", null), lx(this, "cameraMonitor", null), lx(this, "tempProgress", 0), lx(this, "mousePosition", {
                        x: 0,
                        y: 0
                    }), ux(this, yx, {
                        writable: !0,
                        value: null
                    }), ux(this, xx, {
                        writable: !0,
                        value: 0
                    }), ux(this, bx, {
                        writable: !0,
                        value: 0
                    }), px(this, yx, e), fx(this, wx, Lx).call(this), fx(this, Tx, Ox).call(this), px(this, xx, window.innerHeight), px(this, bx, window.innerWidth)
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "moveMouse",
                    value: function (t) {
                        this.mousePosition && (this.mousePosition.x = t.x, this.mousePosition.y = t.y, window.innerWidth <= 800 && (this.mousePosition.x = 0, this.mousePosition.y = 0), fx(this, Mx, Rx).call(this), fx(this, Ex, Cx).call(this))
                    }
                }, {
                    key: "onScroll",
                    value: function () {
                        fx(this, Ex, Cx).call(this)
                    }
                }, {
                    key: "onWindowResize",
                    value: function () {
                        this.camera && this.renderer && (window.innerWidth != dx(this, bx) ? (px(this, bx, window.innerWidth), this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight)) : (dx(this, xx) - window.innerHeight > 300 || dx(this, xx) - window.innerHeight < -300) && (px(this, xx, window.innerHeight), this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight)));
                        var t = ea.getById("trigger-HomeAnimationContainer");
                        t && t.refresh()
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        this.mousePosition = null, dx(this, gx) && dx(this, gx).kill(), dx(this, vx) && dx(this, vx).kill(), dx(this, _x) && dx(this, _x).kill(), fx(this, Sx, Px).call(this)
                    }
                }]) && ox(e.prototype, n), i && ox(e, i), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), t
            }();

        function Px() {
            px(this, gx, null), px(this, vx, null), px(this, _x, null), this.camera = null, this.cameraModel = null, this.renderer = null, this.scene = null, this.videoLayer = null, this.cameraMonitor = null, this.tempProgress = null, this.mousePosition = null, px(this, yx, null)
        }

        function Cx() {
            if (!(window.innerWidth <= 800)) {
                var t = (this.mousePosition.x - window.innerWidth / 2) / (2 * window.innerWidth) * -1 / 3,
                    e = (this.mousePosition.y - window.innerHeight / 2) / (2 * window.innerHeight) * -1 / 3,
                    n = document.querySelector("#showreelVideoContainer"),
                    i = document.querySelector("#videoShowReelPlayText");
                if (n && i) {
                    n.getBoundingClientRect().left, n.getBoundingClientRect().top;
                    var r = n.getBoundingClientRect(),
                        s = r.top,
                        o = r.left;
                    Yi.to("#videoShowReelPlayText", {
                        duration: .5,
                        x: this.mousePosition.x - o - i.offsetWidth / 2,
                        y: this.mousePosition.y - s - i.offsetHeight / 2
                    })
                }
                var a = document.querySelector(".iLikeText"),
                    l = document.querySelector(".creativeText");
                if (a && l && (Yi.to(a, {
                        duration: .2,
                        x: 100 * t
                    }), Yi.to(l, {
                        duration: .2,
                        x: 100 * -t
                    })), document.querySelector(".homeStartGrid")) var c = document.querySelector(".homeStartGrid").querySelector(".fontSizeUltraLarge"),
                    u = document.querySelector(".homeStartGrid").querySelector(".fontSizeNormal");
                c && u && (Yi.to(c, {
                    duration: .2,
                    x: 100 * t,
                    y: 100 * e
                }), Yi.to(u, {
                    duration: .2,
                    x: 200 * t,
                    y: 200 * e
                }))
            }
        }

        function Rx(t) {
            if (null != t && (this.tempProgress = t), !(this.tempProgress < 0 || this.tempProgress >= 1 || void 0 === this.tempProgress)) {
                var e = this.tempProgress,
                    n = new ed;
                if (this.videoLayer && this.videoLayer.getWorldPosition(n), this.camera && this.cameraModel) {
                    var i = this.camera,
                        r = function (t, e, n, i, r) {
                            function s(t, e) {
                                var n = Math.tan;
                                return 2 * (0, Math.atan)(e * n(t / 2))
                            }

                            function o(t, e) {
                                return t / (2 * (0, Math.tan)(e / 2))
                            }
                            var a = n / i,
                                l = s(e, t),
                                c = 0;
                            ("contain" === r ? a <= t : a > t) ? c = o(i, e): a <= t && (c = o(n, l));
                            return c
                        }(i.aspect, i.fov, 3.5, 2, "cover"),
                        s = function (t) {
                            return t * (2 - t)
                        }(e),
                        o = (this.mousePosition.x - window.innerWidth / 2) / (2 * window.innerWidth) * -1 / (3 / e),
                        a = (this.mousePosition.y - window.innerHeight / 2) / (2 * window.innerHeight) * -1 / (3 / e);
                    i.position.z = -.75 + r - 9 * s * -1;
                    var l = 1 - 10 * e;
                    l = Math.max(0, Math.min(l, 1));
                    var c = document.querySelector("#homeAnimationColor");
                    this.cameraModel && Yi.to(this.cameraModel.rotation, {
                        duration: .15,
                        x: 0 + .75 * e + 3 * a,
                        y: 3.5 * s + 3 * o,
                        z: 0 + e / 4
                    }), c && Yi.to(c, {
                        alpha: l
                    }), dx(this, gx)
                }
            }
        }

        function Lx() {
            var t = this;
            px(this, gx, Yi.timeline()), document.querySelector("#s-home-start2") && ea.create({
                trigger: "#s-home-start2",
                start: "top top",
                end: "bottom top",
                id: "trigger-HomeAnimationContainer",
                pin: "#homeAnimationContainer",
                onUpdate: function (e) {
                    fx(t, Mx, Rx).call(t, e.progress)
                },
                onToggle: function (t) {}
            }), document.querySelector("#photosWrapper") && ea.create({
                trigger: "#photosWrapper",
                start: "top center",
                end: "bottom bottom",
                onEnter: function (t) {
                    return Yi.to("#s-home-start3", {
                        backgroundColor: "#ebd9c8",
                        duration: .5
                    })
                },
                onLeaveBack: function (t) {
                    return Yi.to("#s-home-start3", {
                        backgroundColor: "#161618",
                        duration: .5
                    })
                },
                onLeave: function (t) {
                    return Yi.to("#s-home-start3", {
                        backgroundColor: "#8fa5b1",
                        duration: .2
                    })
                },
                onEnterBack: function (t) {
                    return Yi.to("#s-home-start3", {
                        backgroundColor: "#ebd9c8",
                        duration: .2
                    })
                }
            }), document.querySelector("#photoTextWrapper") && ea.create({
                trigger: "#photoTextWrapper",
                start: "center center",
                endTrigger: "#photoContainerEnd",
                end: "bottom center+=150px",
                pin: "#photoTextWrapper",
                scrub: !0
            }), px(this, vx, Yi.timeline({
                yoyo: !0
            })), document.querySelector("#photoCard1") && (dx(this, vx).from("#photoCard1", {
                left: "50%",
                marginLeft: "10%",
                marginTop: 20,
                top: "50%",
                x: "-50%",
                y: "0",
                translateX: "-50%",
                translateY: "-50%",
                rotateZ: -5,
                scale: 1,
                delay: 0,
                ease: "power3.inOut"
            }, 0), dx(this, vx).from("#photoCard2", {
                left: "50%",
                marginLeft: "-10%",
                marginTop: 0,
                top: "50%",
                x: "-50%",
                y: "0",
                translateX: "-50%",
                translateY: "-50%",
                rotateZ: 5,
                scale: 1,
                delay: .05,
                ease: "power3.inOut"
            }, 0), dx(this, vx).from("#photoCard3", {
                left: "50%",
                marginLeft: 0,
                marginTop: -30,
                top: "50%",
                x: "0%",
                y: "-50%",
                translateX: "-50%",
                translateY: "-50%",
                rotateZ: -2,
                scale: 1,
                delay: .1,
                ease: "power3.inOut"
            }, 0), ea.create({
                trigger: "#photoTextWrapper",
                start: "center center",
                end: "bottom bottom",
                endTrigger: "#photoCardsWrapper",
                pin: "#photoCards",
                scrub: !0,
                animation: dx(this, vx)
            })), document.querySelector("#showreelVideoContainer") && Yi.from("#showreelVideoContainer", {
                width: "50%",
                height: "40%",
                borderRadius: "300px",
                repeatRefresh: !0,
                scrollTrigger: {
                    trigger: "#showreelVideoContainer",
                    start: "top bottom",
                    end: "bottom center",
                    scrub: 1,
                    ease: "power4.out"
                }
            }), document.querySelector(".whoheader") && (Yi.from(".whoheader .text1", {
                marginLeft: "-150px",
                scrollTrigger: {
                    trigger: ".whoheader",
                    start: "top bottom",
                    end: "center center",
                    scrub: 1,
                    ease: "power4.out"
                }
            }), Yi.from(".whoheader .text2", {
                marginLeft: "300px",
                scrollTrigger: {
                    trigger: ".whoheader",
                    start: "top bottom",
                    end: "center center",
                    scrub: 1,
                    ease: "power4.out"
                }
            }))
        }

        function Ox() {
            var t;
            document.querySelector("#homeAnimation") && (t = document.getElementById("homeAnimation"));
            var e = window.innerWidth,
                n = window.innerHeight;
            this.camera = new gp(70, e / n, .01, 20), this.camera.position.z = 1.5, this.scene = new dv, this.renderer = new hv({
                antialias: !0,
                alpha: !0
            }), this.renderer.toneMapping = du, this.renderer.toneMappingExposure = 1, this.renderer.outputColorSpace = Qu, this.renderer.setSize(e, n), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.outputColorSpace = Qu, t && t.appendChild(this.renderer.domElement);
            getComputedStyle(document.documentElement).getPropertyValue("--color-background").replace("#", "0x");
            new Z_(2500134).intensity = 1;
            var i = new K_(16777215, 1);
            i.position.set(0, 30, 10), this.scene.add(i);
            var r, s, o = this,
                a = new $p(this.renderer);

            function l(t) {
                o.renderer && null != o.tempProgress && o.tempProgress < 1 && o.renderer.render(o.scene, o.camera)
            }
            a.compileEquirectangularShader(), (new rx).load("assets/3d/nz.hdr", (function (t) {
                var e = a.fromEquirectangular(t).texture;
                o.scene.environment = e, t.dispose(), a.dispose()
            })), (new ay).load("assets/3d/camera_v2.glb", (function (t) {
                t.scene.traverse((function (t) {
                        "Group" == t.type && (o.cameraModel = t), "Wrfel1" == t.name && (o.cameraMonitor = t), "videolayer" == t.name && (o.videoLayer = t)
                    })), o.scene.add(t.scene),
                    function (t) {
                        var e = t,
                            n = document.getElementById("videoIntro");
                        if (e && n) {
                            n.src || (window.innerWidth < 800 ? n.src = "assets/videos/Portfolio Trailer.mp4" : "probably" === n.canPlayType('video/mp4; codecs="H.264"') ? n.src = "assets/videos/Portfolio Trailer.mp4" : n.src = "assets/videos/Portfolio Trailer.mp4"), n.muted = !0, n.loop = !0, n.autoplay = !0, n.playsinline = !0;
                            var i = n.play();
                            void 0 !== i && i.then((function (t) {})).catch((function (t) {
                                n.play()
                            })), (r = new r_(n)).flipY = !1, r.colorSpace = Qu, s = new Mf({
                                map: r
                            }), e.material = s
                        }
                    }(o.videoLayer), fx(o, Mx, Rx).call(o, 0), o.renderer.setAnimationLoop(l)
            }))
        }
            

        function Ix(t) {
            return Ix = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Ix(t)
        }

        function Dx(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Nx(i.key), i)
            }
        }

        function Nx(t) {
            var e = function (t, e) {
                if ("object" != Ix(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" != Ix(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == Ix(e) ? e : String(e)
        }
        var Ux, kx, Fx, zx, Bx, Hx, Vx, Gx, Wx = function () {
                function t() {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t)
                }
                var e, n, i;
                return e = t, (n = [{
                    key: "init",
                    value: function (t, e, n, i, r) {
                        Yi.from(".videoBackground", {
                            height: "0%",
                            duration: .25
                        }), Yi.from(".videoplayerInnerWrapper", {
                            opacity: 0,
                            delay: .25,
                            duration: .5
                        });
                        var s = document.querySelector("#videoplayer"),
                            o = (document.querySelector("#videoplayerInnerWrapper"), s.querySelector("#videoContainer")),
                            a = null,
                            l = s.querySelector("#playPauseBtn"),
                            c = s.querySelector("#closeBtn"),
                            u = l.querySelector(".playPauseText"),
                            h = s.querySelector("#fullscreenBtn"),
                            d = s.querySelector("#seekbarProgress"),
                            f = s.querySelector("#seekbarWrapper"),
                            p = s.querySelector("#seekbarMarker");
                        d.style.width = 0, p.style.left = 0;
                        var m = s.querySelector(".loading");
                        m.style.display = "block", s.querySelector(".videoMouseFollower");
                        var g, v = s.querySelector(".nameText"),
                            _ = s.querySelector("#seekbarImages").querySelectorAll(".img");
                        if (_.forEach((function (t, e) {
                                var n = r + "thumb_" + e + ".jpg";
                                t.style.backgroundImage = "url('" + n + "')"
                            })), o) {
                            var y;
                            o.innerHTML = "", s.classList.add("open"), document.body.classList.add("disableScroll"), (a = document.createElement("video")).autoplay = !0, a.setAttribute("playsinline", ""), v.innerHTML = i || "";
                            try {
                                Hls,
                                y = !0
                            }
                            catch (t) {
                                y = !1
                            }
                            n ? a.canPlayType("application/vnd.apple.mpegurl") ? a.src = n : y && Hls.isSupported() ? ((g = new Hls).loadSource(n), g.attachMedia(a), g.on(Hls.Events.MANIFEST_PARSED, (function () {
                                window.innerWidth < 800 ? g.startLevel = 0 : g.startLevel = 1
                            }))) : b() : b(), o.appendChild(a), l.addEventListener("click", M), c.addEventListener("click", (function t() {
                                w(), l.removeEventListener("click", M), c.removeEventListener("click", t), h.removeEventListener("click", E), a.removeEventListener("click", M), f.removeEventListener("click", S), g && g.destroy(), a.pause(), a.removeAttribute("src"), a.load(), a.src = "", a.srcObject = null, a.remove(), o.innerHTML = "", s.classList.remove("open"), document.body.classList.remove("disableScroll")
                            })), h.addEventListener("click", E), a.addEventListener("click", M), f.addEventListener("click", S), a.ontimeupdate = function () {
                                m.style.display = "none", a.paused ? (u.textContent = "PLAY", u.dataset.linktext = "PLAY") : (u.textContent = "PAUSE", u.dataset.linktext = "PAUSE");
                                var t = a.currentTime / a.duration * 100;
                                d.style.width = t.toFixed(2) + "%", p.style.left = t.toFixed(2) + "%";
                                var e, n = Math.floor(t / 5);
                                e = n, _.forEach((function (t, n) {
                                    n <= e ? t.classList.add("active") : t.classList.remove("active")
                                }))
                            }, a.onpause = function () {
                                u.textContent = "PLAY", u.dataset.linktext = "PLAY"
                            }, a.onplay = function () {
                                u.textContent = "PAUSE", u.dataset.linktext = "PAUSE"
                            }
                        }

                        function x(t, e, n) {
                            var i = document.createElement("source");
                            i.src = e, i.type = n, t.appendChild(i)
                        }

                        function b() {
                            e && x(a, e, "video/webm"), t && x(a, t, "video/mp4")
                        }

                        function S(t) {
                            var e = f.getBoundingClientRect(),
                                n = (t.clientX - e.left) / e.width * 100 / 100 * a.duration;
                            a.currentTime = n
                        }

                        function E() {
                            window.innerWidth <= 800 ? T(a) : T(s)
                        }

                        function M() {
                            a && (a.paused ? (u.textContent = "PAUSE", u.dataset.linktext = "PAUSE", a.play()) : (u.textContent = "PLAY", u.dataset.linktext = "PLAY", a.pause()))
                        }

                        function w() {
                            document.cancelFullScreen ? document.cancelFullScreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.webkitExitFullScreen && (a.setAttribute("playsinline", ""), document.webkitExitFullScreen())
                        }

                        function T(t) {
                            document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement ? w() : t.requestFullscreen ? t.requestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.webkitEnterFullScreen && (a.setAttribute("playsinline", !1), t.webkitEnterFullScreen())
                        }
                    }
                }]) && Dx(e.prototype, n), i && Dx(e, i), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), t
            }(),
            jx = function () {
                return "undefined" != typeof window
            },
            Xx = function () {
                return Ux || jx() && (Ux = window.gsap) && Ux.registerPlugin && Ux
            },
            qx = function (t) {
                return "string" == typeof t
            },
            Yx = function (t) {
                return "function" == typeof t
            },
            Kx = function (t, e) {
                var n = "x" === e ? "Width" : "Height",
                    i = "scroll" + n,
                    r = "client" + n;
                return t === Fx || t === zx || t === Bx ? Math.max(zx[i], Bx[i]) - (Fx["inner" + n] || zx[r] || Bx[r]) : t[i] - t["offset" + n]
            },
            Zx = function (t, e) {
                var n = "scroll" + ("x" === e ? "Left" : "Top");
                return t === Fx && (null != t.pageXOffset ? n = "page" + e.toUpperCase() + "Offset" : t = null != zx[n] ? zx : Bx),
                    function () {
                        return t[n]
                    }
            },
            Jx = function (t, e) {
                if (!(t = Hx(t)[0]) || !t.getBoundingClientRect) return {
                    x: 0,
                    y: 0
                };
                var n = t.getBoundingClientRect(),
                    i = !e || e === Fx || e === Bx,
                    r = i ? {
                        top: zx.clientTop - (Fx.pageYOffset || zx.scrollTop || Bx.scrollTop || 0),
                        left: zx.clientLeft - (Fx.pageXOffset || zx.scrollLeft || Bx.scrollLeft || 0)
                    } : e.getBoundingClientRect(),
                    s = {
                        x: n.left - r.left,
                        y: n.top - r.top
                    };
                return !i && e && (s.x += Zx(e, "x")(), s.y += Zx(e, "y")()), s
            },
            $x = function (t, e, n, i, r) {
                return isNaN(t) || "object" == typeof t ? qx(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + i - r : "max" === t ? Kx(e, n) - r : Math.min(Kx(e, n), Jx(t, e)[n] - r) : parseFloat(t) - r
            },
            Qx = function () {
                Ux = Xx(), jx() && Ux && "undefined" != typeof document && document.body && (Fx = window, Bx = document.body, zx = document.documentElement, Hx = Ux.utils.toArray, Ux.config({
                    autoKillThreshold: 7
                }), Vx = Ux.config(), kx = 1)
            },
            tb = {
                version: "3.12.5",
                name: "scrollTo",
                rawVars: 1,
                register: function (t) {
                    Ux = t, Qx()
                },
                init: function (t, e, n, i, r) {
                    kx || Qx();
                    var s = this,
                        o = Ux.getProperty(t, "scrollSnapType");
                    s.isWin = t === Fx, s.target = t, s.tween = n, e = function (t, e, n, i) {
                        if (Yx(t) && (t = t(e, n, i)), "object" != typeof t) return qx(t) && "max" !== t && "=" !== t.charAt(1) ? {
                            x: t,
                            y: t
                        } : {
                            y: t
                        };
                        if (t.nodeType) return {
                            y: t,
                            x: t
                        };
                        var r, s = {};
                        for (r in t) s[r] = "onAutoKill" !== r && Yx(t[r]) ? t[r](e, n, i) : t[r];
                        return s
                    }(e, i, t, r), s.vars = e, s.autoKill = !!e.autoKill, s.getX = Zx(t, "x"), s.getY = Zx(t, "y"), s.x = s.xPrev = s.getX(), s.y = s.yPrev = s.getY(), Gx || (Gx = Ux.core.globals().ScrollTrigger), "smooth" === Ux.getProperty(t, "scrollBehavior") && Ux.set(t, {
                        scrollBehavior: "auto"
                    }), o && "none" !== o && (s.snap = 1, s.snapInline = t.style.scrollSnapType, t.style.scrollSnapType = "none"), null != e.x ? (s.add(s, "x", s.x, $x(e.x, t, "x", s.x, e.offsetX || 0), i, r), s._props.push("scrollTo_x")) : s.skipX = 1, null != e.y ? (s.add(s, "y", s.y, $x(e.y, t, "y", s.y, e.offsetY || 0), i, r), s._props.push("scrollTo_y")) : s.skipY = 1
                },
                render: function (t, e) {
                    for (var n, i, r, s, o, a = e._pt, l = e.target, c = e.tween, u = e.autoKill, h = e.xPrev, d = e.yPrev, f = e.isWin, p = e.snap, m = e.snapInline; a;) a.r(t, a.d), a = a._next;
                    n = f || !e.skipX ? e.getX() : h, r = (i = f || !e.skipY ? e.getY() : d) - d, s = n - h, o = Vx.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), u && (!e.skipX && (s > o || s < -o) && n < Kx(l, "x") && (e.skipX = 1), !e.skipY && (r > o || r < -o) && i < Kx(l, "y") && (e.skipY = 1), e.skipX && e.skipY && (c.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(c, e.vars.onAutoKillParams || []))), f ? Fx.scrollTo(e.skipX ? n : e.x, e.skipY ? i : e.y) : (e.skipY || (l.scrollTop = e.y), e.skipX || (l.scrollLeft = e.x)), !p || 1 !== t && 0 !== t || (i = l.scrollTop, n = l.scrollLeft, m ? l.style.scrollSnapType = m : l.style.removeProperty("scroll-snap-type"), l.scrollTop = i + 1, l.scrollLeft = n + 1, l.scrollTop = i, l.scrollLeft = n), e.xPrev = e.x, e.yPrev = e.y, Gx && Gx.update()
                },
                kill: function (t) {
                    var e = "scrollTo" === t,
                        n = this._props.indexOf(t);
                    return (e || "scrollTo_x" === t) && (this.skipX = 1), (e || "scrollTo_y" === t) && (this.skipY = 1), n > -1 && this._props.splice(n, 1), !this._props.length
                }
            };
        tb.max = Kx, tb.getOffset = Jx, tb.buildGetter = Zx, Xx() && Ux.registerPlugin(tb);
        n(442);

        function eb(t, e) {
            var n = "function" == typeof Symbol && t[Symbol.iterator];
            if (!n) return t;
            var i, r, s = n.call(t),
                o = [];
            try {
                for (;
                    (void 0 === e || e-- > 0) && !(i = s.next()).done;) o.push(i.value)
            } catch (t) {
                r = {
                    error: t
                }
            } finally {
                try {
                    i && !i.done && (n = s.return) && n.call(s)
                } finally {
                    if (r) throw r.error
                }
            }
            return o
        }

        function nb() {
            for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(eb(arguments[e]));
            return t
        }
        var ib = function (t) {
                return void 0 === t
            },
            rb = function () {
                function t(t, e) {
                    var n, i;
                    if (this._canceled = !1, e) try {
                        for (var r = function (t) {
                                var e = "function" == typeof Symbol && Symbol.iterator,
                                    n = e && t[e],
                                    i = 0;
                                if (n) return n.call(t);
                                if (t && "number" == typeof t.length) return {
                                    next: function () {
                                        return t && i >= t.length && (t = void 0), {
                                            value: t && t[i++],
                                            done: !t
                                        }
                                    }
                                };
                                throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
                            }(Object.keys(e)), s = r.next(); !s.done; s = r.next()) {
                            var o = s.value;
                            this[o] = e[o]
                        }
                    } catch (t) {
                        n = {
                            error: t
                        }
                    } finally {
                        try {
                            s && !s.done && (i = r.return) && i.call(r)
                        } finally {
                            if (n) throw n.error
                        }
                    }
                    this.eventType = t
                }
                var e = t.prototype;
                return e.stop = function () {
                    this._canceled = !0
                }, e.isCanceled = function () {
                    return this._canceled
                }, t
            }(),
            sb = function () {
                function t() {
                    this._eventHandler = {}
                }
                var e = t.prototype;
                return e.trigger = function (t) {
                    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
                    var i = t instanceof rb ? t.eventType : t,
                        r = nb(this._eventHandler[i] || []);
                    return r.length <= 0 || (t instanceof rb ? (t.currentTarget = this, r.forEach((function (e) {
                        e(t)
                    }))) : r.forEach((function (t) {
                        t.apply(void 0, nb(e))
                    }))), this
                }, e.once = function (t, e) {
                    var n = this;
                    if ("object" == typeof t && ib(e)) {
                        var i = t;
                        for (var r in i) this.once(r, i[r]);
                        return this
                    }
                    if ("string" == typeof t && "function" == typeof e) {
                        var s = function () {
                            for (var i = [], r = 0; r < arguments.length; r++) i[r] = arguments[r];
                            e.apply(void 0, nb(i)), n.off(t, s)
                        };
                        this.on(t, s)
                    }
                    return this
                }, e.hasOn = function (t) {
                    return !!this._eventHandler[t]
                }, e.on = function (t, e) {
                    if ("object" == typeof t && ib(e)) {
                        var n = t;
                        for (var i in n) this.on(i, n[i]);
                        return this
                    }
                    if ("string" == typeof t && "function" == typeof e) {
                        var r = this._eventHandler[t];
                        ib(r) && (this._eventHandler[t] = [], r = this._eventHandler[t]), r.push(e)
                    }
                    return this
                }, e.off = function (t, e) {
                    if (ib(t)) return this._eventHandler = {}, this;
                    if (ib(e)) {
                        if ("string" == typeof t) return delete this._eventHandler[t], this;
                        var n = t;
                        for (var i in n) this.off(i, n[i]);
                        return this
                    }
                    var r = this._eventHandler[t];
                    if (r)
                        for (var s = r.length, o = 0; o < s; ++o)
                            if (r[o] === e) {
                                r.splice(o, 1), s <= 1 && delete this._eventHandler[t];
                                break
                            } return this
                }, t.VERSION = "3.0.5", t
            }(),
            ob = rb;
        const ab = sb;

        function lb(t, e) {
            for (var n = t.length, i = 0; i < n; ++i)
                if (e(t[i], i)) return !0;
            return !1
        }

        function cb(t, e) {
            for (var n = t.length, i = 0; i < n; ++i)
                if (e(t[i], i)) return t[i];
            return null
        }

        function ub(t) {
            var e = t;
            if (void 0 === e) {
                if ("undefined" == typeof navigator || !navigator) return "";
                e = navigator.userAgent || ""
            }
            return e.toLowerCase()
        }

        function hb(t, e) {
            try {
                return new RegExp(t, "g").exec(e)
            } catch (t) {
                return null
            }
        }

        function db() {
            if ("undefined" == typeof navigator || !navigator || !navigator.userAgentData) return !1;
            var t = navigator.userAgentData,
                e = t.brands || t.uaList;
            return !(!e || !e.length)
        }

        function fb(t) {
            return t.replace(/_/g, ".")
        }

        function pb(t, e) {
            var n = null,
                i = "-1";
            return lb(t, (function (t) {
                var r = hb("(" + t.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", e);
                return !(!r || t.brand) && (n = t, i = r[3] || "-1", t.versionAlias ? i = t.versionAlias : t.versionTest && (i = function (t, e) {
                    var n = hb("(" + t + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", e);
                    return n ? n[3] : ""
                }(t.versionTest.toLowerCase(), e) || i), i = fb(i), !0)
            })), {
                preset: n,
                version: i
            }
        }

        function mb(t, e) {
            var n = {
                brand: "",
                version: "-1"
            };
            return lb(t, (function (t) {
                var i = gb(e, t);
                return !!i && (n.brand = t.id, n.version = t.versionAlias || i.version, "-1" !== n.version)
            })), n
        }

        function gb(t, e) {
            return cb(t, (function (t) {
                var n = t.brand;
                return hb("" + e.test, n.toLowerCase())
            }))
        }
        var vb = [{
                test: "phantomjs",
                id: "phantomjs"
            }, {
                test: "whale",
                id: "whale"
            }, {
                test: "edgios|edge|edg",
                id: "edge"
            }, {
                test: "msie|trident|windows phone",
                id: "ie",
                versionTest: "iemobile|msie|rv"
            }, {
                test: "miuibrowser",
                id: "miui browser"
            }, {
                test: "samsungbrowser",
                id: "samsung internet"
            }, {
                test: "samsung",
                id: "samsung internet",
                versionTest: "version"
            }, {
                test: "chrome|crios",
                id: "chrome"
            }, {
                test: "firefox|fxios",
                id: "firefox"
            }, {
                test: "android",
                id: "android browser",
                versionTest: "version"
            }, {
                test: "safari|iphone|ipad|ipod",
                id: "safari",
                versionTest: "version"
            }],
            _b = [{
                test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
                id: "chrome",
                versionTest: "chrome"
            }, {
                test: "chromium",
                id: "chrome"
            }, {
                test: "whale",
                id: "chrome",
                versionAlias: "-1",
                brand: !0
            }],
            yb = [{
                test: "applewebkit",
                id: "webkit",
                versionTest: "applewebkit|safari"
            }],
            xb = [{
                test: "(?=(iphone|ipad))(?!(.*version))",
                id: "webview"
            }, {
                test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
                id: "webview"
            }, {
                test: "webview",
                id: "webview"
            }],
            bb = [{
                test: "windows phone",
                id: "windows phone"
            }, {
                test: "windows 2000",
                id: "window",
                versionAlias: "5.0"
            }, {
                test: "windows nt",
                id: "window"
            }, {
                test: "win32|windows",
                id: "window"
            }, {
                test: "iphone|ipad|ipod",
                id: "ios",
                versionTest: "iphone os|cpu os"
            }, {
                test: "macos|macintel|mac os x",
                id: "mac"
            }, {
                test: "android|linux armv81",
                id: "android"
            }, {
                test: "tizen",
                id: "tizen"
            }, {
                test: "webos|web0s",
                id: "webos"
            }];

        function Sb(t) {
            return !!pb(xb, t).preset
        }

        function Eb(t) {
            var e = navigator.userAgentData,
                n = (e.uaList || e.brands).slice(),
                i = t && t.fullVersionList,
                r = e.mobile || !1,
                s = n[0],
                o = (t && t.platform || e.platform || navigator.platform).toLowerCase(),
                a = {
                    name: s.brand,
                    version: s.version,
                    majorVersion: -1,
                    webkit: !1,
                    webkitVersion: "-1",
                    chromium: !1,
                    chromiumVersion: "-1",
                    webview: !!mb(xb, n).brand || Sb(ub())
                },
                l = {
                    name: "unknown",
                    version: "-1",
                    majorVersion: -1
                };
            a.webkit = !a.chromium && lb(yb, (function (t) {
                return gb(n, t)
            }));
            var c = mb(_b, n);
            if (a.chromium = !!c.brand, a.chromiumVersion = c.version, !a.chromium) {
                var u = mb(yb, n);
                a.webkit = !!u.brand, a.webkitVersion = u.version
            }
            var h = cb(bb, (function (t) {
                return new RegExp("" + t.test, "g").exec(o)
            }));
            if (l.name = h ? h.id : "", t && (l.version = t.platformVersion), i && i.length) {
                var d = mb(vb, i);
                a.name = d.brand || a.name, a.version = d.version || a.version
            } else {
                var f = mb(vb, n);
                a.name = f.brand || a.name, a.version = f.brand && t ? t.uaFullVersion : f.version
            }
            return a.webkit && (l.name = r ? "ios" : "mac"), "ios" === l.name && a.webview && (a.version = "-1"), l.version = fb(l.version), a.version = fb(a.version), l.majorVersion = parseInt(l.version, 10), a.majorVersion = parseInt(a.version, 10), {
                browser: a,
                os: l,
                isMobile: r,
                isHints: !0
            }
        }

        function Mb(t) {
            return void 0 === t && db() ? Eb() : function (t) {
                var e = ub(t),
                    n = !!/mobi/g.exec(e),
                    i = {
                        name: "unknown",
                        version: "-1",
                        majorVersion: -1,
                        webview: Sb(e),
                        chromium: !1,
                        chromiumVersion: "-1",
                        webkit: !1,
                        webkitVersion: "-1"
                    },
                    r = {
                        name: "unknown",
                        version: "-1",
                        majorVersion: -1
                    },
                    s = pb(vb, e),
                    o = s.preset,
                    a = s.version,
                    l = pb(bb, e),
                    c = l.preset,
                    u = l.version,
                    h = pb(_b, e);
                if (i.chromium = !!h.preset, i.chromiumVersion = h.version, !i.chromium) {
                    var d = pb(yb, e);
                    i.webkit = !!d.preset, i.webkitVersion = d.version
                }
                return c && (r.name = c.id, r.version = u, r.majorVersion = parseInt(u, 10)), o && (i.name = o.id, i.version = a, i.webview && "ios" === r.name && "safari" !== i.name && (i.webview = !1)), i.majorVersion = parseInt(i.version, 10), {
                    browser: i,
                    os: r,
                    isMobile: n,
                    isHints: !1
                }
            }(t)
        }
        const wb = Mb;

        function Tb(t) {
            return Object.keys(t)
        }
        var Ab = "__observers__",
            Pb = "__computed__",
            Cb = 1,
            Rb = "__CFCS_DETECTED_DEPENDENCIES__",
            Lb = function (t, e) {
                return Lb = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function (t, e) {
                    t.__proto__ = e
                } || function (t, e) {
                    for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
                }, Lb(t, e)
            };

        function Ob() {
            Object[Rb] = Object[Rb] || {};
            var t = Object[Rb];
            return t[Cb] = t[Cb] || [], t[Cb]
        }
        var Ib = function () {
                function t(t) {
                    this._emitter = new ab, this._current = t
                }
                var e = t.prototype;
                return Object.defineProperty(e, "current", {
                    get: function () {
                        var t, e = (t = Ob())[t.length - 1];
                        return null == e || e.push(this), this._current
                    },
                    set: function (t) {
                        this._setCurrent(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.subscribe = function (t) {
                    return this.current, this._emitter.on("update", t), this
                }, e.unsubscribe = function (t) {
                    return this._emitter.off("update", t), this
                }, e._setCurrent = function (t) {
                    var e = this._current,
                        n = t !== e;
                    this._current = t, n && this._emitter.trigger("update", t, e)
                }, e.toString = function () {
                    return "".concat(this.current)
                }, e.valueOf = function () {
                    return this.current
                }, t
            }(),
            Db = function (t) {
                function e(e) {
                    var n = t.call(this) || this;
                    return n._computedCallback = e, n._registered = [], n._onCheckUpdate = function () {
                        n._setCurrent(n.current)
                    }, n._current = n.current, n
                }! function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");

                    function n() {
                        this.constructor = t
                    }
                    Lb(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
                }(e, t);
                var n = e.prototype;
                return Object.defineProperty(n, "current", {
                    get: function () {
                        var t, e, n, i, r = this;
                        t = this, e = Ob(), i = {
                            host: t,
                            observers: n = [],
                            push: function (e) {
                                t !== e && -1 === n.indexOf(e) && n.push(e)
                            }
                        }, e.push(i);
                        var s = this._computedCallback(),
                            o = Ob().pop();
                        return this._registered.forEach((function (t) {
                            t.unsubscribe(r._onCheckUpdate)
                        })), o.observers.forEach((function (t) {
                            t.subscribe(r._onCheckUpdate)
                        })), this._registered = o.observers, s
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(Ib);

        function Nb(t, e, n) {
            void 0 === n && (n = e);
            var i = {
                configurable: !0,
                get: function () {
                    return Vb(this, n).current
                },
                set: function (t) {
                    Vb(this, n, t).current = t
                }
            };
            Object.defineProperty(t, e, i), n !== e && Object.defineProperty(t, n, {
                configurable: !0,
                get: function () {
                    return Vb(this, n).current
                }
            })
        }

        function Ub() {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            return t.length > 1 ? Nb(t[0], t[1]) : function (e, n) {
                return Nb(e, n, t[0])
            }
        }

        function kb(t) {
            t.subscribe = function (t, e) {
                this[t], Vb(this, t).subscribe(e)
            }, t.unsubscribe = function (t, e) {
                var n = this;
                t ? t in this && Vb(this, t).unsubscribe(e) : Tb(Hb(this)).forEach((function (t) {
                    n.unsubscribe(t)
                }))
            }
        }

        function Fb(t) {
            kb(t.prototype)
        }

        function zb(t) {
            return new Ib(t)
        }

        function Bb(t) {
            var e = {};
            return Object.defineProperty(t, Ab, {
                get: function () {
                    return e
                }
            }), e
        }

        function Hb(t, e) {
            var n, i;
            t[Ab] || Bb(t);
            var r = t[Ab];
            if (!e) {
                var s = null === (i = null === (n = null == t ? void 0 : t.constructor) || void 0 === n ? void 0 : n.prototype) || void 0 === i ? void 0 : i[Pb];
                s && s.forEach((function (e) {
                    !(e in r) && e in t && t[e]
                }))
            }
            return r
        }

        function Vb(t, e, n) {
            var i = Hb(t);
            return i[e] || (i[e] = zb(n)), i[e]
        }

        function Gb(t, e, n) {
            var i = n.get;
            var r = {
                configurable: !0,
                get: function () {
                    var t, n = Hb(this, !0);
                    return e in n || (n[e] = (t = i.bind(this), new Db(t))), Vb(this, e).current
                }
            };
            t[Pb] || (t[Pb] = []);
            var s = t[Pb];
            return -1 === s.indexOf(e) && s.push(e), Object.defineProperty(t, e, r), r
        }
        var Wb = function (t, e) {
            return Wb = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            }, Wb(t, e)
        };

        function jb(t, e) {
            function n() {
                this.constructor = t
            }
            Wb(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var Xb, qb = function () {
            return qb = Object.assign || function (t) {
                for (var e, n = 1, i = arguments.length; n < i; n++)
                    for (var r in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                return t
            }, qb.apply(this, arguments)
        };

        function Yb(t, e, n, i) {
            var r, s = arguments.length,
                o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(t, e, n, i);
            else
                for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o), o
        }
        Xb = "undefined" == typeof window ? {
            navigator: {
                userAgent: ""
            }
        } : window;
        var Kb = 24,
            Zb = "left",
            Jb = "right",
            $b = "middle",
            Qb = {
                1: Zb,
                2: $b,
                3: Jb
            },
            tS = "any",
            eS = "ontouchstart" in Xb && "safari" === wb().browser.name,
            nS = function () {
                if ("undefined" == typeof document) return "";
                for (var t = (document.head || document.getElementsByTagName("head")[0]).style, e = ["transform", "webkitTransform", "msTransform", "mozTransform"], n = 0, i = e.length; n < i; n++)
                    if (e[n] in t) return e[n];
                return ""
            }(),
            iS = {
                "-webkit-user-select": "none",
                "-ms-user-select": "none",
                "-moz-user-select": "none",
                "user-select": "none",
                "-webkit-user-drag": "none"
            },
            rS = function (t) {
                for (var e = [], n = 0, i = t.length; n < i; n++) e.push(t[n]);
                return e
            },
            sS = function (t, e) {
                var n;
                if (void 0 === e && (e = !1), "string" == typeof t) {
                    if (t.match(/^<([a-z]+)\s*([^>]*)>/)) {
                        var i = document.createElement("div");
                        i.innerHTML = t, n = rS(i.childNodes)
                    } else n = rS(document.querySelectorAll(t));
                    e || (n = n.length >= 1 ? n[0] : void 0)
                } else t === Xb ? n = t : "value" in t || "current" in t ? n = t.value || t.current : !t.nodeName || 1 !== t.nodeType && 9 !== t.nodeType ? "jQuery" in Xb && t instanceof jQuery || t.constructor.prototype.jquery ? n = e ? t.toArray() : t.get(0) : Array.isArray(t) && (n = t.map((function (t) {
                    return sS(t)
                })), e || (n = n.length >= 1 ? n[0] : void 0)) : n = t;
                return n
            },
            oS = Xb.requestAnimationFrame || Xb.webkitRequestAnimationFrame,
            aS = Xb.cancelAnimationFrame || Xb.webkitCancelAnimationFrame;
        if (oS && !aS) {
            var lS = {},
                cS = oS;
            oS = function (t) {
                var e = cS((function (n) {
                    lS[e] && t(n)
                }));
                return lS[e] = !0, e
            }, aS = function (t) {
                delete lS[t]
            }
        } else oS && aS || (oS = function (t) {
            return Xb.setTimeout((function () {
                t(Xb.performance && Xb.performance.now && Xb.performance.now() || (new Date).getTime())
            }), 16)
        }, aS = Xb.clearTimeout);
        var uS = function (t, e) {
                var n = {};
                for (var i in t) i && (n[i] = e(t[i], i));
                return n
            },
            hS = function (t, e) {
                var n = {};
                for (var i in t) i && e(t[i], i) && (n[i] = t[i]);
                return n
            },
            dS = function (t, e) {
                for (var n in t)
                    if (n && !e(t[n], n)) return !1;
                return !0
            },
            fS = function (t, e) {
                return dS(t, (function (t, n) {
                    return t === e[n]
                }))
            },
            pS = {},
            mS = function (t, e) {
                return pS[e] || (pS[e] = _S(e)), pS[e](t)
            },
            gS = function (t, e) {
                return t && e ? uS(t, (function (t, n) {
                    return mS(t, "number" == typeof e ? e : e[n])
                })) : t
            },
            vS = function (t) {
                if (!isFinite(t)) return 0;
                var e = "".concat(t);
                if (e.indexOf("e") >= 0) {
                    for (var n = 0, i = 1; Math.round(t * i) / i !== t;) i *= 10, n++;
                    return n
                }
                return e.indexOf(".") >= 0 ? e.length - e.indexOf(".") - 1 : 0
            },
            _S = function (t) {
                var e = t < 1 ? Math.pow(10, vS(t)) : 1;
                return function (n) {
                    return 0 === t ? 0 : Math.round(Math.round(n / t) * t * e) / e
                }
            },
            yS = function (t, e) {
                return 180 * Math.atan2(e, t) / Math.PI
            },
            xS = function (t) {
                var e = !0;
                return Object.keys(iS).forEach((function (n) {
                    t && t[n] === iS[n] || (e = !1)
                })), e
            },
            bS = function (t, e) {
                return t && e ? 30 : t ? 6 : e ? Kb : 1
            },
            SS = function (t, e, n) {
                return n ? !!(30 === e || e & t && n & t) : !!(e & t)
            },
            ES = function (t, e, n) {
                var i, r = ((i = {})[1] = "auto", i[30] = "none", i[24] = "pan-x", i[6] = "pan-y", i),
                    s = {};
                if (t && t.style) {
                    var o = e.touchAction ? e.touchAction : r[n],
                        a = qb(qb({}, iS), {
                            "touch-action": "none" === t.style["touch-action"] ? "none" : o
                        });
                    Object.keys(a).forEach((function (e) {
                        s[e] = t.style[e], t.style[e] = a[e]
                    }))
                }
                return s
            },
            MS = function (t, e) {
                t && t.style && e && Object.keys(e).forEach((function (n) {
                    t.style[n] = e[n]
                }))
            },
            wS = function () {
                function t(t) {
                    this._axes = t, this.holdingCount = 0
                }
                var e = t.prototype;
                return e.hold = function (t, e) {
                    var n = this._getRoundPos(t).roundPos;
                    this._axes.trigger(new ob("hold", {
                        pos: n,
                        input: e.input || null,
                        inputEvent: e.event || null,
                        isTrusted: !0
                    }))
                }, e.triggerRelease = function (t) {
                    var e = this._getRoundPos(t.destPos, t.depaPos),
                        n = e.roundPos,
                        i = e.roundDepa;
                    t.destPos = n, t.depaPos = i, t.setTo = this._createUserControll(t.destPos, t.duration), this._axes.trigger(new ob("release", qb(qb({}, t), {
                        bounceRatio: this._getBounceRatio(n)
                    })))
                }, e.triggerChange = function (t, e, n, i) {
                    var r = this;
                    void 0 === i && (i = !1);
                    var s = this.animationManager,
                        o = s.axisManager,
                        a = s.getEventInfo(),
                        l = this._getRoundPos(t, e),
                        c = l.roundPos,
                        u = l.roundDepa,
                        h = o.moveTo(c, u),
                        d = (null == n ? void 0 : n.event) || (null == a ? void 0 : a.event) || null,
                        f = {
                            pos: h.pos,
                            delta: h.delta,
                            bounceRatio: this._getBounceRatio(h.pos),
                            holding: i,
                            inputEvent: d,
                            isTrusted: !!d,
                            input: (null == n ? void 0 : n.input) || (null == a ? void 0 : a.input) || null,
                            set: d ? this._createUserControll(h.pos) : function () {}
                        },
                        p = new ob("change", f);
                    return this._axes.trigger(p), Object.keys(h.pos).forEach((function (t) {
                        var e = h.pos[t];
                        Vb(r._axes, t, e).current = e
                    })), d && o.set(f.set().destPos), !p.isCanceled()
                }, e.triggerAnimationStart = function (t) {
                    var e = this._getRoundPos(t.destPos, t.depaPos),
                        n = e.roundPos,
                        i = e.roundDepa;
                    t.destPos = n, t.depaPos = i, t.setTo = this._createUserControll(t.destPos, t.duration);
                    var r = new ob("animationStart", t);
                    return this._axes.trigger(r), !r.isCanceled()
                }, e.triggerAnimationEnd = function (t) {
                    void 0 === t && (t = !1), this._axes.trigger(new ob("animationEnd", {
                        isTrusted: t
                    }))
                }, e.triggerFinish = function (t) {
                    void 0 === t && (t = !1), this._axes.trigger(new ob("finish", {
                        isTrusted: t
                    }))
                }, e.setAnimationManager = function (t) {
                    this.animationManager = t
                }, e.destroy = function () {
                    this._axes.off()
                }, e._createUserControll = function (t, e) {
                    void 0 === e && (e = 0);
                    var n = {
                        destPos: qb({}, t),
                        duration: e
                    };
                    return function (t, e) {
                        return t && (n.destPos = qb({}, t)), void 0 !== e && (n.duration = e), n
                    }
                }, e._getRoundPos = function (t, e) {
                    var n = this._axes.options.round;
                    return {
                        roundPos: gS(t, n),
                        roundDepa: gS(e, n)
                    }
                }, e._getBounceRatio = function (t) {
                    return this._axes.axisManager.map(t, (function (t, e) {
                        return t < e.range[0] && 0 !== e.bounce[0] ? (e.range[0] - t) / e.bounce[0] : t > e.range[1] && 0 !== e.bounce[1] ? (t - e.range[1]) / e.bounce[1] : 0
                    }))
                }, Yb([Ub], t.prototype, "holdingCount", void 0), t
            }(),
            TS = function () {
                function t(t) {
                    this._options = t, this._prevented = !1
                }
                var e = t.prototype;
                return e.isInterrupting = function () {
                    return this._options.interruptable || this._prevented
                }, e.isInterrupted = function () {
                    return !this._options.interruptable && this._prevented
                }, e.setInterrupt = function (t) {
                    this._options.interruptable || (this._prevented = t)
                }, t
            }(),
            AS = function (t, e, n, i) {
                var r = t,
                    s = [n[0] ? e[0] : i ? e[0] - i[0] : e[0], n[1] ? e[1] : i ? e[1] + i[1] : e[1]];
                return r = Math.max(s[0], r), r = Math.min(s[1], r)
            },
            PS = function (t, e) {
                return t < e[0] || t > e[1]
            },
            CS = function (t, e, n) {
                return n[1] && t > e[1] || n[0] && t < e[0]
            },
            RS = function (t, e, n) {
                var i = t,
                    r = e[0],
                    s = e[1],
                    o = s - r;
                return n[1] && t > s && (i = (i - s) % o + r), n[0] && t < r && (i = (i - r) % o + s), i
            },
            LS = function () {
                function t(t) {
                    var e = this;
                    this._axis = t, this._complementOptions(), this._pos = Object.keys(this._axis).reduce((function (t, n) {
                        return t[n] = e._axis[n].startPos, t
                    }), {})
                }
                var e = t.prototype;
                return e.getDelta = function (t, e) {
                    var n = this.get(t);
                    return uS(this.get(e), (function (t, e) {
                        return t - n[e]
                    }))
                }, e.get = function (t) {
                    var e = this;
                    return t && Array.isArray(t) ? t.reduce((function (t, n) {
                        return n && n in e._pos && (t[n] = e._pos[n]), t
                    }), {}) : qb(qb({}, this._pos), t || {})
                }, e.moveTo = function (t, e) {
                    void 0 === e && (e = this._pos);
                    var n = uS(this._pos, (function (n, i) {
                        return i in t && i in e ? t[i] - e[i] : 0
                    }));
                    return this.set(this.map(t, (function (t, e) {
                        return e ? RS(t, e.range, e.circular) : 0
                    }))), {
                        pos: qb({}, this._pos),
                        delta: n
                    }
                }, e.set = function (t) {
                    for (var e in t) e && e in this._pos && (this._pos[e] = t[e])
                }, e.every = function (t, e) {
                    var n = this._axis;
                    return dS(t, (function (t, i) {
                        return e(t, n[i], i)
                    }))
                }, e.filter = function (t, e) {
                    var n = this._axis;
                    return hS(t, (function (t, i) {
                        return e(t, n[i], i)
                    }))
                }, e.map = function (t, e) {
                    var n = this._axis;
                    return uS(t, (function (t, i) {
                        return e(t, n[i], i)
                    }))
                }, e.isOutside = function (t) {
                    return !this.every(t ? this.get(t) : this._pos, (function (t, e) {
                        return !PS(t, e.range)
                    }))
                }, e.getAxisOptions = function (t) {
                    return this._axis[t]
                }, e.setAxis = function (t) {
                    var e = this;
                    Object.keys(t).forEach((function (n) {
                        if (!e._axis[n]) throw new Error("Axis ".concat(n, " does not exist in Axes instance"));
                        e._axis[n] = qb(qb({}, e._axis[n]), t[n])
                    })), this._complementOptions()
                }, e._complementOptions = function () {
                    var t = this;
                    Object.keys(this._axis).forEach((function (e) {
                        t._axis[e] = qb({
                            range: [0, 100],
                            startPos: t._axis[e].range[0],
                            bounce: [0, 0],
                            circular: [!1, !1]
                        }, t._axis[e]), ["bounce", "circular"].forEach((function (n) {
                            var i = t._axis,
                                r = i[e][n];
                            /string|number|boolean/.test(typeof r) && (i[e][n] = [r, r])
                        }))
                    }))
                }, t
            }(),
            OS = "ontouchstart" in Xb,
            IS = "PointerEvent" in Xb,
            DS = IS || "MSPointerEvent" in Xb,
            NS = function (t, e) {
                return !!(!e || e.indexOf(tS) > -1 || e.indexOf("none") > -1 && !t.shiftKey && !t.ctrlKey && !t.altKey && !t.metaKey || e.indexOf("shift") > -1 && t.shiftKey || e.indexOf("ctrl") > -1 && t.ctrlKey || e.indexOf("alt") > -1 && t.altKey || e.indexOf("meta") > -1 && t.metaKey)
            },
            US = function () {
                function t() {
                    var t = this;
                    this._stopContextMenu = function (e) {
                        e.preventDefault(), Xb.removeEventListener("contextmenu", t._stopContextMenu)
                    }
                }
                var e = t.prototype;
                return e.extendEvent = function (t) {
                    var e, n = this.prevEvent,
                        i = this._getCenter(t),
                        r = n ? this._getMovement(t) : {
                            x: 0,
                            y: 0
                        },
                        s = n ? this._getScale(t) : 1,
                        o = n ? yS(i.x - n.center.x, i.y - n.center.y) : 0,
                        a = n ? n.deltaX + r.x : r.x,
                        l = n ? n.deltaY + r.y : r.y,
                        c = r.x,
                        u = r.y,
                        h = this._latestInterval,
                        d = Date.now(),
                        f = h ? d - h.timestamp : 0,
                        p = n ? n.velocityX : 0,
                        m = n ? n.velocityY : 0;
                    return (!h || f >= 16) && (h && (p = (e = [(a - h.deltaX) / f, (l - h.deltaY) / f])[0], m = e[1]), this._latestInterval = {
                        timestamp: d,
                        deltaX: a,
                        deltaY: l
                    }), {
                        srcEvent: t,
                        scale: s,
                        angle: o,
                        center: i,
                        deltaX: a,
                        deltaY: l,
                        offsetX: c,
                        offsetY: u,
                        velocityX: p,
                        velocityY: m,
                        preventSystemEvent: !0
                    }
                }, e._getDistance = function (t, e) {
                    var n = e.clientX - t.clientX,
                        i = e.clientY - t.clientY;
                    return Math.sqrt(n * n + i * i)
                }, e._getButton = function (t) {
                    var e = {
                            1: Zb,
                            2: Jb,
                            4: $b
                        },
                        n = this._isTouchEvent(t) ? Zb : e[t.buttons];
                    return n || null
                }, e._isTouchEvent = function (t) {
                    return t.type && t.type.indexOf("touch") > -1
                }, e._isValidButton = function (t, e) {
                    return e.indexOf(t) > -1
                }, e._isValidEvent = function (t, e, n) {
                    return (!e || NS(t, e)) && (!n || this._isValidButton(this._getButton(t), n))
                }, e._preventMouseButton = function (t, e) {
                    e === Jb ? Xb.addEventListener("contextmenu", this._stopContextMenu) : e === $b && t.preventDefault()
                }, t
            }(),
            kS = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.start = ["mousedown"], e.move = ["mousemove"], e.end = ["mouseup"], e
                }
                jb(e, t);
                var n = e.prototype;
                return n.onEventStart = function (t, e, n) {
                    var i = this._getButton(t);
                    return this._isValidEvent(t, e, n) ? (this._preventMouseButton(t, i), this.extendEvent(t)) : null
                }, n.onEventMove = function (t, e, n) {
                    return this._isValidEvent(t, e, n) ? this.extendEvent(t) : null
                }, n.onEventEnd = function () {}, n.onRelease = function () {
                    this.prevEvent = null
                }, n.getTouches = function (t, e) {
                    return e && this._isValidButton(Qb[t.which], e) && -1 === this.end.indexOf(t.type) ? 1 : 0
                }, n._getScale = function () {
                    return 1
                }, n._getCenter = function (t) {
                    return {
                        x: t.clientX,
                        y: t.clientY
                    }
                }, n._getMovement = function (t) {
                    var e = this.prevEvent.srcEvent;
                    return {
                        x: t.clientX - e.clientX,
                        y: t.clientY - e.clientY
                    }
                }, e
            }(US),
            FS = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.start = ["touchstart"], e.move = ["touchmove"], e.end = ["touchend", "touchcancel"], e
                }
                jb(e, t);
                var n = e.prototype;
                return n.onEventStart = function (t, e) {
                    return this._baseTouches = t.touches, this._isValidEvent(t, e) ? this.extendEvent(t) : null
                }, n.onEventMove = function (t, e) {
                    return this._isValidEvent(t, e) ? this.extendEvent(t) : null
                }, n.onEventEnd = function (t) {
                    this._baseTouches = t.touches
                }, n.onRelease = function () {
                    this.prevEvent = null, this._baseTouches = null
                }, n.getTouches = function (t) {
                    return t.touches.length
                }, n._getScale = function (t) {
                    return 2 !== t.touches.length || this._baseTouches.length < 2 ? null : this._getDistance(t.touches[0], t.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1])
                }, n._getCenter = function (t) {
                    return {
                        x: t.touches[0].clientX,
                        y: t.touches[0].clientY
                    }
                }, n._getMovement = function (t) {
                    var e = this.prevEvent.srcEvent;
                    return t.touches[0].identifier !== e.touches[0].identifier ? {
                        x: 0,
                        y: 0
                    } : {
                        x: t.touches[0].clientX - e.touches[0].clientX,
                        y: t.touches[0].clientY - e.touches[0].clientY
                    }
                }, e
            }(US),
            zS = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.start = IS ? ["pointerdown"] : ["MSPointerDown"], e.move = IS ? ["pointermove"] : ["MSPointerMove"], e.end = IS ? ["pointerup", "pointercancel"] : ["MSPointerUp", "MSPointerCancel"], e._firstInputs = [], e._recentInputs = [], e
                }
                jb(e, t);
                var n = e.prototype;
                return n.onEventStart = function (t, e, n) {
                    var i = this._getButton(t);
                    return this._isValidEvent(t, e, n) ? (this._preventMouseButton(t, i), this._updatePointerEvent(t), this.extendEvent(t)) : null
                }, n.onEventMove = function (t, e, n) {
                    return this._isValidEvent(t, e, n) ? (this._updatePointerEvent(t), this.extendEvent(t)) : null
                }, n.onEventEnd = function (t) {
                    this._removePointerEvent(t)
                }, n.onRelease = function () {
                    this.prevEvent = null, this._firstInputs = [], this._recentInputs = []
                }, n.getTouches = function () {
                    return this._recentInputs.length
                }, n._getScale = function () {
                    return 2 !== this._recentInputs.length ? null : this._getDistance(this._recentInputs[0], this._recentInputs[1]) / this._getDistance(this._firstInputs[0], this._firstInputs[1])
                }, n._getCenter = function (t) {
                    return {
                        x: t.clientX,
                        y: t.clientY
                    }
                }, n._getMovement = function (t) {
                    var e = this.prevEvent.srcEvent;
                    return t.pointerId !== e.pointerId ? {
                        x: 0,
                        y: 0
                    } : {
                        x: t.clientX - e.clientX,
                        y: t.clientY - e.clientY
                    }
                }, n._updatePointerEvent = function (t) {
                    var e = this,
                        n = !1;
                    this._recentInputs.forEach((function (i, r) {
                        i.pointerId === t.pointerId && (n = !0, e._recentInputs[r] = t)
                    })), n || (this._firstInputs.push(t), this._recentInputs.push(t))
                }, n._removePointerEvent = function (t) {
                    this._firstInputs = this._firstInputs.filter((function (e) {
                        return e.pointerId !== t.pointerId
                    })), this._recentInputs = this._recentInputs.filter((function (e) {
                        return e.pointerId !== t.pointerId
                    }))
                }, e
            }(US),
            BS = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.start = ["mousedown", "touchstart"], e.move = ["mousemove", "touchmove"], e.end = ["mouseup", "touchend", "touchcancel"], e
                }
                jb(e, t);
                var n = e.prototype;
                return n.onEventStart = function (t, e, n) {
                    var i = this._getButton(t);
                    return this._isTouchEvent(t) && (this._baseTouches = t.touches), this._isValidEvent(t, e, n) ? (this._preventMouseButton(t, i), this.extendEvent(t)) : null
                }, n.onEventMove = function (t, e, n) {
                    return this._isValidEvent(t, e, n) ? this.extendEvent(t) : null
                }, n.onEventEnd = function (t) {
                    this._isTouchEvent(t) && (this._baseTouches = t.touches)
                }, n.onRelease = function () {
                    this.prevEvent = null, this._baseTouches = null
                }, n.getTouches = function (t, e) {
                    return this._isTouchEvent(t) ? t.touches.length : this._isValidButton(Qb[t.which], e) && -1 === this.end.indexOf(t.type) ? 1 : 0
                }, n._getScale = function (t) {
                    return this._isTouchEvent(t) ? 2 !== t.touches.length || this._baseTouches.length < 2 ? 1 : this._getDistance(t.touches[0], t.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]) : this.prevEvent.scale
                }, n._getCenter = function (t) {
                    return this._isTouchEvent(t) ? {
                        x: t.touches[0].clientX,
                        y: t.touches[0].clientY
                    } : {
                        x: t.clientX,
                        y: t.clientY
                    }
                }, n._getMovement = function (t) {
                    var e = this,
                        n = [t, this.prevEvent.srcEvent].map((function (t) {
                            return e._isTouchEvent(t) ? {
                                id: t.touches[0].identifier,
                                x: t.touches[0].clientX,
                                y: t.touches[0].clientY
                            } : {
                                id: null,
                                x: t.clientX,
                                y: t.clientY
                            }
                        })),
                        i = n[0],
                        r = n[1];
                    return i.id === r.id ? {
                        x: i.x - r.x,
                        y: i.y - r.y
                    } : {
                        x: 0,
                        y: 0
                    }
                }, e
            }(US),
            HS = function (t, e) {
                return e.reduce((function (e, n, i) {
                    return t[i] && (e[t[i]] = n), e
                }), {})
            },
            VS = function (t) {
                void 0 === t && (t = []);
                var e = !1,
                    n = !1,
                    i = !1;
                return t.forEach((function (t) {
                    switch (t) {
                        case "mouse":
                            n = !0;
                            break;
                        case "touch":
                            e = OS;
                            break;
                        case "pointer":
                            i = DS
                    }
                })), i ? new zS : e && n ? new BS : e ? new FS : n ? new kS : null
            };

        function GS(t) {
            return t.indexOf("touch") > -1 && {
                passive: !1
            }
        }
        var WS = function () {
                function t(t) {
                    var e = t.options,
                        n = t.interruptManager,
                        i = t.eventManager,
                        r = t.axisManager,
                        s = t.animationManager;
                    this._isOutside = !1, this._moveDistance = null, this._isStopped = !1, this.options = e, this._interruptManager = n, this._eventManager = i, this._axisManager = r, this._animationManager = s
                }
                var e = t.prototype;
                return e.get = function (t) {
                    return this._axisManager.get(t.axes)
                }, e.hold = function (t, e) {
                    if (!this._interruptManager.isInterrupted() && t.axes.length) {
                        var n = {
                            input: t,
                            event: e
                        };
                        this._isStopped = !1, this._interruptManager.setInterrupt(!0), this._animationManager.stopAnimation(n), ++this._eventManager.holdingCount, this._moveDistance || this._eventManager.hold(this._axisManager.get(), n), this._isOutside = this._axisManager.isOutside(t.axes), this._moveDistance = this._axisManager.get(t.axes)
                    }
                }, e.change = function (t, e, n, i) {
                    if (!this._isStopped && this._interruptManager.isInterrupting() && !this._axisManager.every(n, (function (t) {
                            return 0 === t
                        }))) {
                        var r = e.srcEvent ? e.srcEvent : e;
                        if (!r.__childrenAxesAlreadyChanged) {
                            var s, o = this._moveDistance || this._axisManager.get(t.axes);
                            s = uS(o, (function (t, e) {
                                return t + (n[e] || 0)
                            })), this._moveDistance && (this._moveDistance = this._axisManager.map(s, (function (t, e) {
                                var n = e.circular,
                                    i = e.range;
                                return n && (n[0] || n[1]) ? RS(t, i, n) : t
                            }))), this._isOutside && this._axisManager.every(o, (function (t, e) {
                                return !PS(t, e.range)
                            })) && (this._isOutside = !1), o = this._atOutside(o), s = this._atOutside(s), this.options.nested && this._isEndofAxis(n, o, s) || (r.__childrenAxesAlreadyChanged = !0);
                            var a = {
                                input: t,
                                event: e
                            };
                            if (i) {
                                var l = this._animationManager.getDuration(s, o);
                                this._animationManager.animateTo(s, l, a)
                            } else {
                                !this._eventManager.triggerChange(s, o, a, !0) && (this._isStopped = !0, this._moveDistance = null, this._animationManager.finish(!1))
                            }
                        }
                    }
                }, e.release = function (t, e, n, i) {
                    if (!this._isStopped && this._interruptManager.isInterrupting() && this._moveDistance) {
                        var r = e.srcEvent ? e.srcEvent : e;
                        r.__childrenAxesAlreadyReleased && (n = n.map((function () {
                            return 0
                        })));
                        var s = this._axisManager.get(t.axes),
                            o = this._axisManager.get(),
                            a = this._animationManager.getDisplacement(n),
                            l = HS(t.axes, a),
                            c = this._axisManager.get(this._axisManager.map(l, (function (t, e, n) {
                                return e.circular && (e.circular[0] || e.circular[1]) ? s[n] + t : AS(s[n] + t, e.range, e.circular, e.bounce)
                            })));
                        r.__childrenAxesAlreadyReleased = !0;
                        var u = this._animationManager.getDuration(c, s, i);
                        0 === u && (c = qb({}, o));
                        var h = {
                            depaPos: o,
                            destPos: c,
                            duration: u,
                            delta: this._axisManager.getDelta(o, c),
                            inputEvent: e,
                            input: t,
                            isTrusted: !0
                        };
                        --this._eventManager.holdingCount, this._eventManager.triggerRelease(h), 0 === this._eventManager.holdingCount && (this._moveDistance = null);
                        var d = this._animationManager.getUserControl(h),
                            f = fS(d.destPos, o),
                            p = {
                                input: t,
                                event: e
                            };
                        f || 0 === d.duration ? (f || this._eventManager.triggerChange(d.destPos, o, p, !0), this._interruptManager.setInterrupt(!1), this._axisManager.isOutside() ? this._animationManager.restore(p) : this._eventManager.triggerFinish(!0)) : this._animationManager.animateTo(d.destPos, d.duration, p)
                    }
                }, e._atOutside = function (t) {
                    var e = this;
                    return this._isOutside ? this._axisManager.map(t, (function (t, e) {
                        var n = e.range[0] - e.bounce[0],
                            i = e.range[1] + e.bounce[1];
                        return t > i ? i : t < n ? n : t
                    })) : this._axisManager.map(t, (function (t, n) {
                        var i = n.range[0],
                            r = n.range[1],
                            s = n.bounce,
                            o = n.circular;
                        return o[0] && t < i || o[1] && t > r ? t : t < i ? i - e._animationManager.interpolate(i - t, s[0]) : t > r ? r + e._animationManager.interpolate(t - r, s[1]) : t
                    }))
                }, e._isEndofAxis = function (t, e, n) {
                    return this._axisManager.every(e, (function (i, r, s) {
                        return 0 === t[s] || e[s] === n[s] && function (t, e, n, i) {
                            return !i[0] && t === e[0] - n[0] || !i[1] && t === e[1] + n[1]
                        }(i, r.range, r.bounce, r.circular)
                    }))
                }, t
            }(),
            jS = function (t, e, n) {
                return Math.max(Math.min(t, n), e)
            },
            XS = function () {
                function t(t) {
                    var e = t.options,
                        n = t.interruptManager,
                        i = t.eventManager,
                        r = t.axisManager;
                    this._options = e, this.interruptManager = n, this.eventManager = i, this.axisManager = r, this.animationEnd = this.animationEnd.bind(this)
                }
                var e = t.prototype;
                return e.getDuration = function (t, e, n) {
                    var i, r = this;
                    if (void 0 !== n) i = n;
                    else {
                        var s = uS(e, (function (e, n) {
                            return function (t, e) {
                                var n = Math.sqrt(t / e * 2);
                                return n < 100 ? 0 : n
                            }(Math.abs(e - t[n]), r._options.deceleration)
                        }));
                        i = Object.keys(s).reduce((function (t, e) {
                            return Math.max(t, s[e])
                        }), -1 / 0)
                    }
                    return jS(i, this._options.minimumDuration, this._options.maximumDuration)
                }, e.getDisplacement = function (t) {
                    var e = Math.pow(t.reduce((function (t, e) {
                            return t + e * e
                        }), 0), 1 / t.length),
                        n = Math.abs(e / -this._options.deceleration);
                    return t.map((function (t) {
                        return t / 2 * n
                    }))
                }, e.stopAnimation = function (t) {
                    if (this._animateParam) {
                        var e = this.axisManager.get(),
                            n = this.axisManager.map(e, (function (t, e) {
                                return RS(t, e.range, e.circular)
                            }));
                        dS(n, (function (t, n) {
                            return e[n] === t
                        })) || this.eventManager.triggerChange(n, e, t, !!t), this._animateParam = null, this._raf && (i = this._raf, aS(i)), this._raf = null, this.eventManager.triggerAnimationEnd(!!(null == t ? void 0 : t.event))
                    }
                    var i
                }, e.getEventInfo = function () {
                    return this._animateParam && this._animateParam.input && this._animateParam.inputEvent ? {
                        input: this._animateParam.input,
                        event: this._animateParam.inputEvent
                    } : null
                }, e.restore = function (t) {
                    var e = this.axisManager.get(),
                        n = this.axisManager.map(e, (function (t, e) {
                            return Math.min(e.range[1], Math.max(e.range[0], t))
                        }));
                    this.stopAnimation(), this.animateTo(n, this.getDuration(e, n), t)
                }, e.animationEnd = function () {
                    var t = this.getEventInfo();
                    this._animateParam = null;
                    var e = this.axisManager.filter(this.axisManager.get(), (function (t, e) {
                        return CS(t, e.range, e.circular)
                    }));
                    Object.keys(e).length > 0 && this.setTo(this.axisManager.map(e, (function (t, e) {
                        return RS(t, e.range, e.circular)
                    }))), this.interruptManager.setInterrupt(!1), this.eventManager.triggerAnimationEnd(!!t), this.axisManager.isOutside() ? this.restore(t) : this.finish(!!t)
                }, e.finish = function (t) {
                    this._animateParam = null, this.interruptManager.setInterrupt(!1), this.eventManager.triggerFinish(t)
                }, e.getUserControl = function (t) {
                    var e = t.setTo();
                    return e.destPos = this.axisManager.get(e.destPos), e.duration = jS(e.duration, this._options.minimumDuration, this._options.maximumDuration), e
                }, e.animateTo = function (t, e, n) {
                    var i = this;
                    this.stopAnimation();
                    var r = this._createAnimationParam(t, e, n),
                        s = qb({}, r.depaPos),
                        o = this.eventManager.triggerAnimationStart(r),
                        a = this.getUserControl(r);
                    if (!o && this.axisManager.every(a.destPos, (function (t, e) {
                            return CS(t, e.range, e.circular)
                        })), o && !fS(a.destPos, s)) {
                        var l = (null == n ? void 0 : n.event) || null;
                        this._animateLoop({
                            depaPos: s,
                            destPos: a.destPos,
                            duration: a.duration,
                            delta: this.axisManager.getDelta(s, a.destPos),
                            isTrusted: !!l,
                            inputEvent: l,
                            input: (null == n ? void 0 : n.input) || null
                        }, (function () {
                            return i.animationEnd()
                        }))
                    }
                }, e.setTo = function (t, e) {
                    void 0 === e && (e = 0);
                    var n = Object.keys(t),
                        i = this.axisManager.get(n);
                    if (fS(t, i)) return this;
                    this.interruptManager.setInterrupt(!0);
                    var r = hS(t, (function (t, e) {
                        return i[e] !== t
                    }));
                    return Object.keys(r).length ? (r = this.axisManager.map(r, (function (t, e) {
                        var n = e.range,
                            i = e.circular;
                        return i && (i[0] || i[1]) ? t : AS(t, n, i)
                    })), fS(r, i) || (e > 0 ? this.animateTo(r, e) : (this.stopAnimation(), this.eventManager.triggerChange(r), this.finish(!1))), this) : this
                }, e.setBy = function (t, e) {
                    return void 0 === e && (e = 0), this.setTo(uS(this.axisManager.get(Object.keys(t)), (function (e, n) {
                        return e + t[n]
                    })), e)
                }, e.setOptions = function (t) {
                    this._options = qb(qb({}, this._options), t)
                }, e._createAnimationParam = function (t, e, n) {
                    var i = this.axisManager.get(),
                        r = t,
                        s = (null == n ? void 0 : n.event) || null;
                    return {
                        depaPos: i,
                        destPos: r,
                        duration: jS(e, this._options.minimumDuration, this._options.maximumDuration),
                        delta: this.axisManager.getDelta(i, r),
                        inputEvent: s,
                        input: (null == n ? void 0 : n.input) || null,
                        isTrusted: !!s,
                        done: this.animationEnd
                    }
                }, e._animateLoop = function (t, e) {
                    var n = this;
                    if (t.duration) {
                        this._animateParam = qb(qb({}, t), {
                            startTime: (new Date).getTime()
                        });
                        var i = uS(t.destPos, (function (t) {
                                return t
                            })),
                            r = this._initState(this._animateParam),
                            s = function () {
                                n._raf = null;
                                var t = n._animateParam,
                                    o = n._getNextState(r),
                                    a = !n.eventManager.triggerChange(o.pos, r.pos);
                                if (r = o, o.finished) return t.destPos = n._getFinalPos(t.destPos, i), fS(t.destPos, n.axisManager.get(Object.keys(t.destPos))) || n.eventManager.triggerChange(t.destPos, o.pos), void e();
                                a ? n.finish(!1) : n._raf = oS(s)
                            };
                        s()
                    } else this.eventManager.triggerChange(t.destPos), e()
                }, e._getFinalPos = function (t, e) {
                    var n = this,
                        i = 1e-6;
                    return uS(t, (function (t, r) {
                        if (t >= e[r] - i && t <= e[r] + i) return e[r];
                        var s = n._getRoundUnit(t, r);
                        return mS(t, s)
                    }))
                }, e._getRoundUnit = function (t, e) {
                    var n = this._options.round,
                        i = null;
                    if (!n) {
                        var r = this.axisManager.getAxisOptions(e);
                        i = function (t) {
                            return 1 / Math.pow(10, t)
                        }(Math.max(vS(r.range[0]), vS(r.range[1]), vS(t)))
                    }
                    return i || n
                }, t
            }(),
            qS = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e._useDuration = !0, e
                }
                jb(e, t);
                var n = e.prototype;
                return n.interpolate = function (t, e) {
                    var n = this._easing(1e-5) / 1e-5;
                    return this._easing(t / (e * n)) * e
                }, n.updateAnimation = function (t) {
                    var e, n = this._animateParam;
                    if (n) {
                        var i = (new Date).getTime() - n.startTime,
                            r = (null == t ? void 0 : t.destPos) || n.destPos,
                            s = null !== (e = null == t ? void 0 : t.duration) && void 0 !== e ? e : n.duration;
                        if ((null == t ? void 0 : t.restart) || s <= i) this.setTo(r, s - i);
                        else {
                            if (null == t ? void 0 : t.destPos) {
                                var o = this.axisManager.get();
                                this._initialEasingPer = this._prevEasingPer, n.delta = this.axisManager.getDelta(o, r), n.destPos = r
                            }
                            if (null == t ? void 0 : t.duration) {
                                var a = (i + this._durationOffset) / n.duration;
                                this._durationOffset = a * s - i, n.duration = s
                            }
                        }
                    }
                }, n._initState = function (t) {
                    return this._initialEasingPer = 0, this._prevEasingPer = 0, this._durationOffset = 0, {
                        pos: t.depaPos,
                        easingPer: 0,
                        finished: !1
                    }
                }, n._getNextState = function (t) {
                    var e = this,
                        n = this._animateParam,
                        i = t.pos,
                        r = n.destPos,
                        s = uS(i, (function (t, e) {
                            return t <= r[e] ? 1 : -1
                        })),
                        o = ((new Date).getTime() - n.startTime + this._durationOffset) / n.duration,
                        a = this._easing(o),
                        l = this.axisManager.map(i, (function (t, l, c) {
                            var u = o >= 1 ? r[c] : t + n.delta[c] * (a - e._prevEasingPer) / (1 - e._initialEasingPer),
                                h = RS(u, l.range, l.circular);
                            if (u !== h) {
                                var d = s[c] * (l.range[1] - l.range[0]);
                                r[c] -= d, i[c] -= d
                            }
                            return h
                        }));
                    return this._prevEasingPer = a, {
                        pos: l,
                        easingPer: a,
                        finished: a >= 1
                    }
                }, n._easing = function (t) {
                    return t > 1 ? 1 : this._options.easing(t)
                }, e
            }(XS),
            YS = function (t) {
                function e(e, n, i) {
                    void 0 === e && (e = {}), void 0 === n && (n = {}), void 0 === i && (i = {});
                    var r = t.call(this) || this;
                    return r.axis = e, r._inputs = [], r.options = qb({
                        easing: function (t) {
                            return 1 - Math.pow(1 - t, 3)
                        },
                        interruptable: !0,
                        maximumDuration: 1 / 0,
                        minimumDuration: 0,
                        deceleration: 6e-4,
                        round: null,
                        nested: !1
                    }, n), Object.keys(i).forEach((function (t) {
                        r.axis[t].startPos = i[t]
                    })), r.interruptManager = new TS(r.options), r.axisManager = new LS(r.axis), r.eventManager = new wS(r), r.animationManager = new qS(r), r.inputObserver = new WS(r), r.eventManager.setAnimationManager(r.animationManager), r.eventManager.triggerChange(r.axisManager.get()), r
                }
                jb(e, t);
                var n = e.prototype;
                return Object.defineProperty(n, "holding", {
                    get: function () {
                        return this.eventManager.holdingCount > 0
                    },
                    enumerable: !1,
                    configurable: !0
                }), n.connect = function (t, e) {
                    var n;
                    return n = "string" == typeof t ? t.split(" ") : t.concat(), ~this._inputs.indexOf(e) && this.disconnect(e), e.mapAxes(n), e.connect(this.inputObserver), this._inputs.push(e), this
                }, n.disconnect = function (t) {
                    if (t) {
                        var e = this._inputs.indexOf(t);
                        e >= 0 && (this._inputs[e].disconnect(), this._inputs.splice(e, 1))
                    } else this._inputs.forEach((function (t) {
                        return t.disconnect()
                    })), this._inputs = [];
                    return this
                }, n.get = function (t) {
                    return this.axisManager.get(t)
                }, n.setTo = function (t, e) {
                    return void 0 === e && (e = 0), this.animationManager.setTo(t, e), this
                }, n.setBy = function (t, e) {
                    return void 0 === e && (e = 0), this.animationManager.setBy(t, e), this
                }, n.setOptions = function (t) {
                    return this.options = qb(qb({}, this.options), t), this.animationManager.setOptions(t), this
                }, n.setAxis = function (t) {
                    return this.axisManager.setAxis(t), this
                }, n.stopAnimation = function () {
                    return this.animationManager.stopAnimation(), this.animationManager.finish(!1), this
                }, n.updateAnimation = function (t) {
                    return this.animationManager.updateAnimation(t), this
                }, n.isBounceArea = function (t) {
                    return this.axisManager.isOutside(t)
                }, n.destroy = function () {
                    this.disconnect(), this.eventManager.destroy()
                }, e.VERSION = "3.9.0", e.TRANSFORM = nS, e.DIRECTION_NONE = 1, e.DIRECTION_LEFT = 2, e.DIRECTION_RIGHT = 4, e.DIRECTION_UP = 8, e.DIRECTION_DOWN = 16, e.DIRECTION_HORIZONTAL = 6, e.DIRECTION_VERTICAL = Kb, e.DIRECTION_ALL = 30, Yb([Gb], e.prototype, "holding", null), e = Yb([Fb], e)
            }(ab),
            KS = function () {
                function t(t, e) {
                    var n = this;
                    this.axes = [], this.element = null, this._enabled = !1, this._activeEvent = null, this._atRightEdge = !1, this._rightEdgeTimer = 0, this._dragged = !1, this._isOverThreshold = !1, this._preventClickWhenDragged = function (t) {
                        n._dragged && (t.preventDefault(), t.stopPropagation()), n._dragged = !1
                    }, this._voidFunction = function () {}, this.element = sS(t), this.options = qb({
                        inputType: ["touch", "mouse", "pointer"],
                        inputKey: [tS],
                        inputButton: [Zb],
                        scale: [1, 1],
                        thresholdAngle: 45,
                        threshold: 0,
                        preventClickOnDrag: !1,
                        preventDefaultOnDrag: !1,
                        iOSEdgeSwipeThreshold: 30,
                        releaseOnScroll: !1,
                        touchAction: null
                    }, e), this._onPanstart = this._onPanstart.bind(this), this._onPanmove = this._onPanmove.bind(this), this._onPanend = this._onPanend.bind(this)
                }
                var e = t.prototype;
                return e.mapAxes = function (t) {
                    this._direction = bS(!!t[0], !!t[1]), this.axes = t
                }, e.connect = function (t) {
                    return this._activeEvent && (this._detachElementEvent(), this._detachWindowEvent(this._activeEvent)), this._attachElementEvent(t), this._originalCssProps = ES(this.element, this.options, this._direction), this
                }, e.disconnect = function () {
                    return this._detachElementEvent(), this._detachWindowEvent(this._activeEvent), xS(this._originalCssProps) || MS(this.element, this._originalCssProps), this._direction = 1, this
                }, e.destroy = function () {
                    this.disconnect(), this.element = null
                }, e.enable = function () {
                    return this._enabled = !0, this
                }, e.disable = function () {
                    return this._enabled = !1, this
                }, e.isEnabled = function () {
                    return this._enabled
                }, e.release = function () {
                    var t = this._activeEvent,
                        e = t.prevEvent;
                    return t.onRelease(), this._observer.release(this, e, [0, 0]), this._detachWindowEvent(t), this
                }, e._onPanstart = function (t) {
                    var e = this.options,
                        n = e.inputKey,
                        i = e.inputButton,
                        r = e.preventDefaultOnDrag,
                        s = this._activeEvent,
                        o = s.onEventStart(t, n, i);
                    if (o && this._enabled && !(s.getTouches(t, i) > 1) && !1 !== o.srcEvent.cancelable) {
                        var a = this.options.iOSEdgeSwipeThreshold;
                        this._dragged = !1, this._isOverThreshold = !1, this._observer.hold(this, o), this._atRightEdge = eS && o.center.x > window.innerWidth - a, this._attachWindowEvent(s), r && "touchstart" !== o.srcEvent.type && o.srcEvent.preventDefault(), s.prevEvent = o
                    }
                }, e._onPanmove = function (t) {
                    var e = this,
                        n = this.options,
                        i = n.iOSEdgeSwipeThreshold,
                        r = n.preventClickOnDrag,
                        s = n.releaseOnScroll,
                        o = n.inputKey,
                        a = n.inputButton,
                        l = n.threshold,
                        c = n.thresholdAngle,
                        u = this._activeEvent,
                        h = u.onEventMove(t, o, a),
                        d = u.getTouches(t, a);
                    if (0 === d || s && h && !h.srcEvent.cancelable) this._onPanend(t);
                    else if (h && this._enabled && !(d > 1)) {
                        var f = function (t, e) {
                                if (e < 0 || e > 90) return 1;
                                var n = Math.abs(t);
                                return n > e && n < 180 - e ? Kb : 6
                            }(h.angle, c),
                            p = SS(6, this._direction, f),
                            m = SS(Kb, this._direction, f);
                        if (u.prevEvent && eS) {
                            if (h.center.x < 0) return void this.release();
                            this._atRightEdge && (clearTimeout(this._rightEdgeTimer), h.deltaX < -i ? this._atRightEdge = !1 : this._rightEdgeTimer = window.setTimeout((function () {
                                return e.release()
                            }), 100))
                        }
                        var g = this._getDistance([h.deltaX, h.deltaY], [p, m]),
                            v = this._getOffset([h.offsetX, h.offsetY], [p, m]),
                            _ = v.some((function (t) {
                                return 0 !== t
                            }));
                        _ && (!1 !== h.srcEvent.cancelable && h.srcEvent.preventDefault(), h.srcEvent.stopPropagation()), h.preventSystemEvent = _, _ && (this._isOverThreshold || g >= l) && (this._dragged = r, this._isOverThreshold = !0, this._observer.change(this, h, HS(this.axes, v))), u.prevEvent = h
                    }
                }, e._onPanend = function (t) {
                    var e = this.options.inputButton,
                        n = this._activeEvent;
                    if (n.onEventEnd(t), this._enabled && 0 === n.getTouches(t, e)) {
                        this._detachWindowEvent(n), clearTimeout(this._rightEdgeTimer);
                        var i = n.prevEvent,
                            r = this._isOverThreshold ? this._getOffset([Math.abs(i.velocityX) * (i.offsetX < 0 ? -1 : 1), Math.abs(i.velocityY) * (i.offsetY < 0 ? -1 : 1)], [SS(6, this._direction), SS(Kb, this._direction)]) : [0, 0];
                        n.onRelease(), this._observer.release(this, i, r)
                    }
                }, e._attachWindowEvent = function (t) {
                    var e = this;
                    null == t || t.move.forEach((function (t) {
                        window.addEventListener(t, e._onPanmove, GS(t))
                    })), null == t || t.end.forEach((function (t) {
                        window.addEventListener(t, e._onPanend, GS(t))
                    }))
                }, e._detachWindowEvent = function (t) {
                    var e = this;
                    null == t || t.move.forEach((function (t) {
                        window.removeEventListener(t, e._onPanmove)
                    })), null == t || t.end.forEach((function (t) {
                        window.removeEventListener(t, e._onPanend)
                    }))
                }, e._getOffset = function (t, e) {
                    var n = this.options.scale;
                    return [e[0] ? t[0] * n[0] : 0, e[1] ? t[1] * n[1] : 0]
                }, e._getDistance = function (t, e) {
                    return Math.sqrt(Number(e[0]) * Math.pow(t[0], 2) + Number(e[1]) * Math.pow(t[1], 2))
                }, e._attachElementEvent = function (t) {
                    var e = this,
                        n = VS(this.options.inputType),
                        i = this.element;
                    if (n) {
                        if (!i) throw new Error("Element to connect input does not exist.");
                        this._observer = t, this._enabled = !0, this._activeEvent = n, i.addEventListener("click", this._preventClickWhenDragged, !0), n.start.forEach((function (t) {
                            i.addEventListener(t, e._onPanstart)
                        })), n.move.forEach((function (t) {
                            i.addEventListener(t, e._voidFunction)
                        }))
                    }
                }, e._detachElementEvent = function () {
                    var t = this,
                        e = this._activeEvent,
                        n = this.element;
                    n && (n.removeEventListener("click", this._preventClickWhenDragged, !0), null == e || e.start.forEach((function (e) {
                        n.removeEventListener(e, t._onPanstart)
                    })), null == e || e.move.forEach((function (e) {
                        n.removeEventListener(e, t._voidFunction)
                    }))), this._enabled = !1, this._observer = null
                }, t
            }();
        const ZS = YS;
        var JS = function (t, e) {
            return JS = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, JS(t, e)
        };

        function $S(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");

            function n() {
                this.constructor = t
            }
            JS(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var QS = function () {
            return QS = Object.assign || function (t) {
                for (var e, n = 1, i = arguments.length; n < i; n++)
                    for (var r in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                return t
            }, QS.apply(this, arguments)
        };

        function tE() {
            for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
            var i = Array(t),
                r = 0;
            for (e = 0; e < n; e++)
                for (var s = arguments[e], o = 0, a = s.length; o < a; o++, r++) i[r] = s[o];
            return i
        }
        var eE = "undefined" != typeof window,
            nE = eE ? window.navigator.userAgent : "",
            iE = !!eE && !!("getComputedStyle" in window),
            rE = /MSIE|Trident|Windows Phone|Edge/.test(nE),
            sE = !!eE && !!("addEventListener" in document),
            oE = "width",
            aE = "height";

        function lE(t, e) {
            return t.getAttribute(e) || ""
        }

        function cE(t) {
            return [].slice.call(t)
        }

        function uE(t, e) {
            return void 0 === e && (e = "data-"), "loading" in t && "lazy" === t.getAttribute("loading") || !!t.getAttribute(e + "lazy")
        }

        function hE(t, e, n) {
            sE ? t.addEventListener(e, n, !1) : t.attachEvent ? t.attachEvent("on" + e, n) : t["on" + e] = n
        }

        function dE(t, e, n) {
            t.removeEventListener ? t.removeEventListener(e, n, !1) : t.detachEvent ? t.detachEvent("on" + e, n) : t["on" + e] = null
        }

        function fE(t, e) {
            var n = t["client" + e] || t["offset" + e];
            return parseFloat(n || function (t) {
                return (iE ? window.getComputedStyle(t) : t.currentStyle) || {}
            }(t)[e.toLowerCase()]) || 0
        }
        var pE = [];

        function mE(t, e) {
            !pE.length && hE(window, "resize", vE), t.__PREFIX__ = e, pE.push(t), gE(t)
        }

        function gE(t, e) {
            void 0 === e && (e = "data-");
            var n = t.__PREFIX__ || e,
                i = parseInt(lE(t, "" + n + oE), 10) || 0,
                r = parseInt(lE(t, "" + n + aE), 10) || 0;
            if (lE(t, n + "fixed") === aE) {
                var s = fE(t, "Height") || r;
                t.style[oE] = i / r * s + "px"
            } else {
                s = function (t) {
                    return fE(t, "Width")
                }(t) || i;
                t.style[aE] = r / i * s + "px"
            }
        }

        function vE() {
            pE.forEach((function (t) {
                gE(t)
            }))
        }
        var _E = function (t) {
                function e(e, n) {
                    void 0 === n && (n = {});
                    var i = t.call(this) || this;
                    i.isReady = !1, i.isPreReady = !1, i.hasDataSize = !1, i.hasLoading = !1, i.isSkip = !1, i.onCheck = function (t) {
                        if (i.clear(), t && "error" === t.type && i.onError(i.element), !i.hasLoading || !i.checkElement()) {
                            var e = !i.hasDataSize && !i.hasLoading;
                            i.onReady(e)
                        }
                    }, i.options = QS({
                        prefix: "data-"
                    }, n), i.element = e;
                    var r = i.options.prefix;
                    return i.hasDataSize = function (t, e) {
                        return void 0 === e && (e = "data-"), !!t.getAttribute(e + "width")
                    }(e, r), i.isSkip = function (t, e) {
                        return void 0 === e && (e = "data-"), !!t.getAttribute(e + "skip")
                    }(e, r), i.hasLoading = uE(e, r), i
                }
                $S(e, t);
                var n = e.prototype;
                return n.check = function () {
                    return this.isSkip || !this.checkElement() ? (this.onAlreadyReady(!0), !1) : (this.hasDataSize && mE(this.element, this.options.prefix), (this.hasDataSize || this.hasLoading) && this.onAlreadyPreReady(), !0)
                }, n.addEvents = function () {
                    var t = this,
                        e = this.element;
                    this.constructor.EVENTS.forEach((function (n) {
                        hE(e, n, t.onCheck)
                    }))
                }, n.clear = function () {
                    var t = this,
                        e = this.element;
                    this.constructor.EVENTS.forEach((function (n) {
                        dE(e, n, t.onCheck)
                    })), this.removeAutoSizer()
                }, n.destroy = function () {
                    this.clear(), this.off()
                }, n.removeAutoSizer = function () {
                    if (this.hasDataSize) {
                        var t = this.options.prefix;
                        ! function (t, e) {
                            var n = pE.indexOf(t);
                            if (!(n < 0)) {
                                var i = lE(t, e + "fixed");
                                delete t.__PREFIX__, t.style[i === aE ? oE : aE] = "", pE.splice(n, 1), !pE.length && dE(window, "resize", vE)
                            }
                        }(this.element, t)
                    }
                }, n.onError = function (t) {
                    this.trigger("error", {
                        element: this.element,
                        target: t
                    })
                }, n.onPreReady = function () {
                    this.isPreReady || (this.isPreReady = !0, this.trigger("preReady", {
                        element: this.element,
                        hasLoading: this.hasLoading,
                        isSkip: this.isSkip
                    }))
                }, n.onReady = function (t) {
                    this.isReady || ((t = !this.isPreReady && t) && (this.isPreReady = !0), this.removeAutoSizer(), this.isReady = !0, this.trigger("ready", {
                        element: this.element,
                        withPreReady: t,
                        hasLoading: this.hasLoading,
                        isSkip: this.isSkip
                    }))
                }, n.onAlreadyError = function (t) {
                    var e = this;
                    setTimeout((function () {
                        e.onError(t)
                    }))
                }, n.onAlreadyPreReady = function () {
                    var t = this;
                    setTimeout((function () {
                        t.onPreReady()
                    }))
                }, n.onAlreadyReady = function (t) {
                    var e = this;
                    setTimeout((function () {
                        e.onReady(t)
                    }))
                }, e.EVENTS = [], e
            }(ab),
            yE = function (t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                $S(e, t);
                var n = e.prototype;
                return n.setHasLoading = function (t) {
                    this.hasLoading = t
                }, n.check = function () {
                    return this.isSkip ? (this.onAlreadyReady(!0), !1) : (this.hasDataSize ? (mE(this.element, this.options.prefix), this.onAlreadyPreReady()) : this.trigger("requestChildren"), !0)
                }, n.checkElement = function () {
                    return !0
                }, n.destroy = function () {
                    this.clear(), this.trigger("requestDestroy"), this.off()
                }, n.onAlreadyPreReady = function () {
                    t.prototype.onAlreadyPreReady.call(this), this.trigger("reqeustReadyChildren")
                }, e.EVENTS = [], e
            }(_E),
            xE = function (t) {
                function e(e) {
                    void 0 === e && (e = {});
                    var n = t.call(this) || this;
                    return n.readyCount = 0, n.preReadyCount = 0, n.totalCount = 0, n.totalErrorCount = 0, n.isPreReadyOver = !0, n.elementInfos = [], n.options = QS({
                        loaders: {},
                        prefix: "data-"
                    }, e), n
                }
                $S(e, t);
                var n = e.prototype;
                return n.check = function (t) {
                    var e = this,
                        n = this.options.prefix;
                    this.clear(), this.elementInfos = cE(t).map((function (t, i) {
                        var r = e.getLoader(t, {
                            prefix: n
                        });
                        return r.check(), r.on("error", (function (t) {
                            e.onError(i, t.target)
                        })).on("preReady", (function (t) {
                            var n = e.elementInfos[i];
                            n.hasLoading = t.hasLoading, n.isSkip = t.isSkip;
                            var r = e.checkPreReady(i);
                            e.onPreReadyElement(i), r && e.onPreReady()
                        })).on("ready", (function (t) {
                            var n = t.withPreReady,
                                r = t.hasLoading,
                                s = t.isSkip,
                                o = e.elementInfos[i];
                            o.hasLoading = r, o.isSkip = s;
                            var a = n && e.checkPreReady(i),
                                l = e.checkReady(i);
                            n && e.onPreReadyElement(i), e.onReadyElement(i), a && e.onPreReady(), l && e.onReady()
                        })), {
                            loader: r,
                            element: t,
                            hasLoading: !1,
                            hasError: !1,
                            isPreReady: !1,
                            isReady: !1,
                            isSkip: !1
                        }
                    }));
                    var i = this.elementInfos.length;
                    return this.totalCount = i, i || setTimeout((function () {
                        e.onPreReady(), e.onReady()
                    })), this
                }, n.getTotalCount = function () {
                    return this.totalCount
                }, n.isPreReady = function () {
                    return this.elementInfos.every((function (t) {
                        return t.isPreReady
                    }))
                }, n.isReady = function () {
                    return this.elementInfos.every((function (t) {
                        return t.isReady
                    }))
                }, n.hasError = function () {
                    return this.totalErrorCount > 0
                }, n.clear = function () {
                    this.isPreReadyOver = !1, this.totalCount = 0, this.preReadyCount = 0, this.readyCount = 0, this.totalErrorCount = 0, this.elementInfos.forEach((function (t) {
                        t.loader && t.loader.destroy()
                    })), this.elementInfos = []
                }, n.destroy = function () {
                    this.clear(), this.off()
                }, n.getLoader = function (t, e) {
                    var n = this,
                        i = t.tagName.toLowerCase(),
                        r = this.options.loaders,
                        s = e.prefix,
                        o = Object.keys(r);
                    if (r[i]) return new r[i](t, e);
                    var a = new yE(t, e),
                        l = cE(t.querySelectorAll(o.join(", ")));
                    a.setHasLoading(l.some((function (t) {
                        return uE(t, s)
                    })));
                    var c = !1,
                        u = this.clone().on("error", (function (t) {
                            a.onError(t.target)
                        })).on("ready", (function () {
                            a.onReady(c)
                        }));
                    return a.on("requestChildren", (function () {
                        var e = function (t, e, n) {
                            var i = cE(t.querySelectorAll(tE(["[" + n + "skip] [" + n + "width]"], e.map((function (t) {
                                return ["[" + n + "skip] " + t, t + "[" + n + "skip]", "[" + n + "width] " + t].join(", ")
                            }))).join(", ")));
                            return cE(t.querySelectorAll("[" + n + "width], " + e.join(", "))).filter((function (t) {
                                return -1 === i.indexOf(t)
                            }))
                        }(t, o, n.options.prefix);
                        u.check(e).on("preReady", (function (t) {
                            (c = t.isReady) || a.onPreReady()
                        }))
                    })).on("reqeustReadyChildren", (function () {
                        u.check(l)
                    })).on("requestDestroy", (function () {
                        u.destroy()
                    })), a
                }, n.clone = function () {
                    return new e(QS({}, this.options))
                }, n.checkPreReady = function (t) {
                    return this.elementInfos[t].isPreReady = !0, ++this.preReadyCount, !(this.preReadyCount < this.totalCount)
                }, n.checkReady = function (t) {
                    return this.elementInfos[t].isReady = !0, ++this.readyCount, !(this.readyCount < this.totalCount)
                }, n.onError = function (t, e) {
                    var n = this.elementInfos[t];
                    n.hasError = !0, this.trigger(new ob("error", {
                        element: n.element,
                        index: t,
                        target: e,
                        errorCount: this.getErrorCount(),
                        totalErrorCount: ++this.totalErrorCount
                    }))
                }, n.onPreReadyElement = function (t) {
                    var e = this.elementInfos[t];
                    this.trigger(new ob("preReadyElement", {
                        element: e.element,
                        index: t,
                        preReadyCount: this.preReadyCount,
                        readyCount: this.readyCount,
                        totalCount: this.totalCount,
                        isPreReady: this.isPreReady(),
                        isReady: this.isReady(),
                        hasLoading: e.hasLoading,
                        isSkip: e.isSkip
                    }))
                }, n.onPreReady = function () {
                    this.isPreReadyOver = !0, this.trigger(new ob("preReady", {
                        readyCount: this.readyCount,
                        totalCount: this.totalCount,
                        isReady: this.isReady(),
                        hasLoading: this.hasLoading()
                    }))
                }, n.onReadyElement = function (t) {
                    var e = this.elementInfos[t];
                    this.trigger(new ob("readyElement", {
                        index: t,
                        element: e.element,
                        hasError: e.hasError,
                        errorCount: this.getErrorCount(),
                        totalErrorCount: this.totalErrorCount,
                        preReadyCount: this.preReadyCount,
                        readyCount: this.readyCount,
                        totalCount: this.totalCount,
                        isPreReady: this.isPreReady(),
                        isReady: this.isReady(),
                        hasLoading: e.hasLoading,
                        isPreReadyOver: this.isPreReadyOver,
                        isSkip: e.isSkip
                    }))
                }, n.onReady = function () {
                    this.trigger(new ob("ready", {
                        errorCount: this.getErrorCount(),
                        totalErrorCount: this.totalErrorCount,
                        totalCount: this.totalCount
                    }))
                }, n.getErrorCount = function () {
                    return this.elementInfos.filter((function (t) {
                        return t.hasError
                    })).length
                }, n.hasLoading = function () {
                    return this.elementInfos.some((function (t) {
                        return t.hasLoading
                    }))
                }, e
            }(ab),
            bE = function (t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                return $S(e, t), e.prototype.checkElement = function () {
                    var t = this.element,
                        e = t.getAttribute("src");
                    if (t.complete) {
                        if (e) return t.naturalWidth || this.onAlreadyError(t), !1;
                        this.onAlreadyPreReady()
                    }
                    return this.addEvents(), rE && t.setAttribute("src", e), !0
                }, e.EVENTS = ["load", "error"], e
            }(_E),
            SE = function (t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                return $S(e, t), e.prototype.checkElement = function () {
                    var t = this.element;
                    return !(t.readyState >= 1) && (t.error ? (this.onAlreadyError(t), !1) : (this.addEvents(), !0))
                }, e.EVENTS = ["loadedmetadata", "error"], e
            }(_E),
            EE = function (t) {
                function e(e) {
                    return void 0 === e && (e = {}), t.call(this, QS({
                        loaders: {
                            img: bE,
                            video: SE
                        }
                    }, e)) || this
                }
                return $S(e, t), e
            }(xE);
        const ME = EE;
        var wE = function (t, e) {
            return wE = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, wE(t, e)
        };

        function TE(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");

            function n() {
                this.constructor = t
            }
            wE(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var AE = function () {
            return AE = Object.assign || function (t) {
                for (var e, n = 1, i = arguments.length; n < i; n++)
                    for (var r in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                return t
            }, AE.apply(this, arguments)
        };

        function PE(t, e, n, i) {
            return new(n || (n = Promise))((function (r, s) {
                function o(t) {
                    try {
                        l(i.next(t))
                    } catch (t) {
                        s(t)
                    }
                }

                function a(t) {
                    try {
                        l(i.throw(t))
                    } catch (t) {
                        s(t)
                    }
                }

                function l(t) {
                    var e;
                    t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) {
                        t(e)
                    }))).then(o, a)
                }
                l((i = i.apply(t, e || [])).next())
            }))
        }

        function CE(t, e) {
            var n, i, r, s, o = {
                label: 0,
                sent: function () {
                    if (1 & r[0]) throw r[1];
                    return r[1]
                },
                trys: [],
                ops: []
            };
            return s = {
                next: a(0),
                throw: a(1),
                return: a(2)
            }, "function" == typeof Symbol && (s[Symbol.iterator] = function () {
                return this
            }), s;

            function a(s) {
                return function (a) {
                    return function (s) {
                        if (n) throw new TypeError("Generator is already executing.");
                        for (; o;) try {
                            if (n = 1, i && (r = 2 & s[0] ? i.return : s[0] ? i.throw || ((r = i.return) && r.call(i), 0) : i.next) && !(r = r.call(i, s[1])).done) return r;
                            switch (i = 0, r && (s = [2 & s[0], r.value]), s[0]) {
                                case 0:
                                case 1:
                                    r = s;
                                    break;
                                case 4:
                                    return o.label++, {
                                        value: s[1],
                                        done: !1
                                    };
                                case 5:
                                    o.label++, i = s[1], s = [0];
                                    continue;
                                case 7:
                                    s = o.ops.pop(), o.trys.pop();
                                    continue;
                                default:
                                    if (!(r = o.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                        o = 0;
                                        continue
                                    }
                                    if (3 === s[0] && (!r || s[1] > r[0] && s[1] < r[3])) {
                                        o.label = s[1];
                                        break
                                    }
                                    if (6 === s[0] && o.label < r[1]) {
                                        o.label = r[1], r = s;
                                        break
                                    }
                                    if (r && o.label < r[2]) {
                                        o.label = r[2], o.ops.push(s);
                                        break
                                    }
                                    r[2] && o.ops.pop(), o.trys.pop();
                                    continue
                            }
                            s = e.call(t, o)
                        } catch (t) {
                            s = [6, t], i = 0
                        } finally {
                            n = r = 0
                        }
                        if (5 & s[0]) throw s[1];
                        return {
                            value: s[0] ? s[1] : void 0,
                            done: !0
                        }
                    }([s, a])
                }
            }
        }

        function RE(t) {
            var e = "function" == typeof Symbol && Symbol.iterator,
                n = e && t[e],
                i = 0;
            if (n) return n.call(t);
            if (t && "number" == typeof t.length) return {
                next: function () {
                    return t && i >= t.length && (t = void 0), {
                        value: t && t[i++],
                        done: !t
                    }
                }
            };
            throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
        }

        function LE(t, e) {
            var n = "function" == typeof Symbol && t[Symbol.iterator];
            if (!n) return t;
            var i, r, s = n.call(t),
                o = [];
            try {
                for (;
                    (void 0 === e || e-- > 0) && !(i = s.next()).done;) o.push(i.value)
            } catch (t) {
                r = {
                    error: t
                }
            } finally {
                try {
                    i && !i.done && (n = s.return) && n.call(s)
                } finally {
                    if (r) throw r.error
                }
            }
            return o
        }

        function OE() {
            for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(LE(arguments[e]));
            return t
        }
        var IE, DE = 0,
            NE = 1,
            UE = 2,
            kE = 3,
            FE = 4,
            zE = 5,
            BE = 6,
            HE = 7,
            VE = 8,
            GE = 9,
            WE = 10,
            jE = 11,
            XE = 12,
            qE = function (t, e) {
                return t + "(" + typeof t + ") is not a " + e.map((function (t) {
                    return '"' + t + '"'
                })).join(" or ") + "."
            },
            YE = function (t) {
                return 'Element with selector "' + t + '" not found.'
            },
            KE = function (t, e) {
                return e + " should be provided. Given: " + t
            },
            ZE = 'This module is not attached to the Flicking instance. "init()" should be called first.',
            JE = function (t, e) {
                return 'Option "' + t + '" is not in correct format, given: ' + e
            },
            $E = function (t, e, n) {
                return 'Index "' + t + '" is out of range: should be between ' + e + " and " + n + "."
            },
            QE = function (t) {
                return 'Position "' + t + '" is not reachable.'
            },
            tM = "Browser does not support CSS transform.",
            eM = "Event stop() is called by user.",
            nM = "Animation is interrupted by user input.",
            iM = "Animation is already playing.",
            rM = "This behavior is not allowed in the frameworks like React, Vue, or Angular.",
            sM = "Flicking is not initialized yet, call init() first.",
            oM = "ready",
            aM = "beforeResize",
            lM = "afterResize",
            cM = "holdStart",
            uM = "holdEnd",
            hM = "moveStart",
            dM = "move",
            fM = "moveEnd",
            pM = "willChange",
            mM = "changed",
            gM = "willRestore",
            vM = "restored",
            _M = "select",
            yM = "needPanel",
            xM = "visibleChange",
            bM = "reachEdge",
            SM = "panelChange",
            EM = "prev",
            MM = "center",
            wM = "next",
            TM = "PREV",
            AM = "NEXT",
            PM = null,
            CM = {
                SNAP: "snap",
                FREE_SCROLL: "freeScroll",
                STRICT: "strict"
            },
            RM = "flicking-panel",
            LM = "linear",
            OM = "bound",
            IM = "ltr",
            DM = "rtl",
            NM = function (t, e, n) {
                return Math.max(Math.min(t, n), e)
            },
            UM = function (t) {
                if (!t) throw new nw(ZE, kE);
                return t
            },
            kM = function (t) {
                return [].slice.call(t)
            },
            FM = function (t, e) {
                var n;
                if (XM(t)) switch (t) {
                    case EM:
                        n = 0;
                        break;
                    case MM:
                        n = .5 * e;
                        break;
                    case wM:
                        n = e;
                        break;
                    default:
                        if (null == (n = zM(t, e))) throw new nw(JE("align", t), FE)
                } else n = t;
                return n
            },
            zM = function (t, e) {
                var n = BM(t);
                return null == n ? null : n.percentage * e + n.absolute
            },
            BM = function (t) {
                var e = /(?:(\+|\-)\s*)?(\d+(?:\.\d+)?(%|px)?)/g;
                if ("number" == typeof t) return {
                    percentage: 0,
                    absolute: t
                };
                for (var n = {
                        percentage: 0,
                        absolute: 0
                    }, i = 0, r = e.exec(t); null != r;) {
                    var s = r[1],
                        o = r[2],
                        a = r[3],
                        l = parseFloat(o);
                    if (i <= 0 && (s = s || "+"), !s) return null;
                    var c = "+" === s ? 1 : -1;
                    "%" === a ? n.percentage += c * (l / 100) : n.absolute += c * l, ++i, r = e.exec(t)
                }
                return 0 === i ? null : n
            },
            HM = function (t) {
                return "object" == typeof t ? t.panel : t
            },
            VM = function (t, e) {
                return t === e ? PM : t < e ? AM : TM
            },
            GM = function (t) {
                Array.isArray(t) || (t = [t]);
                var e = [];
                return t.forEach((function (t) {
                    if (XM(t)) {
                        var n = document.createElement("div");
                        for (n.innerHTML = t, e.push.apply(e, OE(kM(n.children))); n.firstChild;) n.removeChild(n.firstChild)
                    } else {
                        if (!t || t.nodeType !== Node.ELEMENT_NODE) throw new nw(qE(t, ["HTMLElement", "string"]), DE);
                        e.push(t)
                    }
                })), e
            },
            WM = function (t, e) {
                return NM(t < 0 ? t + e : t, 0, e)
            },
            jM = function (t, e) {
                var n, i;
                try {
                    for (var r = RE(t), s = r.next(); !s.done; s = r.next()) {
                        if (s.value === e) return !0
                    }
                } catch (t) {
                    n = {
                        error: t
                    }
                } finally {
                    try {
                        s && !s.done && (i = r.return) && i.call(r)
                    } finally {
                        if (n) throw n.error
                    }
                }
                return !1
            },
            XM = function (t) {
                return "string" == typeof t
            },
            qM = function (t, e, n) {
                var i = n - e;
                if (t < e) t = n - (e - t) % i;
                else if (t > n) {
                    t = e + (t - n) % i
                }
                return t
            },
            YM = function (t, e, n) {
                return (t - e) / (n - e)
            },
            KM = function (t) {
                return window.getComputedStyle(t) || t.currentStyle
            },
            ZM = function (t, e) {
                var n = e.width,
                    i = e.height;
                null != n && (XM(n) ? t.style.width = n : t.style.width = n + "px"), null != i && (XM(i) ? t.style.height = i : t.style.height = i + "px")
            },
            JM = function (t, e, n) {
                return t >= e && t <= n
            },
            $M = function (t, e) {
                return t >= e ? t % e : t < 0 ? WM((t + 1) % e - 1, e) : t
            },
            QM = function (t) {
                for (var e = new Array(t), n = 0; n < t; n++) e[n] = n;
                return e
            },
            tw = function (t) {
                var e = t.el,
                    n = t.horizontal,
                    i = t.useFractionalSize,
                    r = t.useOffset,
                    s = t.style,
                    o = 0;
                if (i) {
                    var a = parseFloat(n ? s.width : s.height) || 0,
                        l = "border-box" === s.boxSizing,
                        c = n ? parseFloat(s.borderLeftWidth || "0") + parseFloat(s.borderRightWidth || "0") : parseFloat(s.borderTopWidth || "0") + parseFloat(s.borderBottomWidth || "0");
                    if (l) o = r ? a : a - c;
                    else {
                        var u = n ? parseFloat(s.paddingLeft || "0") + parseFloat(s.paddingRight || "0") : parseFloat(s.paddingTop || "0") + parseFloat(s.paddingBottom || "0");
                        o = r ? a + u + c : a + u
                    }
                } else {
                    var h = n ? "Width" : "Height";
                    o = r ? e["offset" + h] : e["client" + h]
                }
                return Math.max(o, 0)
            },
            ew = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            },
            nw = function (t) {
                function e(n, i) {
                    var r = t.call(this, n) || this;
                    return ew(r, e.prototype), r.name = "FlickingError", r.code = i, r
                }
                return TE(e, t), e
            }(Error),
            iw = function () {
                function t(t, e) {
                    this._flicking = t, this._el = e, this._width = 0, this._height = 0, this._padding = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, this._isBorderBoxSizing = !1
                }
                var e = t.prototype;
                return Object.defineProperty(e, "element", {
                    get: function () {
                        return this._el
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "width", {
                    get: function () {
                        return this._width - this._padding.left - this._padding.right
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "height", {
                    get: function () {
                        return this._height - this._padding.top - this._padding.bottom
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "padding", {
                    get: function () {
                        return this._padding
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.setSize = function (t) {
                    var e = t.width,
                        n = t.height,
                        i = this._el,
                        r = this._padding,
                        s = this._isBorderBoxSizing;
                    if (null != e)
                        if (XM(e)) i.style.width = e;
                        else {
                            var o = s ? e + r.left + r.right : e;
                            i.style.width = o + "px"
                        } if (null != n)
                        if (XM(n)) i.style.height = n;
                        else {
                            var a = s ? n + r.top + r.bottom : n;
                            i.style.height = a + "px"
                        } this.resize()
                }, e.resize = function () {
                    var t = this._el,
                        e = KM(t),
                        n = this._flicking.useFractionalSize;
                    this._width = tw({
                        el: t,
                        horizontal: !0,
                        useFractionalSize: n,
                        useOffset: !1,
                        style: e
                    }), this._height = tw({
                        el: t,
                        horizontal: !1,
                        useFractionalSize: n,
                        useOffset: !1,
                        style: e
                    }), this._padding = {
                        left: e.paddingLeft ? parseFloat(e.paddingLeft) : 0,
                        right: e.paddingRight ? parseFloat(e.paddingRight) : 0,
                        top: e.paddingTop ? parseFloat(e.paddingTop) : 0,
                        bottom: e.paddingBottom ? parseFloat(e.paddingBottom) : 0
                    }, this._isBorderBoxSizing = "border-box" === e.boxSizing
                }, t
            }(),
            rw = function () {
                function t(t) {
                    var e, n = this;
                    this._onResize = function () {
                        var t = n._flicking,
                            e = t.resizeDebounce,
                            i = t.maxResizeDebounce;
                        e <= 0 ? t.resize() : (n._maxResizeDebounceTimer <= 0 && i > 0 && i >= e && (n._maxResizeDebounceTimer = window.setTimeout(n._doScheduledResize, i)), n._resizeTimer > 0 && (clearTimeout(n._resizeTimer), n._resizeTimer = 0), n._resizeTimer = window.setTimeout(n._doScheduledResize, e))
                    }, this._doScheduledResize = function () {
                        clearTimeout(n._resizeTimer), clearTimeout(n._maxResizeDebounceTimer), n._maxResizeDebounceTimer = -1, n._resizeTimer = -1, n._flicking.resize()
                    }, this._skipFirstResize = (e = !0, function () {
                        e ? e = !1 : n._onResize()
                    }), this._flicking = t, this._enabled = !1, this._resizeObserver = null, this._resizeTimer = -1, this._maxResizeDebounceTimer = -1
                }
                var e = t.prototype;
                return Object.defineProperty(e, "enabled", {
                    get: function () {
                        return this._enabled
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.enable = function () {
                    var t = this._flicking,
                        e = t.viewport;
                    if (this._enabled && this.disable(), t.useResizeObserver && window.ResizeObserver) {
                        var n = 0 !== e.width || 0 !== e.height ? new ResizeObserver(this._skipFirstResize) : new ResizeObserver(this._onResize);
                        n.observe(t.viewport.element), this._resizeObserver = n
                    } else window.addEventListener("resize", this._onResize);
                    return this._enabled = !0, this
                }, e.disable = function () {
                    if (!this._enabled) return this;
                    var t = this._resizeObserver;
                    return t ? (t.disconnect(), this._resizeObserver = null) : window.removeEventListener("resize", this._onResize), this._enabled = !1, this
                }, t
            }(),
            sw = function () {
                function t(t) {
                    this._element = t, this._rendered = !0
                }
                var e = t.prototype;
                return Object.defineProperty(e, "element", {
                    get: function () {
                        return this._element
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "rendered", {
                    get: function () {
                        return this._rendered
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.show = function (t) {
                    var e = this.element,
                        n = t.camera.element;
                    e.parentElement !== n && (n.appendChild(e), this._rendered = !0)
                }, e.hide = function (t) {
                    var e = this.element,
                        n = t.camera.element;
                    e.parentElement === n && (n.removeChild(e), this._rendered = !1)
                }, t
            }(),
            ow = function () {
                function t(t) {
                    this._flicking = t
                }
                var e = t.prototype;
                return Object.defineProperty(e, "element", {
                    get: function () {
                        return this._virtualElement.nativeElement
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "rendered", {
                    get: function () {
                        return this._virtualElement.visible
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "_virtualElement", {
                    get: function () {
                        var t = this._flicking,
                            e = this._panel.elementIndex;
                        return t.virtual.elements[e]
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.init = function (t) {
                    this._panel = t
                }, e.show = function () {}, e.hide = function () {}, t
            }(),
            aw = function () {
                function t(t, e) {
                    var n, i, r, s;
                    this._flicking = t, this._renderPanel = null !== (n = null == e ? void 0 : e.renderPanel) && void 0 !== n ? n : function () {
                        return ""
                    }, this._initialPanelCount = null !== (i = null == e ? void 0 : e.initialPanelCount) && void 0 !== i ? i : -1, this._cache = null !== (r = null == e ? void 0 : e.cache) && void 0 !== r && r, this._panelClass = null !== (s = null == e ? void 0 : e.panelClass) && void 0 !== s ? s : RM, this._elements = []
                }
                var e = t.prototype;
                return Object.defineProperty(e, "elements", {
                    get: function () {
                        return this._elements
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "renderPanel", {
                    get: function () {
                        return this._renderPanel
                    },
                    set: function (t) {
                        this._renderPanel = t, this._flicking.renderer.panels.forEach((function (t) {
                            return t.uncacheRenderResult()
                        }))
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "initialPanelCount", {
                    get: function () {
                        return this._initialPanelCount
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "cache", {
                    get: function () {
                        return this._cache
                    },
                    set: function (t) {
                        this._cache = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "panelClass", {
                    get: function () {
                        return this._panelClass
                    },
                    set: function (t) {
                        this._panelClass = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.init = function () {
                    var t = this._flicking;
                    if (t.virtualEnabled) {
                        t.externalRenderer || t.renderExternal || this._initVirtualElements();
                        var e = t.camera.children;
                        this._elements = e.map((function (t) {
                            return {
                                nativeElement: t,
                                visible: !0
                            }
                        }))
                    }
                }, e.show = function (t) {
                    var e = this._elements[t],
                        n = e.nativeElement;
                    e.visible = !0, n.style.display && (n.style.display = "")
                }, e.hide = function (t) {
                    var e = this._elements[t],
                        n = e.nativeElement;
                    e.visible = !1, n.style.display = "none"
                }, e.append = function (t) {
                    void 0 === t && (t = 1);
                    var e = this._flicking;
                    return this.insert(e.panels.length, t)
                }, e.prepend = function (t) {
                    return void 0 === t && (t = 1), this.insert(0, t)
                }, e.insert = function (t, e) {
                    return void 0 === e && (e = 1), e <= 0 ? [] : this._flicking.renderer.batchInsert({
                        index: t,
                        elements: QM(e),
                        hasDOMInElements: !1
                    })
                }, e.remove = function (t, e) {
                    return e <= 0 ? [] : this._flicking.renderer.batchRemove({
                        index: t,
                        deleteCount: e,
                        hasDOMInElements: !1
                    })
                }, e._initVirtualElements = function () {
                    var t = this,
                        e = this._flicking,
                        n = e.camera.element,
                        i = e.panelsPerView,
                        r = document.createDocumentFragment();
                    QM(i + 1).map((function (e) {
                        var n = document.createElement("div");
                        return n.className = t._panelClass, n.dataset.elementIndex = e.toString(), n
                    })).forEach((function (t) {
                        r.appendChild(t)
                    })), n.appendChild(r)
                }, t
            }(),
            lw = {
                HOLD: "hold",
                CHANGE: "change",
                RELEASE: "release",
                ANIMATION_END: "animationEnd",
                FINISH: "finish"
            },
            cw = "flick";
        ! function (t) {
            t[t.IDLE = 0] = "IDLE", t[t.HOLDING = 1] = "HOLDING", t[t.DRAGGING = 2] = "DRAGGING", t[t.ANIMATING = 3] = "ANIMATING", t[t.DISABLED = 4] = "DISABLED"
        }(IE || (IE = {}));
        var uw, hw, dw = function () {
                function t() {
                    this._delta = 0, this._targetPanel = null
                }
                var e = t.prototype;
                return Object.defineProperty(e, "delta", {
                    get: function () {
                        return this._delta
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "targetPanel", {
                    get: function () {
                        return this._targetPanel
                    },
                    set: function (t) {
                        this._targetPanel = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.onEnter = function (t) {
                    this._delta = t._delta, this._targetPanel = t._targetPanel
                }, e.onHold = function (t) {}, e.onChange = function (t) {}, e.onRelease = function (t) {}, e.onAnimationEnd = function (t) {}, e.onFinish = function (t) {}, e._moveToChangedPosition = function (t) {
                    var e = t.flicking,
                        n = t.axesEvent,
                        i = t.transitTo,
                        r = n.delta[cw];
                    if (r) {
                        this._delta += r;
                        var s = e.camera,
                            o = s.position,
                            a = n.pos[cw],
                            l = e.circularEnabled ? qM(a, s.range.min, s.range.max) : a;
                        s.lookAt(l);
                        var c = new ob(dM, {
                            isTrusted: n.isTrusted,
                            holding: this.holding,
                            direction: VM(0, n.delta[cw]),
                            axesEvent: n
                        });
                        e.trigger(c), c.isCanceled() && (s.lookAt(o), i(IE.DISABLED))
                    }
                }, t
            }(),
            fw = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.holding = !1, e.animating = !1, e
                }
                TE(e, t);
                var n = e.prototype;
                return n.onEnter = function () {
                    this._delta = 0, this._targetPanel = null
                }, n.onHold = function (t) {
                    var e = t.flicking,
                        n = t.axesEvent,
                        i = t.transitTo;
                    if (e.renderer.panelCount <= 0) i(IE.DISABLED);
                    else {
                        var r = new ob(cM, {
                            axesEvent: n
                        });
                        e.trigger(r), r.isCanceled() ? i(IE.DISABLED) : i(IE.HOLDING)
                    }
                }, n.onChange = function (t) {
                    var e = t.flicking,
                        n = t.axesEvent,
                        i = t.transitTo,
                        r = e.control.controller.animatingContext,
                        s = new ob(hM, {
                            isTrusted: n.isTrusted,
                            holding: this.holding,
                            direction: VM(r.start, r.end),
                            axesEvent: n
                        });
                    e.trigger(s), s.isCanceled() ? i(IE.DISABLED) : i(IE.ANIMATING).onChange(t)
                }, e
            }(dw),
            pw = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.holding = !0, e.animating = !1, e._releaseEvent = null, e
                }
                TE(e, t);
                var n = e.prototype;
                return n.onChange = function (t) {
                    var e = t.flicking,
                        n = t.axesEvent,
                        i = t.transitTo,
                        r = n.inputEvent,
                        s = e.horizontal ? r.offsetX : r.offsetY,
                        o = new ob(hM, {
                            isTrusted: n.isTrusted,
                            holding: this.holding,
                            direction: VM(0, -s),
                            axesEvent: n
                        });
                    e.trigger(o), o.isCanceled() ? i(IE.DISABLED) : i(IE.DRAGGING).onChange(t)
                }, n.onRelease = function (t) {
                    var e = t.flicking,
                        n = t.axesEvent,
                        i = t.transitTo;
                    if (e.trigger(new ob(uM, {
                            axesEvent: n
                        })), 0 !== n.delta.flick) return n.setTo({
                        flick: e.camera.position
                    }, 0), void i(IE.IDLE);
                    this._releaseEvent = n
                }, n.onFinish = function (t) {
                    var e, n, i = t.flicking;
                    if ((0, t.transitTo)(IE.IDLE), this._releaseEvent) {
                        var r, s = this._releaseEvent.inputEvent.srcEvent;
                        if ("touchend" === s.type) {
                            var o = s.changedTouches[0];
                            r = document.elementFromPoint(o.clientX, o.clientY)
                        } else r = s.target;
                        var a = i.renderer.panels,
                            l = null;
                        try {
                            for (var c = RE(a), u = c.next(); !u.done; u = c.next()) {
                                var h = u.value;
                                if (h.contains(r)) {
                                    l = h;
                                    break
                                }
                            }
                        } catch (t) {
                            e = {
                                error: t
                            }
                        } finally {
                            try {
                                u && !u.done && (n = c.return) && n.call(c)
                            } finally {
                                if (e) throw e.error
                            }
                        }
                        if (l) {
                            var d = i.camera.position,
                                f = l.position;
                            i.trigger(new ob(_M, {
                                index: l.index,
                                panel: l,
                                direction: VM(d, f)
                            }))
                        }
                    }
                }, e
            }(dw),
            mw = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.holding = !0, e.animating = !0, e
                }
                TE(e, t);
                var n = e.prototype;
                return n.onChange = function (t) {
                    this._moveToChangedPosition(t)
                }, n.onRelease = function (t) {
                    var e, n = t.flicking,
                        i = t.axesEvent,
                        r = t.transitTo;
                    if (n.trigger(new ob(uM, {
                            axesEvent: i
                        })), n.renderer.panelCount <= 0) r(IE.IDLE);
                    else {
                        r(IE.ANIMATING);
                        var s = n.control,
                            o = i.destPos[cw],
                            a = Math.max(i.duration, n.duration);
                        try {
                            s.moveToPosition(o, a, i)
                        } catch (t) {
                            r(IE.IDLE), i.setTo(((e = {})[cw] = n.camera.position, e), 0)
                        }
                    }
                }, e
            }(dw),
            gw = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.holding = !1, e.animating = !0, e
                }
                TE(e, t);
                var n = e.prototype;
                return n.onHold = function (t) {
                    var e = t.flicking,
                        n = t.axesEvent,
                        i = t.transitTo,
                        r = this._targetPanel,
                        s = e.control;
                    this._delta = 0, e.control.updateInput(), e.changeOnHold && r && s.setActive(r, s.activePanel, n.isTrusted);
                    var o = new ob(cM, {
                        axesEvent: n
                    });
                    e.trigger(o), o.isCanceled() ? i(IE.DISABLED) : i(IE.DRAGGING)
                }, n.onChange = function (t) {
                    this._moveToChangedPosition(t)
                }, n.onFinish = function (t) {
                    var e = t.flicking,
                        n = t.axesEvent,
                        i = t.transitTo,
                        r = e.control,
                        s = r.controller.animatingContext;
                    i(IE.IDLE), e.trigger(new ob(fM, {
                        isTrusted: n.isTrusted,
                        direction: VM(s.start, s.end),
                        axesEvent: n
                    }));
                    var o = this._targetPanel;
                    o && r.setActive(o, r.activePanel, n.isTrusted)
                }, e
            }(dw),
            vw = function (t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.holding = !1, e.animating = !0, e
                }
                TE(e, t);
                var n = e.prototype;
                return n.onAnimationEnd = function (t) {
                    (0, t.transitTo)(IE.IDLE)
                }, n.onChange = function (t) {
                    var e = t.axesEvent,
                        n = t.transitTo;
                    e.stop(), n(IE.IDLE)
                }, n.onRelease = function (t) {
                    var e = t.axesEvent,
                        n = t.transitTo;
                    0 === e.delta.flick && n(IE.IDLE)
                }, e
            }(dw),
            _w = function () {
                function t() {
                    var t = this;
                    this.transitTo = function (e) {
                        var n;
                        switch (e) {
                            case IE.IDLE:
                                n = new fw;
                                break;
                            case IE.HOLDING:
                                n = new pw;
                                break;
                            case IE.DRAGGING:
                                n = new mw;
                                break;
                            case IE.ANIMATING:
                                n = new gw;
                                break;
                            case IE.DISABLED:
                                n = new vw
                        }
                        return n.onEnter(t._state), t._state = n, t._state
                    }, this._state = new fw
                }
                var e = t.prototype;
                return Object.defineProperty(e, "state", {
                    get: function () {
                        return this._state
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.fire = function (t, e) {
                    var n = this._state,
                        i = AE(AE({}, e), {
                            transitTo: this.transitTo
                        });
                    switch (t) {
                        case lw.HOLD:
                            n.onHold(i);
                            break;
                        case lw.CHANGE:
                            n.onChange(i);
                            break;
                        case lw.RELEASE:
                            n.onRelease(i);
                            break;
                        case lw.ANIMATION_END:
                            n.onAnimationEnd(i);
                            break;
                        case lw.FINISH:
                            n.onFinish(i)
                    }
                }, t
            }(),
            yw = function () {
                function t() {
                    var t = this;
                    this._onAxesHold = function () {
                        t._dragged = !1
                    }, this._onAxesChange = function () {
                        var e;
                        t._dragged = !!(null === (e = t._panInput) || void 0 === e ? void 0 : e.isEnabled())
                    }, this._preventClickWhenDragged = function (e) {
                        t._dragged && (e.preventDefault(), e.stopPropagation()), t._dragged = !1
                    }, this._resetInternalValues(), this._stateMachine = new _w
                }
                var e = t.prototype;
                return Object.defineProperty(e, "axes", {
                    get: function () {
                        return this._axes
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "panInput", {
                    get: function () {
                        return this._panInput
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "stateMachine", {
                    get: function () {
                        return this._stateMachine
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "state", {
                    get: function () {
                        return this._stateMachine.state
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "animatingContext", {
                    get: function () {
                        return this._animatingContext
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "controlParams", {
                    get: function () {
                        var t = this._axes;
                        if (!t) return {
                            range: {
                                min: 0,
                                max: 0
                            },
                            position: 0,
                            circular: !1
                        };
                        var e = t.axis[cw];
                        return {
                            range: {
                                min: e.range[0],
                                max: e.range[1]
                            },
                            circular: e.circular[0],
                            position: this.position
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "enabled", {
                    get: function () {
                        var t, e;
                        return null !== (e = null === (t = this._panInput) || void 0 === t ? void 0 : t.isEnabled()) && void 0 !== e && e
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "position", {
                    get: function () {
                        var t, e;
                        return null !== (e = null === (t = this._axes) || void 0 === t ? void 0 : t.get([cw])[cw]) && void 0 !== e ? e : 0
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "range", {
                    get: function () {
                        var t, e;
                        return null !== (e = null === (t = this._axes) || void 0 === t ? void 0 : t.axis[cw].range) && void 0 !== e ? e : [0, 0]
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "bounce", {
                    get: function () {
                        var t;
                        return null === (t = this._axes) || void 0 === t ? void 0 : t.axis[cw].bounce
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.init = function (t) {
                    var e, n = this;
                    this._flicking = t, this._axes = new ZS(((e = {})[cw] = {
                        range: [0, 0],
                        circular: !1,
                        bounce: [0, 0]
                    }, e), {
                        deceleration: t.deceleration,
                        interruptable: t.interruptable,
                        nested: t.nested,
                        easing: t.easing
                    }), this._panInput = new KS(t.viewport.element, {
                        inputType: t.inputType,
                        threshold: 1,
                        iOSEdgeSwipeThreshold: t.iOSEdgeSwipeThreshold,
                        preventDefaultOnDrag: t.preventDefaultOnDrag,
                        scale: t.horizontal ? [t.camera.panelOrder === DM ? 1 : -1, 0] : [0, -1],
                        releaseOnScroll: !0
                    });
                    var i = this._axes;
                    i.connect(t.horizontal ? [cw, ""] : ["", cw], this._panInput);
                    var r = function (e) {
                        var r = lw[e];
                        i.on(r, (function (e) {
                            n._stateMachine.fire(r, {
                                flicking: t,
                                axesEvent: e
                            })
                        }))
                    };
                    for (var s in lw) r(s);
                    return this
                }, e.destroy = function () {
                    var t;
                    this._axes && (this.removePreventClickHandler(), this._axes.destroy()), null === (t = this._panInput) || void 0 === t || t.destroy(), this._resetInternalValues()
                }, e.enable = function () {
                    var t;
                    return null === (t = this._panInput) || void 0 === t || t.enable(), this
                }, e.disable = function () {
                    var t;
                    return null === (t = this._panInput) || void 0 === t || t.disable(), this
                }, e.release = function () {
                    var t;
                    return null === (t = this._panInput) || void 0 === t || t.release(), this
                }, e.updateAnimation = function (t, e) {
                    var n, i;
                    return this._animatingContext = AE(AE({}, this._animatingContext), {
                        end: t
                    }), null === (i = this._axes) || void 0 === i || i.updateAnimation({
                        destPos: (n = {}, n[cw] = t, n),
                        duration: e
                    }), this
                }, e.stopAnimation = function () {
                    var t;
                    return null === (t = this._axes) || void 0 === t || t.stopAnimation(), this
                }, e.update = function (t) {
                    var e, n = UM(this._flicking),
                        i = n.camera,
                        r = this._axes,
                        s = r.axis[cw];
                    return s.circular = [t.circular, t.circular], s.range = [t.range.min, t.range.max], s.bounce = function (t, e) {
                        var n;
                        if (Array.isArray(t)) n = t.map((function (t) {
                            return zM(t, e)
                        }));
                        else {
                            var i = zM(t, e);
                            n = [i, i]
                        }
                        return n.map((function (e) {
                            if (null == e) throw new nw(JE("bounce", t), FE);
                            return e
                        }))
                    }(n.bounce, i.size), r.axisManager.set(((e = {})[cw] = t.position, e)), this
                }, e.addPreventClickHandler = function () {
                    var t = UM(this._flicking),
                        e = this._axes,
                        n = t.camera.element;
                    return e.on(lw.HOLD, this._onAxesHold), e.on(lw.CHANGE, this._onAxesChange), n.addEventListener("click", this._preventClickWhenDragged, !0), this
                }, e.removePreventClickHandler = function () {
                    var t = UM(this._flicking),
                        e = this._axes,
                        n = t.camera.element;
                    return e.off(lw.HOLD, this._onAxesHold), e.off(lw.CHANGE, this._onAxesChange), n.removeEventListener("click", this._preventClickWhenDragged, !0), this
                }, e.animateTo = function (t, e, n) {
                    var i, r = this,
                        s = this._axes,
                        o = this._stateMachine.state;
                    if (!s) return Promise.reject(new nw(ZE, kE));
                    var a = s.get([cw])[cw];
                    if (a === t) {
                        var l = UM(this._flicking);
                        return l.camera.lookAt(t), o.targetPanel && l.control.setActive(o.targetPanel, l.control.activePanel, null !== (i = null == n ? void 0 : n.isTrusted) && void 0 !== i && i), Promise.resolve()
                    }
                    this._animatingContext = {
                        start: a,
                        end: t,
                        offset: 0
                    };
                    return new Promise((function (i, o) {
                        var a = function () {
                                s.off(lw.HOLD, l), i()
                            },
                            l = function () {
                                s.off(lw.FINISH, a), o(new nw(nM, GE))
                            };
                        s.once(lw.FINISH, a), s.once(lw.HOLD, l),
                            function () {
                                var i, o;
                                s.once(lw.FINISH, (function () {
                                    r._animatingContext = {
                                        start: 0,
                                        end: 0,
                                        offset: 0
                                    }
                                })), n ? n.setTo(((i = {})[cw] = t, i), e) : s.setTo(((o = {})[cw] = t, o), e)
                            }()
                    }))
                }, e.updateDirection = function () {
                    var t = UM(this._flicking),
                        e = this._axes,
                        n = this._panInput;
                    e.disconnect(n), e.connect(t.horizontal ? [cw, ""] : ["", cw], n), n.options.scale = t.horizontal ? [t.camera.panelOrder === DM ? 1 : -1, 0] : [0, -1]
                }, e._resetInternalValues = function () {
                    this._flicking = null, this._axes = null, this._panInput = null, this._animatingContext = {
                        start: 0,
                        end: 0,
                        offset: 0
                    }, this._dragged = !1
                }, t
            }(),
            xw = function () {
                function t() {
                    this._flicking = null, this._controller = new yw, this._activePanel = null
                }
                var e = t.prototype;
                return Object.defineProperty(e, "controller", {
                    get: function () {
                        return this._controller
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "activeIndex", {
                    get: function () {
                        var t, e;
                        return null !== (e = null === (t = this._activePanel) || void 0 === t ? void 0 : t.index) && void 0 !== e ? e : -1
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "activePanel", {
                    get: function () {
                        return this._activePanel
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "animating", {
                    get: function () {
                        return this._controller.state.animating
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "holding", {
                    get: function () {
                        return this._controller.state.holding
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.init = function (t) {
                    return this._flicking = t, this._controller.init(t), this
                }, e.destroy = function () {
                    this._controller.destroy(), this._flicking = null, this._activePanel = null
                }, e.enable = function () {
                    return this._controller.enable(), this
                }, e.disable = function () {
                    return this._controller.disable(), this
                }, e.release = function () {
                    return this._controller.release(), this
                }, e.updateAnimation = function (t, e, n) {
                    var i = this._controller.state,
                        r = this._getPosition(t, null != n ? n : PM);
                    return i.targetPanel = t, this._controller.updateAnimation(r, e), this
                }, e.stopAnimation = function () {
                    return this._controller.state.targetPanel = null, this._controller.stopAnimation(), this
                }, e.updatePosition = function (t) {
                    var e = UM(this._flicking).camera,
                        n = this._activePanel;
                    n && e.lookAt(e.clampToReachablePosition(n.position))
                }, e.updateInput = function () {
                    var t = UM(this._flicking).camera;
                    return this._controller.update(t.controlParams), this
                }, e.resetActive = function () {
                    return this._activePanel = null, this
                }, e.moveToPanel = function (t, e) {
                    var n = e.duration,
                        i = e.direction,
                        r = void 0 === i ? PM : i,
                        s = e.axesEvent;
                    return PE(this, void 0, void 0, (function () {
                        var e;
                        return CE(this, (function (i) {
                            return e = this._getPosition(t, r), this._triggerIndexChangeEvent(t, t.position, s), [2, this._animateToPosition({
                                position: e,
                                duration: n,
                                newActivePanel: t,
                                axesEvent: s
                            })]
                        }))
                    }))
                }, e.setActive = function (t, e, n) {
                    var i, r = UM(this._flicking);
                    this._activePanel = t, this._nextPanel = null, r.camera.updateAdaptiveHeight(), t !== e ? r.trigger(new ob(mM, {
                        index: t.index,
                        panel: t,
                        prevIndex: null !== (i = null == e ? void 0 : e.index) && void 0 !== i ? i : -1,
                        prevPanel: e,
                        isTrusted: n,
                        direction: e ? VM(e.position, t.position) : PM
                    })) : r.trigger(new ob(vM, {
                        isTrusted: n
                    }))
                }, e.copy = function (t) {
                    this._flicking = t._flicking, this._activePanel = t._activePanel, this._controller = t._controller
                }, e._triggerIndexChangeEvent = function (t, e, n) {
                    var i, r = UM(this._flicking),
                        s = t !== this._activePanel ? pM : gM,
                        o = r.camera,
                        a = this._activePanel,
                        l = new ob(s, {
                            index: t.index,
                            panel: t,
                            isTrusted: (null == n ? void 0 : n.isTrusted) || !1,
                            direction: VM(null !== (i = null == a ? void 0 : a.position) && void 0 !== i ? i : o.position, e)
                        });
                    if (this._nextPanel = t, r.trigger(l), l.isCanceled()) throw new nw(eM, VE)
                }, e._animateToPosition = function (t) {
                    var e = t.position,
                        n = t.duration,
                        i = t.newActivePanel,
                        r = t.axesEvent;
                    return PE(this, void 0, void 0, (function () {
                        var t, s, o = this;
                        return CE(this, (function (a) {
                            return t = UM(this._flicking), s = function () {
                                return o._controller.animateTo(e, n, r)
                            }, this._controller.state.targetPanel = i, n <= 0 ? [2, s()] : [2, s().then((function () {
                                return PE(o, void 0, void 0, (function () {
                                    return CE(this, (function (e) {
                                        switch (e.label) {
                                            case 0:
                                                return [4, t.renderer.render()];
                                            case 1:
                                                return e.sent(), [2]
                                        }
                                    }))
                                }))
                            })).catch((function (t) {
                                if (!(r && t instanceof nw && t.code === GE)) throw t
                            }))]
                        }))
                    }))
                }, e._getPosition = function (t, e) {
                    void 0 === e && (e = PM);
                    var n = UM(this._flicking),
                        i = n.camera,
                        r = t.position,
                        s = i.findNearestAnchor(r);
                    if (t.removed || !s) throw new nw(QE(t.position), BE);
                    if (i.canReach(t)) {
                        if (n.circularEnabled) {
                            var o = this._controller.position,
                                a = i.rangeDiff,
                                l = [r, r + a, r - a].filter((function (t) {
                                    return e === PM || (e === TM ? t <= o : t >= o)
                                }));
                            r = l.reduce((function (t, e) {
                                return Math.abs(o - e) < Math.abs(o - t) ? e : t
                            }), 1 / 0)
                        }
                    } else r = s.position, t = s.panel;
                    return r
                }, t
            }(),
            bw = function () {
                function t(t) {
                    var e = t.index,
                        n = t.position,
                        i = t.panel;
                    this._index = e, this._pos = n, this._panel = i
                }
                var e = t.prototype;
                return Object.defineProperty(e, "index", {
                    get: function () {
                        return this._index
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "position", {
                    get: function () {
                        return this._pos
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "panel", {
                    get: function () {
                        return this._panel
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(),
            Sw = function (t) {
                function e(e) {
                    var n = (void 0 === e ? {} : e).count,
                        i = void 0 === n ? 1 / 0 : n,
                        r = t.call(this) || this;
                    return r._count = i, r
                }
                TE(e, t);
                var n = e.prototype;
                return Object.defineProperty(n, "count", {
                    get: function () {
                        return this._count
                    },
                    set: function (t) {
                        this._count = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), n.moveToPosition = function (t, e, n) {
                    var i = UM(this._flicking),
                        r = i.camera,
                        s = r.findActiveAnchor(),
                        o = r.findNearestAnchor(r.position),
                        a = this._controller.state;
                    if (!s || !o) return Promise.reject(new nw(QE(t), BE));
                    var l, c = this._calcSnapThreshold(t, s),
                        u = i.animating ? a.delta : t - r.position,
                        h = Math.abs(u),
                        d = n && 0 !== n.delta[cw] ? Math.abs(n.delta[cw]) : h;
                    if (d >= c && d > 0) l = this._findSnappedAnchor(t, o);
                    else {
                        if (!(h >= i.threshold && h > 0)) return this.moveToPanel(o.panel, {
                            duration: e,
                            axesEvent: n
                        });
                        l = this._findAdjacentAnchor(t, u, o)
                    }
                    return this._triggerIndexChangeEvent(l.panel, t, n), this._animateToPosition({
                        position: r.clampToReachablePosition(l.position),
                        duration: e,
                        newActivePanel: l.panel,
                        axesEvent: n
                    })
                }, n._findSnappedAnchor = function (t, e) {
                    var n = UM(this._flicking),
                        i = n.camera,
                        r = this._count,
                        s = i.position,
                        o = i.clampToReachablePosition(t),
                        a = i.findAnchorIncludePosition(o);
                    if (!e || !a) throw new nw(QE(t), BE);
                    if (!isFinite(r)) return a;
                    var l = n.panelCount,
                        c = i.anchorPoints,
                        u = Math.sign(t - s) * Math.floor(Math.abs(t - s) / i.rangeDiff);
                    t > s && a.index < e.index || a.position > e.position && a.index === e.index ? u += 1 : (t < s && a.index > e.index || a.position < e.position && a.index === e.index) && (u -= 1);
                    var h = u * l,
                        d = a.index + h;
                    if (Math.abs(d - e.index) <= r) {
                        var f = c[a.index];
                        return new bw({
                            index: f.index,
                            position: f.position + u * i.rangeDiff,
                            panel: f.panel
                        })
                    }
                    if (n.circularEnabled) {
                        var p = c[$M(e.index + Math.sign(t - s) * r, l)],
                            m = Math.floor(r / l);
                        return t > s && p.index < e.index ? m += 1 : t < s && p.index > e.index && (m -= 1), new bw({
                            index: p.index,
                            position: p.position + m * i.rangeDiff,
                            panel: p.panel
                        })
                    }
                    return c[NM(e.index + Math.sign(t - s) * r, 0, c.length - 1)]
                }, n._findAdjacentAnchor = function (t, e, n) {
                    var i, r = UM(this._flicking).camera;
                    if (r.circularEnabled) {
                        var s = r.findAnchorIncludePosition(t);
                        if (s && s.position !== n.position) return s
                    }
                    return null !== (i = e > 0 ? r.getNextAnchor(n) : r.getPrevAnchor(n)) && void 0 !== i ? i : n
                }, n._calcSnapThreshold = function (t, e) {
                    var n = t > e.position,
                        i = e.panel,
                        r = i.size,
                        s = i.alignPosition;
                    return n ? r - s + i.margin.next : s + i.margin.prev
                }, e
            }(xw),
            Ew = function (t) {
                function e(e) {
                    var n = (void 0 === e ? {} : e).stopAtEdge,
                        i = void 0 === n || n,
                        r = t.call(this) || this;
                    return r._stopAtEdge = i, r
                }
                TE(e, t);
                var n = e.prototype;
                return Object.defineProperty(n, "stopAtEdge", {
                    get: function () {
                        return this._stopAtEdge
                    },
                    set: function (t) {
                        this._stopAtEdge = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), n.updatePosition = function (t) {
                    var e = UM(this._flicking).camera,
                        n = this._activePanel;
                    if (n) {
                        var i = n.range,
                            r = i.min + (i.max - i.min) * t;
                        e.lookAt(e.clampToReachablePosition(r))
                    }
                }, n.moveToPosition = function (t, e, n) {
                    var i = UM(this._flicking).camera,
                        r = i.clampToReachablePosition(t),
                        s = i.findAnchorIncludePosition(r);
                    if (!s) return Promise.reject(new nw(QE(t), BE));
                    var o = s.panel;
                    return o !== this._activePanel && this._triggerIndexChangeEvent(o, t, n), this._animateToPosition({
                        position: this._stopAtEdge ? r : t,
                        duration: e,
                        newActivePanel: o,
                        axesEvent: n
                    })
                }, e
            }(xw),
            Mw = function (t) {
                function e(e) {
                    var n = (void 0 === e ? {} : e).count,
                        i = void 0 === n ? 1 : n,
                        r = t.call(this) || this;
                    return r.setActive = function (e, n, i) {
                        t.prototype.setActive.call(r, e, n, i), r.updateInput()
                    }, r._count = i, r._resetIndexRange(), r
                }
                TE(e, t);
                var n = e.prototype;
                return Object.defineProperty(n, "count", {
                    get: function () {
                        return this._count
                    },
                    set: function (t) {
                        this._count = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), n.destroy = function () {
                    t.prototype.destroy.call(this), this._resetIndexRange()
                }, n.updateInput = function () {
                    var t, e = UM(this._flicking),
                        n = e.camera,
                        i = e.renderer,
                        r = this._controller,
                        s = n.controlParams,
                        o = this._count,
                        a = r.state.animating ? null === (t = n.findNearestAnchor(n.position)) || void 0 === t ? void 0 : t.panel : this._activePanel;
                    if (!a) return r.update(s), this._resetIndexRange(), this;
                    var l = s.range,
                        c = a.position,
                        u = a.index,
                        h = i.panelCount,
                        d = u - o,
                        f = u + o;
                    d < 0 && (d = e.circularEnabled ? WM((d + 1) % h - 1, h) : NM(d, 0, h - 1)), f >= h && (f = e.circularEnabled ? f % h : NM(f, 0, h - 1));
                    var p = i.panels[d],
                        m = i.panels[f],
                        g = Math.max(p.position, l.min),
                        v = Math.min(m.position, l.max);
                    return g > c && (g -= n.rangeDiff), v < c && (v += n.rangeDiff), s.range = {
                        min: g,
                        max: v
                    }, s.circular && (s.position < g && (s.position += n.rangeDiff), s.position > v && (s.position -= n.rangeDiff)), s.circular = !1, r.update(s), this._indexRange = {
                        min: p.index,
                        max: m.index
                    }, this
                }, n.moveToPanel = function (e, n) {
                    return PE(this, void 0, void 0, (function () {
                        var i, r;
                        return CE(this, (function (s) {
                            return i = UM(this._flicking), r = i.camera, this._controller.update(r.controlParams), [2, t.prototype.moveToPanel.call(this, e, n)]
                        }))
                    }))
                }, n.moveToPosition = function (t, e, n) {
                    var i, r = UM(this._flicking),
                        s = r.camera,
                        o = null !== (i = this._nextPanel) && void 0 !== i ? i : this._activePanel,
                        a = this._controller.range,
                        l = this._indexRange,
                        c = s.range,
                        u = this._controller.state,
                        h = NM(s.clampToReachablePosition(t), a[0], a[1]),
                        d = s.findAnchorIncludePosition(h);
                    if (!d || !o) return Promise.reject(new nw(QE(t), BE));
                    var f, p, m = o.position,
                        g = r.animating ? u.delta : t - s.position,
                        v = Math.abs(g) >= r.threshold,
                        _ = t > m ? s.getNextAnchor(d) : s.getPrevAnchor(d),
                        y = s.anchorPoints,
                        x = y[0],
                        b = y[y.length - 1],
                        S = t <= c.min && JM(x.panel.index, l.min, l.max),
                        E = t >= c.max && JM(b.panel.index, l.min, l.max),
                        M = _ && (l.min <= l.max ? JM(_.index, l.min, l.max) : _.index >= l.min || _.index <= l.max);
                    if (S || E) {
                        var w = t < c.min ? x : b;
                        p = w.panel, f = w.position
                    } else if (v && d.position !== o.position) p = d.panel, f = d.position;
                    else {
                        if (!v || !M) {
                            var T = s.findNearestAnchor(s.position);
                            return T ? this.moveToPanel(T.panel, {
                                duration: e,
                                axesEvent: n
                            }) : Promise.reject(new nw(QE(t), BE))
                        }
                        p = _.panel, f = _.position
                    }
                    return this._triggerIndexChangeEvent(p, t, n), this._animateToPosition({
                        position: f,
                        duration: e,
                        newActivePanel: p,
                        axesEvent: n
                    })
                }, n._resetIndexRange = function () {
                    this._indexRange = {
                        min: 0,
                        max: 0
                    }
                }, e
            }(xw),
            ww = function () {
                function t(t) {
                    this._flicking = t
                }
                var e = t.prototype;
                return e.getAnchors = function () {
                    return this._flicking.renderer.panels.map((function (t, e) {
                        return new bw({
                            index: e,
                            position: t.position,
                            panel: t
                        })
                    }))
                }, e.findAnchorIncludePosition = function (t) {
                    return this._flicking.camera.anchorPoints.filter((function (e) {
                        return e.panel.includePosition(t, !0)
                    })).reduce((function (e, n) {
                        return e && Math.abs(e.position - t) < Math.abs(n.position - t) ? e : n
                    }), null)
                }, e.findNearestAnchor = function (t) {
                    var e = this._flicking.camera.anchorPoints;
                    if (e.length <= 0) return null;
                    for (var n = 1 / 0, i = 0; i < e.length; i++) {
                        var r = e[i],
                            s = Math.abs(r.position - t);
                        if (s > n) return e[i - 1];
                        n = s
                    }
                    return e[e.length - 1]
                }, e.clampToReachablePosition = function (t) {
                    var e = this._flicking.camera.range;
                    return NM(t, e.min, e.max)
                }, e.getCircularOffset = function () {
                    return 0
                }, e.canReach = function (t) {
                    var e = this._flicking.camera.range;
                    if (t.removed) return !1;
                    var n = t.position;
                    return n >= e.min && n <= e.max
                }, e.canSee = function (t) {
                    var e = this._flicking.camera.visibleRange;
                    return t.isVisibleOnRange(e.min, e.max)
                }, t
            }(),
            Tw = function (t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                TE(e, t);
                var n = e.prototype;
                return n.checkAvailability = function () {
                    return !0
                }, n.getRange = function () {
                    var t, e, n = this._flicking.renderer,
                        i = n.getPanel(0),
                        r = n.getPanel(n.panelCount - 1);
                    return {
                        min: null !== (t = null == i ? void 0 : i.position) && void 0 !== t ? t : 0,
                        max: null !== (e = null == r ? void 0 : r.position) && void 0 !== e ? e : 0
                    }
                }, e
            }(ww),
            Aw = function (t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                TE(e, t);
                var n = e.prototype;
                return n.checkAvailability = function () {
                    var t = this._flicking,
                        e = t.renderer.panels;
                    if (e.length <= 0) return !1;
                    var n = e[0],
                        i = e[e.length - 1],
                        r = n.range.min - n.margin.prev,
                        s = i.range.max + i.margin.next,
                        o = t.camera.size,
                        a = s - r;
                    return e.every((function (t) {
                        return a - t.size >= o
                    }))
                }, n.getRange = function () {
                    var t = this._flicking.renderer.panels;
                    if (t.length <= 0) return {
                        min: 0,
                        max: 0
                    };
                    var e = t[0],
                        n = t[t.length - 1];
                    return {
                        min: e.range.min - e.margin.prev,
                        max: n.range.max + n.margin.next
                    }
                }, n.getAnchors = function () {
                    return this._flicking.renderer.panels.map((function (t, e) {
                        return new bw({
                            index: e,
                            position: t.position,
                            panel: t
                        })
                    }))
                }, n.findNearestAnchor = function (t) {
                    var e = this._flicking.camera,
                        n = e.anchorPoints;
                    if (n.length <= 0) return null;
                    for (var i = e.range, r = 1 / 0, s = -1, o = 0; o < n.length; o++) {
                        var a = n[o],
                            l = Math.min(Math.abs(a.position - t), Math.abs(a.position - i.min + i.max - t), Math.abs(t - i.min + i.max - a.position));
                        l < r && (r = l, s = o)
                    }
                    return n[s]
                }, n.findAnchorIncludePosition = function (e) {
                    var n = this._flicking.camera,
                        i = n.range,
                        r = n.anchorPoints,
                        s = n.rangeDiff,
                        o = r.length,
                        a = qM(e, i.min, i.max),
                        l = t.prototype.findAnchorIncludePosition.call(this, a);
                    if (o > 0 && (e === i.min || e === i.max)) {
                        var c = [l, new bw({
                            index: 0,
                            position: r[0].position + s,
                            panel: r[0].panel
                        }), new bw({
                            index: o - 1,
                            position: r[o - 1].position - s,
                            panel: r[o - 1].panel
                        })].filter((function (t) {
                            return !!t
                        }));
                        l = c.reduce((function (t, n) {
                            return t && Math.abs(t.position - e) < Math.abs(n.position - e) ? t : n
                        }), null)
                    }
                    if (!l) return null;
                    if (e < i.min) {
                        var u = -Math.floor((i.min - e) / s) - 1;
                        return new bw({
                            index: l.index,
                            position: l.position + s * u,
                            panel: l.panel
                        })
                    }
                    if (e > i.max) {
                        u = Math.floor((e - i.max) / s) + 1;
                        return new bw({
                            index: l.index,
                            position: l.position + s * u,
                            panel: l.panel
                        })
                    }
                    return l
                }, n.getCircularOffset = function () {
                    var t = this._flicking;
                    if (!t.camera.circularEnabled) return 0;
                    var e = t.panels.filter((function (t) {
                            return t.toggled
                        })),
                        n = e.filter((function (t) {
                            return t.toggleDirection === TM
                        })),
                        i = e.filter((function (t) {
                            return t.toggleDirection === AM
                        }));
                    return this._calcPanelAreaSum(n) - this._calcPanelAreaSum(i)
                }, n.clampToReachablePosition = function (t) {
                    return t
                }, n.canReach = function (t) {
                    return !t.removed
                }, n.canSee = function (e) {
                    var n = this._flicking.camera,
                        i = n.range,
                        r = n.rangeDiff,
                        s = n.visibleRange,
                        o = t.prototype.canSee.call(this, e);
                    return s.min < i.min ? o || e.isVisibleOnRange(s.min + r, s.max + r) : s.max > i.max ? o || e.isVisibleOnRange(s.min - r, s.max - r) : o
                }, n._calcPanelAreaSum = function (t) {
                    return t.reduce((function (t, e) {
                        return t + e.sizeIncludingMargin
                    }), 0)
                }, e
            }(ww),
            Pw = function (t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                TE(e, t);
                var n = e.prototype;
                return n.checkAvailability = function () {
                    var t = this._flicking,
                        e = t.renderer,
                        n = e.getPanel(0),
                        i = e.getPanel(e.panelCount - 1);
                    if (!n || !i) return !1;
                    var r = t.camera.size,
                        s = n.range.min;
                    return r < i.range.max - s
                }, n.getRange = function () {
                    var t = this._flicking,
                        e = t.renderer,
                        n = t.camera.alignPosition,
                        i = e.getPanel(0),
                        r = e.getPanel(e.panelCount - 1);
                    if (!i || !r) return {
                        min: 0,
                        max: 0
                    };
                    var s = t.camera.size,
                        o = i.range.min,
                        a = r.range.max,
                        l = o + n,
                        c = a - s + n;
                    if (s < a - o) return {
                        min: l,
                        max: c
                    };
                    var u = t.camera.align,
                        h = "object" == typeof u ? u.camera : u,
                        d = l + FM(h, c - l);
                    return {
                        min: d,
                        max: d
                    }
                }, n.getAnchors = function () {
                    var t = this._flicking,
                        e = t.camera,
                        n = t.renderer.panels;
                    if (n.length <= 0) return [];
                    var i = t.camera.range,
                        r = n.filter((function (t) {
                            return e.canReach(t)
                        }));
                    if (r.length > 0) {
                        var s = r[0].position !== i.min,
                            o = r[r.length - 1].position !== i.max,
                            a = s ? 1 : 0,
                            l = r.map((function (t, e) {
                                return new bw({
                                    index: e + a,
                                    position: t.position,
                                    panel: t
                                })
                            }));
                        return s && l.splice(0, 0, new bw({
                            index: 0,
                            position: i.min,
                            panel: n[r[0].index - 1]
                        })), o && l.push(new bw({
                            index: l.length,
                            position: i.max,
                            panel: n[r[r.length - 1].index + 1]
                        })), l
                    }
                    if (i.min !== i.max) {
                        var c = this._findNearestPanel(i.min, n),
                            u = c.index === n.length - 1 ? c.prev() : c,
                            h = u.next();
                        return [new bw({
                            index: 0,
                            position: i.min,
                            panel: u
                        }), new bw({
                            index: 1,
                            position: i.max,
                            panel: h
                        })]
                    }
                    return [new bw({
                        index: 0,
                        position: i.min,
                        panel: this._findNearestPanel(i.min, n)
                    })]
                }, n.findAnchorIncludePosition = function (e) {
                    var n = this._flicking.camera,
                        i = n.range,
                        r = n.anchorPoints;
                    return r.length <= 0 ? null : e <= i.min ? r[0] : e >= i.max ? r[r.length - 1] : t.prototype.findAnchorIncludePosition.call(this, e)
                }, n._findNearestPanel = function (t, e) {
                    for (var n = 1 / 0, i = 0; i < e.length; i++) {
                        var r = e[i],
                            s = Math.abs(r.position - t);
                        if (s > n) return e[i - 1];
                        n = s
                    }
                    return e[e.length - 1]
                }, e
            }(ww),
            Cw = function () {
                function t(t, e) {
                    var n = this,
                        i = (void 0 === e ? {} : e).align,
                        r = void 0 === i ? MM : i;
                    this._checkTranslateSupport = function () {
                        var t, e, i = document.documentElement.style,
                            r = "";
                        try {
                            for (var s = RE(["webkitTransform", "msTransform", "MozTransform", "OTransform", "transform"]), o = s.next(); !o.done; o = s.next()) {
                                var a = o.value;
                                a in i && (r = a)
                            }
                        } catch (e) {
                            t = {
                                error: e
                            }
                        } finally {
                            try {
                                o && !o.done && (e = s.return) && e.call(s)
                            } finally {
                                if (t) throw t.error
                            }
                        }
                        if (!r) throw new nw(tM, HE);
                        n._transform = r
                    }, this._flicking = t, this._resetInternalValues(), this._align = r
                }
                var e = t.prototype;
                return Object.defineProperty(e, "element", {
                    get: function () {
                        return this._el
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "children", {
                    get: function () {
                        return kM(this._el.children)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "position", {
                    get: function () {
                        return this._position
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "alignPosition", {
                    get: function () {
                        return this._alignPos
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "offset", {
                    get: function () {
                        return this._offset - this._circularOffset
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "circularEnabled", {
                    get: function () {
                        return this._circularEnabled
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "mode", {
                    get: function () {
                        return this._mode
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "range", {
                    get: function () {
                        return this._range
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "rangeDiff", {
                    get: function () {
                        return this._range.max - this._range.min
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "visiblePanels", {
                    get: function () {
                        return this._visiblePanels
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "visibleRange", {
                    get: function () {
                        return {
                            min: this._position - this._alignPos,
                            max: this._position - this._alignPos + this.size
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "anchorPoints", {
                    get: function () {
                        return this._anchors
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "controlParams", {
                    get: function () {
                        return {
                            range: this._range,
                            position: this._position,
                            circular: this._circularEnabled
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "atEdge", {
                    get: function () {
                        return this._position <= this._range.min || this._position >= this._range.max
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "size", {
                    get: function () {
                        var t = this._flicking;
                        return t ? t.horizontal ? t.viewport.width : t.viewport.height : 0
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "progress", {
                    get: function () {
                        var t = this._flicking,
                            e = this._position + this._offset,
                            n = this.findNearestAnchor(this._position);
                        if (!t || !n) return NaN;
                        var i = n.panel,
                            r = i.position + i.offset,
                            s = t.control.controller.bounce,
                            o = this.range,
                            a = o.min,
                            l = o.max,
                            c = this.rangeDiff;
                        if (e === r) return i.index;
                        if (e < r) {
                            var u = i.prev(),
                                h = u ? u.position + u.offset : a - s[0];
                            return h > r && (h -= c), i.index - 1 + YM(e, h, r)
                        }
                        var d = i.next(),
                            f = d ? d.position + d.offset : l + s[1];
                        return f < r && (f += c), i.index + YM(e, r, f)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "panelOrder", {
                    get: function () {
                        return this._panelOrder
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "align", {
                    get: function () {
                        return this._align
                    },
                    set: function (t) {
                        this._align = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.init = function () {
                    var t = this._flicking.viewport.element;
                    return function (t, e) {
                        if (null == t) throw new nw(KE(t, e), UE)
                    }(t.firstElementChild, "First element child of the viewport element"), this._el = t.firstElementChild, this._checkTranslateSupport(), this._updateMode(), this.updatePanelOrder(), this
                }, e.destroy = function () {
                    return this._resetInternalValues(), this
                }, e.lookAt = function (t) {
                    var e = this,
                        n = UM(this._flicking),
                        i = this._position;
                    this._position = t;
                    var r = this._togglePanels(i, t);
                    this._refreshVisiblePanels(), this._checkNeedPanel(), this._checkReachEnd(i, t), r ? n.renderer.render().then((function () {
                        e.updateOffset()
                    })) : this.applyTransform()
                }, e.getPrevAnchor = function (t) {
                    if (this._circularEnabled && 0 === t.index) {
                        var e = this._anchors,
                            n = this.rangeDiff,
                            i = e[e.length - 1];
                        return new bw({
                            index: i.index,
                            position: i.position - n,
                            panel: i.panel
                        })
                    }
                    return this._anchors[t.index - 1] || null
                }, e.getNextAnchor = function (t) {
                    var e = this._anchors;
                    if (this._circularEnabled && t.index === e.length - 1) {
                        var n = this.rangeDiff,
                            i = e[0];
                        return new bw({
                            index: i.index,
                            position: i.position + n,
                            panel: i.panel
                        })
                    }
                    return e[t.index + 1] || null
                }, e.getProgressInPanel = function (t) {
                    var e = t.range;
                    return (this._position - e.min) / (e.max - e.min)
                }, e.findAnchorIncludePosition = function (t) {
                    return this._mode.findAnchorIncludePosition(t)
                }, e.findNearestAnchor = function (t) {
                    return this._mode.findNearestAnchor(t)
                }, e.findActiveAnchor = function () {
                    var t = UM(this._flicking).control.activeIndex;
                    return function (t, e) {
                        var n, i;
                        try {
                            for (var r = RE(t), s = r.next(); !s.done; s = r.next()) {
                                var o = s.value;
                                if (e(o)) return o
                            }
                        } catch (t) {
                            n = {
                                error: t
                            }
                        } finally {
                            try {
                                s && !s.done && (i = r.return) && i.call(r)
                            } finally {
                                if (n) throw n.error
                            }
                        }
                        return null
                    }(this._anchors, (function (e) {
                        return e.panel.index === t
                    }))
                }, e.clampToReachablePosition = function (t) {
                    return this._mode.clampToReachablePosition(t)
                }, e.canReach = function (t) {
                    return this._mode.canReach(t)
                }, e.canSee = function (t) {
                    return this._mode.canSee(t)
                }, e.updateRange = function () {
                    var t = UM(this._flicking).renderer.panels;
                    return this._updateMode(), this._range = this._mode.getRange(), t.forEach((function (t) {
                        return t.updateCircularToggleDirection()
                    })), this
                }, e.updateAlignPos = function () {
                    var t = this._align,
                        e = "object" == typeof t ? t.camera : t;
                    return this._alignPos = FM(e, this.size), this
                }, e.updateAnchors = function () {
                    return this._anchors = this._mode.getAnchors(), this
                }, e.updateAdaptiveHeight = function () {
                    var t = UM(this._flicking),
                        e = t.control.activePanel;
                    t.horizontal && t.adaptive && e && t.viewport.setSize({
                        height: e.height
                    })
                }, e.updateOffset = function () {
                    var t = UM(this._flicking),
                        e = this._position,
                        n = t.panels.filter((function (t) {
                            return !t.rendered
                        }));
                    return this._offset = n.filter((function (t) {
                        return t.position + t.offset < e
                    })).reduce((function (t, e) {
                        return t + e.sizeIncludingMargin
                    }), 0), this._circularOffset = this._mode.getCircularOffset(), this.applyTransform(), this
                }, e.updatePanelOrder = function () {
                    var t = UM(this._flicking);
                    if (!t.horizontal) return this;
                    var e = this._el,
                        n = KM(e).direction;
                    return n !== this._panelOrder && (this._panelOrder = n === DM ? DM : IM, t.initialized && t.control.controller.updateDirection()), this
                }, e.resetNeedPanelHistory = function () {
                    return this._needPanelTriggered = {
                        prev: !1,
                        next: !1
                    }, this
                }, e.applyTransform = function () {
                    var t = this._el,
                        e = UM(this._flicking);
                    if (e.renderer.rendering || !e.initialized) return this;
                    var n = this._position - this._alignPos - this._offset + this._circularOffset;
                    return t.style[this._transform] = e.horizontal ? "translate(" + (this._panelOrder === DM ? n : -n) + "px)" : "translate(0, " + -n + "px)", this
                }, e._resetInternalValues = function () {
                    this._position = 0, this._alignPos = 0, this._offset = 0, this._circularOffset = 0, this._circularEnabled = !1, this._range = {
                        min: 0,
                        max: 0
                    }, this._visiblePanels = [], this._anchors = [], this._needPanelTriggered = {
                        prev: !1,
                        next: !1
                    }
                }, e._refreshVisiblePanels = function () {
                    var t = this,
                        e = UM(this._flicking),
                        n = e.renderer.panels.filter((function (e) {
                            return t.canSee(e)
                        })),
                        i = this._visiblePanels;
                    this._visiblePanels = n;
                    var r = n.filter((function (t) {
                            return !jM(i, t)
                        })),
                        s = i.filter((function (t) {
                            return !jM(n, t)
                        }));
                    (r.length > 0 || s.length > 0) && e.renderer.render().then((function () {
                        e.trigger(new ob(xM, {
                            added: r,
                            removed: s,
                            visiblePanels: n
                        }))
                    }))
                }, e._checkNeedPanel = function () {
                    var t = this._needPanelTriggered;
                    if (!t.prev || !t.next) {
                        var e = UM(this._flicking),
                            n = e.renderer.panels;
                        if (n.length <= 0) return t.prev || (e.trigger(new ob(yM, {
                            direction: TM
                        })), t.prev = !0), void(t.next || (e.trigger(new ob(yM, {
                            direction: AM
                        })), t.next = !0));
                        var i = this._position,
                            r = this.size,
                            s = this._range,
                            o = e.needPanelThreshold,
                            a = i - this._alignPos,
                            l = a + r,
                            c = n[0],
                            u = n[n.length - 1];
                        if (!t.prev)(a <= c.range.min + o || i <= s.min + o) && (e.trigger(new ob(yM, {
                            direction: TM
                        })), t.prev = !0);
                        if (!t.next)(l >= u.range.max - o || i >= s.max - o) && (e.trigger(new ob(yM, {
                            direction: AM
                        })), t.next = !0)
                    }
                }, e._checkReachEnd = function (t, e) {
                    var n = UM(this._flicking),
                        i = this._range,
                        r = t > i.min && t < i.max,
                        s = e > i.min && e < i.max;
                    if (r && !s) {
                        var o = e <= i.min ? TM : AM;
                        n.trigger(new ob(bM, {
                            direction: o
                        }))
                    }
                }, e._updateMode = function () {
                    var t = UM(this._flicking);
                    if (t.circular) {
                        var e = new Aw(t),
                            n = e.checkAvailability();
                        if (n) this._mode = e;
                        else {
                            var i = t.circularFallback;
                            this._mode = i === OM ? new Pw(t) : new Tw(t)
                        }
                        this._circularEnabled = n
                    } else this._mode = t.bound ? new Pw(t) : new Tw(t), this._circularEnabled = !1
                }, e._togglePanels = function (t, e) {
                    return e !== t && UM(this._flicking).renderer.panels.map((function (n) {
                        return n.toggle(t, e)
                    })).some((function (t) {
                        return t
                    }))
                }, t
            }(),
            Rw = function () {
                function t(t) {
                    var e = t.align,
                        n = void 0 === e ? MM : e,
                        i = t.strategy;
                    this._flicking = null, this._panels = [], this._rendering = !1, this._align = n, this._strategy = i
                }
                var e = t.prototype;
                return Object.defineProperty(e, "panels", {
                    get: function () {
                        return this._panels
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "rendering", {
                    get: function () {
                        return this._rendering
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "panelCount", {
                    get: function () {
                        return this._panels.length
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "strategy", {
                    get: function () {
                        return this._strategy
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "align", {
                    get: function () {
                        return this._align
                    },
                    set: function (t) {
                        this._align = t;
                        var e = HM(t);
                        this._panels.forEach((function (t) {
                            t.align = e
                        }))
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.init = function (t) {
                    return this._flicking = t, this._collectPanels(), this
                }, e.destroy = function () {
                    this._flicking = null, this._panels = []
                }, e.getPanel = function (t) {
                    return this._panels[t] || null
                }, e.forceRenderAllPanels = function () {
                    return this._panels.forEach((function (t) {
                        return t.markForShow()
                    })), Promise.resolve()
                }, e.updatePanelSize = function () {
                    var t = UM(this._flicking),
                        e = this._panels;
                    if (e.length <= 0) return this;
                    if (t.panelsPerView > 0) {
                        var n = e[0];
                        n.resize(), this._updatePanelSizeByGrid(n, e)
                    } else t.panels.forEach((function (t) {
                        return t.resize()
                    }));
                    return this
                }, e.batchInsert = function () {
                    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
                    var n = this.batchInsertDefer.apply(this, OE(t));
                    return n.length <= 0 ? [] : (this.updateAfterPanelChange(n, []), n)
                }, e.batchInsertDefer = function () {
                    for (var t = this, e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                    var i = this._panels,
                        r = UM(this._flicking),
                        s = i[0],
                        o = HM(this._align);
                    return e.reduce((function (e, n) {
                        var a, l = WM(n.index, i.length),
                            c = i.slice(l),
                            u = n.elements.map((function (e, n) {
                                return t._createPanel(e, {
                                    index: l + n,
                                    align: o,
                                    flicking: r
                                })
                            }));
                        if (i.splice.apply(i, OE([l, 0], u)), n.hasDOMInElements && t._insertPanelElements(u, null !== (a = c[0]) && void 0 !== a ? a : null), r.panelsPerView > 0) {
                            var h = s || u[0].resize();
                            t._updatePanelSizeByGrid(h, u)
                        } else u.forEach((function (t) {
                            return t.resize()
                        }));
                        return c.forEach((function (t) {
                            t.increaseIndex(u.length), t.updatePosition()
                        })), OE(e, u)
                    }), [])
                }, e.batchRemove = function () {
                    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
                    var n = this.batchRemoveDefer.apply(this, OE(t));
                    return n.length <= 0 ? [] : (this.updateAfterPanelChange([], n), n)
                }, e.batchRemoveDefer = function () {
                    for (var t = this, e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                    var i = this._panels,
                        r = UM(this._flicking).control,
                        s = r.activePanel;
                    return e.reduce((function (e, n) {
                        var o = n.index,
                            a = n.deleteCount,
                            l = WM(o, i.length),
                            c = i.slice(l + a),
                            u = i.splice(l, a);
                        return u.length <= 0 ? [] : (c.forEach((function (t) {
                            t.decreaseIndex(u.length), t.updatePosition()
                        })), n.hasDOMInElements && t._removePanelElements(u), u.forEach((function (t) {
                            return t.destroy()
                        })), jM(u, s) && r.resetActive(), OE(e, u))
                    }), [])
                }, e.updateAfterPanelChange = function (t, e) {
                    var n, i = UM(this._flicking),
                        r = i.camera,
                        s = i.control,
                        o = this._panels,
                        a = s.activePanel;
                    if (this._updateCameraAndControl(), this.render(), !i.animating)
                        if (!a || a.removed)
                            if (o.length <= 0) r.lookAt(0);
                            else {
                                var l = null !== (n = null == a ? void 0 : a.index) && void 0 !== n ? n : 0;
                                l > o.length - 1 && (l = o.length - 1), s.moveToPanel(o[l], {
                                    duration: 0
                                }).catch((function () {}))
                            }
                    else s.moveToPanel(a, {
                        duration: 0
                    }).catch((function () {}));
                    i.camera.updateOffset(), (t.length > 0 || e.length > 0) && (i.trigger(new ob(SM, {
                        added: t,
                        removed: e
                    })), this.checkPanelContentsReady(OE(t, e)))
                }, e.checkPanelContentsReady = function (t) {
                    var e = this,
                        n = UM(this._flicking),
                        i = n.resizeOnContentsReady,
                        r = this._panels;
                    if (i && !n.virtualEnabled) {
                        if (!((t = t.filter((function (t) {
                                return function (t) {
                                    return t.element && !!t.element.querySelector("img, video")
                                }(t)
                            }))).length <= 0)) {
                            var s = new ME;
                            t.forEach((function (t) {
                                t.loading = !0
                            })), s.on("readyElement", (function (i) {
                                if (e._flicking) {
                                    var o = t[i.index],
                                        a = n.camera,
                                        l = n.control,
                                        c = l.activePanel ? a.getProgressInPanel(l.activePanel) : 0;
                                    o.loading = !1, o.resize(), r.slice(o.index + 1).forEach((function (t) {
                                        return t.updatePosition()
                                    })), n.initialized && (a.updateRange(), a.updateOffset(), a.updateAnchors(), l.animating || (l.updatePosition(c), l.updateInput()))
                                } else s.destroy()
                            })), s.on("preReady", (function (t) {
                                e._flicking && e.render(), t.readyCount === t.totalCount && s.destroy()
                            })), s.on("ready", (function () {
                                e._flicking && e.render(), s.destroy()
                            })), s.check(t.map((function (t) {
                                return t.element
                            })))
                        }
                    }
                }, e._updateCameraAndControl = function () {
                    var t = UM(this._flicking),
                        e = t.camera,
                        n = t.control;
                    e.updateRange(), e.updateOffset(), e.updateAnchors(), e.resetNeedPanelHistory(), n.updateInput()
                }, e._showOnlyVisiblePanels = function (t) {
                    var e = t.renderer.panels,
                        n = t.camera.visiblePanels.reduce((function (t, e) {
                            return t[e.index] = !0, t
                        }), {});
                    e.forEach((function (e) {
                        e.index in n || e.loading ? e.markForShow() : t.holding || e.markForHide()
                    }))
                }, e._updatePanelSizeByGrid = function (t, e) {
                    var n = UM(this._flicking),
                        i = n.panelsPerView;
                    if (i <= 0) throw new nw(JE("panelsPerView", i), FE);
                    if (!(e.length <= 0)) {
                        var r = (n.camera.size - (t.margin.prev + t.margin.next) * (i - 1)) / i,
                            s = n.horizontal ? {
                                width: r
                            } : {
                                height: r
                            },
                            o = AE({
                                size: r,
                                margin: t.margin
                            }, !n.horizontal && {
                                height: t.height
                            });
                        n.noPanelStyleOverride || this._strategy.updatePanelSizes(n, s), n.panels.forEach((function (t) {
                            return t.resize(o)
                        }))
                    }
                }, e._removeAllChildsFromCamera = function () {
                    for (var t = UM(this._flicking).camera.element; t.firstChild;) t.removeChild(t.firstChild)
                }, e._insertPanelElements = function (t, e) {
                    void 0 === e && (e = null);
                    var n = UM(this._flicking).camera.element,
                        i = (null == e ? void 0 : e.element) || null,
                        r = document.createDocumentFragment();
                    t.forEach((function (t) {
                        return r.appendChild(t.element)
                    })), n.insertBefore(r, i)
                }, e._removePanelElements = function (t) {
                    var e = UM(this._flicking).camera.element;
                    t.forEach((function (t) {
                        e.removeChild(t.element)
                    }))
                }, e._afterRender = function () {
                    UM(this._flicking).camera.applyTransform()
                }, t
            }(),
            Lw = function (t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                TE(e, t);
                var n = e.prototype;
                return n.render = function () {
                    return PE(this, void 0, void 0, (function () {
                        var t, e;
                        return CE(this, (function (n) {
                            return t = UM(this._flicking), (e = this._strategy).updateRenderingPanels(t), e.renderPanels(t), this._resetPanelElementOrder(), this._afterRender(), [2]
                        }))
                    }))
                }, n._collectPanels = function () {
                    var t = UM(this._flicking),
                        e = t.camera;
                    this._removeAllTextNodes(), this._panels = this._strategy.collectPanels(t, e.children)
                }, n._createPanel = function (t, e) {
                    return this._strategy.createPanel(t, e)
                }, n._resetPanelElementOrder = function () {
                    var t = UM(this._flicking),
                        e = t.camera.element,
                        n = this._strategy.getRenderingElementsByOrder(t).reverse();
                    n.forEach((function (t, i) {
                        var r = n[i - 1] ? n[i - 1] : null;
                        t.nextElementSibling !== r && e.insertBefore(t, r)
                    }))
                }, n._removeAllTextNodes = function () {
                    var t = UM(this._flicking).camera.element;
                    kM(t.childNodes).forEach((function (e) {
                        e.nodeType === Node.TEXT_NODE && t.removeChild(e)
                    }))
                }, e
            }(Rw),
            Ow = function () {
                function t(t) {
                    var e = t.index,
                        n = t.align,
                        i = t.flicking,
                        r = t.elementProvider;
                    this._index = e, this._flicking = i, this._elProvider = r, this._align = n, this._removed = !1, this._rendered = !0, this._loading = !1, this._resetInternalStates()
                }
                var e = t.prototype;
                return Object.defineProperty(e, "element", {
                    get: function () {
                        return this._elProvider.element
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "elementProvider", {
                    get: function () {
                        return this._elProvider
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "index", {
                    get: function () {
                        return this._index
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "position", {
                    get: function () {
                        return this._pos + this._alignPos
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "size", {
                    get: function () {
                        return this._size
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "sizeIncludingMargin", {
                    get: function () {
                        return this._size + this._margin.prev + this._margin.next
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "height", {
                    get: function () {
                        return this._height
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "margin", {
                    get: function () {
                        return this._margin
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "alignPosition", {
                    get: function () {
                        return this._alignPos
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "removed", {
                    get: function () {
                        return this._removed
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "rendered", {
                    get: function () {
                        return this._rendered
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "loading", {
                    get: function () {
                        return this._loading
                    },
                    set: function (t) {
                        this._loading = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "range", {
                    get: function () {
                        return {
                            min: this._pos,
                            max: this._pos + this._size
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "toggled", {
                    get: function () {
                        return this._toggled
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "toggleDirection", {
                    get: function () {
                        return this._toggleDirection
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "offset", {
                    get: function () {
                        var t = this._toggleDirection,
                            e = this._flicking.camera.rangeDiff;
                        return t !== PM && this._toggled ? t === TM ? -e : e : 0
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "progress", {
                    get: function () {
                        var t = this._flicking;
                        return this.index - t.camera.progress
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "outsetProgress", {
                    get: function () {
                        var t = this.position + this.offset,
                            e = this._alignPos,
                            n = this._flicking.camera,
                            i = n.position;
                        if (i === t) return 0;
                        if (i < t) {
                            var r = t + (n.size - n.alignPosition) + e;
                            return -YM(i, t, r)
                        }
                        var s = t - (n.alignPosition + this._size - e);
                        return 1 - YM(i, s, t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "visibleRatio", {
                    get: function () {
                        var t = this.range,
                            e = this._size,
                            n = this.offset,
                            i = this._flicking.camera.visibleRange,
                            r = t.min + n,
                            s = t.max + n;
                        if (s <= i.min || r >= i.max) return 0;
                        var o = e;
                        return i.min > r && (o -= i.min - r), i.max < s && (o -= s - i.max), o / e
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "align", {
                    get: function () {
                        return this._align
                    },
                    set: function (t) {
                        this._align = t, this._updateAlignPos()
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.markForShow = function () {
                    this._rendered = !0, this._elProvider.show(this._flicking)
                }, e.markForHide = function () {
                    this._rendered = !1, this._elProvider.hide(this._flicking)
                }, e.resize = function (t) {
                    var e, n = this.element,
                        i = this._flicking,
                        r = i.horizontal,
                        s = i.useFractionalSize;
                    if (t) this._size = t.size, this._margin = AE({}, t.margin), this._height = null !== (e = t.height) && void 0 !== e ? e : tw({
                        el: n,
                        horizontal: !1,
                        useFractionalSize: s,
                        useOffset: !0,
                        style: KM(n)
                    });
                    else {
                        var o = KM(n);
                        this._size = tw({
                            el: n,
                            horizontal: r,
                            useFractionalSize: s,
                            useOffset: !0,
                            style: o
                        }), this._margin = r ? {
                            prev: parseFloat(o.marginLeft || "0"),
                            next: parseFloat(o.marginRight || "0")
                        } : {
                            prev: parseFloat(o.marginTop || "0"),
                            next: parseFloat(o.marginBottom || "0")
                        }, this._height = r ? tw({
                            el: n,
                            horizontal: !1,
                            useFractionalSize: s,
                            useOffset: !0,
                            style: o
                        }) : this._size
                    }
                    return this.updatePosition(), this._updateAlignPos(), this
                }, e.setSize = function (t) {
                    return ZM(this.element, t), this
                }, e.contains = function (t) {
                    var e;
                    return !!(null === (e = this.element) || void 0 === e ? void 0 : e.contains(t))
                }, e.destroy = function () {
                    this._resetInternalStates(), this._removed = !0
                }, e.includePosition = function (t, e) {
                    return void 0 === e && (e = !1), this.includeRange(t, t, e)
                }, e.includeRange = function (t, e, n) {
                    void 0 === n && (n = !1);
                    var i = this._margin,
                        r = this.range;
                    return n && (r.min -= i.prev, r.max += i.next), e >= r.min && t <= r.max
                }, e.isVisibleOnRange = function (t, e) {
                    var n = this.range;
                    return e > n.min && t < n.max
                }, e.focus = function (t) {
                    return this._flicking.moveTo(this._index, t)
                }, e.prev = function () {
                    var t = this._index,
                        e = this._flicking,
                        n = e.renderer,
                        i = n.panelCount;
                    return 1 === i ? null : e.circularEnabled ? n.getPanel(0 === t ? i - 1 : t - 1) : n.getPanel(t - 1)
                }, e.next = function () {
                    var t = this._index,
                        e = this._flicking,
                        n = e.renderer,
                        i = n.panelCount;
                    return 1 === i ? null : e.circularEnabled ? n.getPanel(t === i - 1 ? 0 : t + 1) : n.getPanel(t + 1)
                }, e.increaseIndex = function (t) {
                    return this._index += Math.max(t, 0), this
                }, e.decreaseIndex = function (t) {
                    return this._index -= Math.max(t, 0), this
                }, e.updatePosition = function () {
                    var t = this._flicking.renderer.panels[this._index - 1];
                    return this._pos = t ? t.range.max + t.margin.next + this._margin.prev : this._margin.prev, this
                }, e.toggle = function (t, e) {
                    var n = this._toggleDirection,
                        i = this._togglePosition;
                    if (n === PM || e === t) return !1;
                    var r = this._toggled;
                    return e > t ? i >= t && i <= e && (this._toggled = n === AM) : i <= t && i >= e && (this._toggled = n !== AM), r !== this._toggled
                }, e.updateCircularToggleDirection = function () {
                    var t = this._flicking;
                    if (!t.circularEnabled) return this._toggleDirection = PM, this._togglePosition = 0, this._toggled = !1, this;
                    var e = t.camera,
                        n = e.range,
                        i = e.alignPosition,
                        r = e.visibleRange,
                        s = r.max - r.min,
                        o = n.min - i,
                        a = n.max - i + s,
                        l = this.includeRange(a - s, a, !1),
                        c = this.includeRange(o, o + s, !1);
                    return this._toggled = !1, l ? (this._toggleDirection = TM, this._togglePosition = this.range.max + n.min - n.max + i, this.toggle(1 / 0, e.position)) : c ? (this._toggleDirection = AM, this._togglePosition = this.range.min + n.max - s + i, this.toggle(-1 / 0, e.position)) : (this._toggleDirection = PM, this._togglePosition = 0), this
                }, e._updateAlignPos = function () {
                    this._alignPos = FM(this._align, this._size)
                }, e._resetInternalStates = function () {
                    this._size = 0, this._pos = 0, this._margin = {
                        prev: 0,
                        next: 0
                    }, this._height = 0, this._alignPos = 0, this._toggled = !1, this._togglePosition = 0, this._toggleDirection = PM
                }, t
            }(),
            Iw = function () {
                function t(t) {
                    var e = t.providerCtor;
                    this._providerCtor = e
                }
                var e = t.prototype;
                return e.renderPanels = function () {}, e.getRenderingIndexesByOrder = function (t) {
                    var e = t.renderer.panels.filter((function (t) {
                            return t.rendered
                        })),
                        n = e.filter((function (t) {
                            return t.toggled && t.toggleDirection === TM
                        })),
                        i = e.filter((function (t) {
                            return t.toggled && t.toggleDirection === AM
                        }));
                    return OE(n, e.filter((function (t) {
                        return !t.toggled
                    })), i).map((function (t) {
                        return t.index
                    }))
                }, e.getRenderingElementsByOrder = function (t) {
                    var e = t.panels;
                    return this.getRenderingIndexesByOrder(t).map((function (t) {
                        return e[t].element
                    }))
                }, e.updateRenderingPanels = function (t) {
                    t.renderOnlyVisible ? this._showOnlyVisiblePanels(t) : t.panels.forEach((function (t) {
                        return t.markForShow()
                    }))
                }, e.collectPanels = function (t, e) {
                    var n = this,
                        i = HM(t.renderer.align);
                    return e.map((function (e, r) {
                        return new Ow({
                            index: r,
                            elementProvider: new n._providerCtor(e),
                            align: i,
                            flicking: t
                        })
                    }))
                }, e.createPanel = function (t, e) {
                    return new Ow(AE(AE({}, e), {
                        elementProvider: new this._providerCtor(t)
                    }))
                }, e.updatePanelSizes = function (t, e) {
                    t.panels.forEach((function (t) {
                        return t.setSize(e)
                    }))
                }, e._showOnlyVisiblePanels = function (t) {
                    var e = t.renderer.panels,
                        n = t.camera,
                        i = n.visiblePanels.reduce((function (t, e) {
                            return t[e.index] = !0, t
                        }), {});
                    e.forEach((function (e) {
                        e.index in i || e.loading ? e.markForShow() : t.holding || e.markForHide()
                    })), n.updateOffset()
                }, t
            }(),
            Dw = function (t) {
                function e(e) {
                    var n = t.call(this, e) || this;
                    return e.elementProvider.init(n), n._elProvider = e.elementProvider, n._cachedInnerHTML = null, n
                }
                TE(e, t);
                var n = e.prototype;
                return Object.defineProperty(n, "element", {
                    get: function () {
                        return this._elProvider.element
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "cachedInnerHTML", {
                    get: function () {
                        return this._cachedInnerHTML
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "elementIndex", {
                    get: function () {
                        var t = this._flicking,
                            e = t.panelsPerView + 1,
                            n = t.panelCount,
                            i = this._index;
                        return this._toggled && (i = this._toggleDirection === AM ? i + n : i - n), $M(i, e)
                    },
                    enumerable: !1,
                    configurable: !0
                }), n.cacheRenderResult = function (t) {
                    this._cachedInnerHTML = t
                }, n.uncacheRenderResult = function () {
                    this._cachedInnerHTML = null
                }, n.render = function () {
                    var t = this._flicking.virtual,
                        e = t.renderPanel,
                        n = t.cache,
                        i = this._elProvider.element,
                        r = this._cachedInnerHTML || e(this, this._index);
                    r !== i.innerHTML && (i.innerHTML = r, n && this.cacheRenderResult(r))
                }, n.increaseIndex = function (e) {
                    return this.uncacheRenderResult(), t.prototype.increaseIndex.call(this, e)
                }, n.decreaseIndex = function (e) {
                    return this.uncacheRenderResult(), t.prototype.decreaseIndex.call(this, e)
                }, e
            }(Ow),
            Nw = function () {
                function t() {}
                var e = t.prototype;
                return e.renderPanels = function (t) {
                    var e = t.virtual,
                        n = t.visiblePanels,
                        i = QM(t.panelsPerView + 1);
                    n.forEach((function (t) {
                        var n = t.elementIndex;
                        t.render(), e.show(n), i[n] = -1
                    })), i.filter((function (t) {
                        return t >= 0
                    })).forEach((function (t) {
                        e.hide(t)
                    }))
                }, e.getRenderingIndexesByOrder = function (t) {
                    var e = t.virtual,
                        n = OE(t.visiblePanels).filter((function (t) {
                            return t.rendered
                        })).sort((function (t, e) {
                            return t.position + t.offset - (e.position + e.offset)
                        }));
                    return n.length <= 0 ? e.elements.map((function (t, e) {
                        return e
                    })) : OE(n.map((function (t) {
                        return t.elementIndex
                    })), e.elements.map((function (t, e) {
                        return AE(AE({}, t), {
                            idx: e
                        })
                    })).filter((function (t) {
                        return !t.visible
                    })).map((function (t) {
                        return t.idx
                    })))
                }, e.getRenderingElementsByOrder = function (t) {
                    var e = t.virtual.elements;
                    return this.getRenderingIndexesByOrder(t).map((function (t) {
                        return e[t].nativeElement
                    }))
                }, e.updateRenderingPanels = function (t) {
                    var e = t.renderer.panels,
                        n = t.camera,
                        i = n.visiblePanels.reduce((function (t, e) {
                            return t[e.index] = !0, t
                        }), {});
                    e.forEach((function (t) {
                        t.index in i || t.loading ? t.markForShow() : t.markForHide()
                    })), n.updateOffset()
                }, e.collectPanels = function (t) {
                    var e = HM(t.renderer.align);
                    return QM(t.virtual.initialPanelCount).map((function (n) {
                        return new Dw({
                            index: n,
                            elementProvider: new ow(t),
                            align: e,
                            flicking: t
                        })
                    }))
                }, e.createPanel = function (t, e) {
                    return new Dw(AE(AE({}, e), {
                        elementProvider: new ow(e.flicking)
                    }))
                }, e.updatePanelSizes = function (t, e) {
                    t.virtual.elements.forEach((function (t) {
                        ZM(t.nativeElement, e)
                    })), t.panels.forEach((function (t) {
                        return t.setSize(e)
                    }))
                }, t
            }(),
            Uw = function (t) {
                function e(e, n) {
                    var i = void 0 === n ? {} : n,
                        r = i.align,
                        s = void 0 === r ? MM : r,
                        o = i.defaultIndex,
                        a = void 0 === o ? 0 : o,
                        l = i.horizontal,
                        c = void 0 === l || l,
                        u = i.circular,
                        h = void 0 !== u && u,
                        d = i.circularFallback,
                        f = void 0 === d ? LM : d,
                        p = i.bound,
                        m = void 0 !== p && p,
                        g = i.adaptive,
                        v = void 0 !== g && g,
                        _ = i.panelsPerView,
                        y = void 0 === _ ? -1 : _,
                        x = i.noPanelStyleOverride,
                        b = void 0 !== x && x,
                        S = i.resizeOnContentsReady,
                        E = void 0 !== S && S,
                        M = i.nested,
                        w = void 0 !== M && M,
                        T = i.needPanelThreshold,
                        A = void 0 === T ? 0 : T,
                        P = i.preventEventsBeforeInit,
                        C = void 0 === P || P,
                        R = i.deceleration,
                        L = void 0 === R ? .0075 : R,
                        O = i.duration,
                        I = void 0 === O ? 500 : O,
                        D = i.easing,
                        N = void 0 === D ? function (t) {
                            return 1 - Math.pow(1 - t, 3)
                        } : D,
                        U = i.inputType,
                        k = void 0 === U ? ["mouse", "touch"] : U,
                        F = i.moveType,
                        z = void 0 === F ? "snap" : F,
                        B = i.threshold,
                        H = void 0 === B ? 40 : B,
                        V = i.interruptable,
                        G = void 0 === V || V,
                        W = i.bounce,
                        j = void 0 === W ? "20%" : W,
                        X = i.iOSEdgeSwipeThreshold,
                        q = void 0 === X ? 30 : X,
                        Y = i.preventClickOnDrag,
                        K = void 0 === Y || Y,
                        Z = i.preventDefaultOnDrag,
                        J = void 0 !== Z && Z,
                        $ = i.disableOnInit,
                        Q = void 0 !== $ && $,
                        tt = i.changeOnHold,
                        et = void 0 !== tt && tt,
                        nt = i.renderOnlyVisible,
                        it = void 0 !== nt && nt,
                        rt = i.virtual,
                        st = void 0 === rt ? null : rt,
                        ot = i.autoInit,
                        at = void 0 === ot || ot,
                        lt = i.autoResize,
                        ct = void 0 === lt || lt,
                        ut = i.useResizeObserver,
                        ht = void 0 === ut || ut,
                        dt = i.resizeDebounce,
                        ft = void 0 === dt ? 0 : dt,
                        pt = i.maxResizeDebounce,
                        mt = void 0 === pt ? 100 : pt,
                        gt = i.useFractionalSize,
                        vt = void 0 !== gt && gt,
                        _t = i.externalRenderer,
                        yt = void 0 === _t ? null : _t,
                        xt = i.renderExternal,
                        bt = void 0 === xt ? null : xt,
                        St = t.call(this) || this;
                    return St._initialized = !1, St._plugins = [], St._align = s, St._defaultIndex = a, St._horizontal = c, St._circular = h, St._circularFallback = f, St._bound = m, St._adaptive = v, St._panelsPerView = y, St._noPanelStyleOverride = b, St._resizeOnContentsReady = E, St._nested = w, St._virtual = st, St._needPanelThreshold = A, St._preventEventsBeforeInit = C, St._deceleration = L, St._duration = I, St._easing = N, St._inputType = k, St._moveType = z, St._threshold = H, St._interruptable = G, St._bounce = j, St._iOSEdgeSwipeThreshold = q, St._preventClickOnDrag = K, St._preventDefaultOnDrag = J, St._disableOnInit = Q, St._changeOnHold = et, St._renderOnlyVisible = it, St._autoInit = at, St._autoResize = ct, St._useResizeObserver = ht, St._resizeDebounce = ft, St._maxResizeDebounce = mt, St._useFractionalSize = vt, St._externalRenderer = yt, St._renderExternal = bt, St._viewport = new iw(St, function (t, e) {
                        var n = null;
                        if (XM(t)) {
                            var i = (e || document).querySelector(t);
                            if (!i) throw new nw(YE(t), NE);
                            n = i
                        } else t && t.nodeType === Node.ELEMENT_NODE && (n = t);
                        if (!n) throw new nw(qE(t, ["HTMLElement", "string"]), DE);
                        return n
                    }(e)), St._autoResizer = new rw(St), St._renderer = St._createRenderer(), St._camera = St._createCamera(), St._control = St._createControl(), St._virtualManager = new aw(St, st), St._autoInit && St.init(), St
                }
                TE(e, t);
                var n = e.prototype;
                return Object.defineProperty(n, "control", {
                    get: function () {
                        return this._control
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "camera", {
                    get: function () {
                        return this._camera
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "renderer", {
                    get: function () {
                        return this._renderer
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "viewport", {
                    get: function () {
                        return this._viewport
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "initialized", {
                    get: function () {
                        return this._initialized
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "circularEnabled", {
                    get: function () {
                        return this._camera.circularEnabled
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "virtualEnabled", {
                    get: function () {
                        return this._panelsPerView > 0 && null != this._virtual
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "index", {
                    get: function () {
                        return this._control.activeIndex
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "element", {
                    get: function () {
                        return this._viewport.element
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "currentPanel", {
                    get: function () {
                        return this._control.activePanel
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "panels", {
                    get: function () {
                        return this._renderer.panels
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "panelCount", {
                    get: function () {
                        return this._renderer.panelCount
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "visiblePanels", {
                    get: function () {
                        return this._camera.visiblePanels
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "animating", {
                    get: function () {
                        return this._control.animating
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "holding", {
                    get: function () {
                        return this._control.holding
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "activePlugins", {
                    get: function () {
                        return this._plugins
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "align", {
                    get: function () {
                        return this._align
                    },
                    set: function (t) {
                        this._align = t, this._renderer.align = t, this._camera.align = t, this.resize()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "defaultIndex", {
                    get: function () {
                        return this._defaultIndex
                    },
                    set: function (t) {
                        this._defaultIndex = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "horizontal", {
                    get: function () {
                        return this._horizontal
                    },
                    set: function (t) {
                        this._horizontal = t, this._control.controller.updateDirection(), this.resize()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "circular", {
                    get: function () {
                        return this._circular
                    },
                    set: function (t) {
                        this._circular = t, this.resize()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "circularFallback", {
                    get: function () {
                        return this._circularFallback
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "bound", {
                    get: function () {
                        return this._bound
                    },
                    set: function (t) {
                        this._bound = t, this.resize()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "adaptive", {
                    get: function () {
                        return this._adaptive
                    },
                    set: function (t) {
                        this._adaptive = t, this.resize()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "panelsPerView", {
                    get: function () {
                        return this._panelsPerView
                    },
                    set: function (t) {
                        this._panelsPerView = t, this.resize()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "noPanelStyleOverride", {
                    get: function () {
                        return this._noPanelStyleOverride
                    },
                    set: function (t) {
                        this._noPanelStyleOverride = t, this.resize()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "resizeOnContentsReady", {
                    get: function () {
                        return this._resizeOnContentsReady
                    },
                    set: function (t) {
                        this._resizeOnContentsReady = t, t && this._renderer.checkPanelContentsReady(this._renderer.panels)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "nested", {
                    get: function () {
                        return this._nested
                    },
                    set: function (t) {
                        this._nested = t;
                        var e = this._control.controller.axes;
                        e && (e.options.nested = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "needPanelThreshold", {
                    get: function () {
                        return this._needPanelThreshold
                    },
                    set: function (t) {
                        this._needPanelThreshold = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "preventEventsBeforeInit", {
                    get: function () {
                        return this._preventEventsBeforeInit
                    },
                    set: function (t) {
                        this._preventEventsBeforeInit = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "deceleration", {
                    get: function () {
                        return this._deceleration
                    },
                    set: function (t) {
                        this._deceleration = t;
                        var e = this._control.controller.axes;
                        e && (e.options.deceleration = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "easing", {
                    get: function () {
                        return this._easing
                    },
                    set: function (t) {
                        this._easing = t;
                        var e = this._control.controller.axes;
                        e && (e.options.easing = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "duration", {
                    get: function () {
                        return this._duration
                    },
                    set: function (t) {
                        this._duration = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "inputType", {
                    get: function () {
                        return this._inputType
                    },
                    set: function (t) {
                        this._inputType = t;
                        var e = this._control.controller.panInput;
                        e && (e.options.inputType = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "moveType", {
                    get: function () {
                        return this._moveType
                    },
                    set: function (t) {
                        this._moveType = t;
                        var e = this._control,
                            n = this._createControl(),
                            i = e.activePanel;
                        n.copy(e);
                        var r = i ? this._camera.getProgressInPanel(i) : 0;
                        this._control = n, this._control.updatePosition(r), this._control.updateInput()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "threshold", {
                    get: function () {
                        return this._threshold
                    },
                    set: function (t) {
                        this._threshold = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "interruptable", {
                    get: function () {
                        return this._interruptable
                    },
                    set: function (t) {
                        this._interruptable = t;
                        var e = this._control.controller.axes;
                        e && (e.options.interruptable = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "bounce", {
                    get: function () {
                        return this._bounce
                    },
                    set: function (t) {
                        this._bounce = t, this._control.updateInput()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "iOSEdgeSwipeThreshold", {
                    get: function () {
                        return this._iOSEdgeSwipeThreshold
                    },
                    set: function (t) {
                        this._iOSEdgeSwipeThreshold = t;
                        var e = this._control.controller.panInput;
                        e && (e.options.iOSEdgeSwipeThreshold = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "preventClickOnDrag", {
                    get: function () {
                        return this._preventClickOnDrag
                    },
                    set: function (t) {
                        if (t !== this._preventClickOnDrag) {
                            var e = this._control.controller;
                            t ? e.addPreventClickHandler() : e.removePreventClickHandler(), this._preventClickOnDrag = t
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "preventDefaultOnDrag", {
                    get: function () {
                        return this._preventDefaultOnDrag
                    },
                    set: function (t) {
                        this._preventDefaultOnDrag = t;
                        var e = this._control.controller.panInput;
                        e && (e.options.preventDefaultOnDrag = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "disableOnInit", {
                    get: function () {
                        return this._disableOnInit
                    },
                    set: function (t) {
                        this._disableOnInit = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "changeOnHold", {
                    get: function () {
                        return this._changeOnHold
                    },
                    set: function (t) {
                        this._changeOnHold = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "renderOnlyVisible", {
                    get: function () {
                        return this._renderOnlyVisible
                    },
                    set: function (t) {
                        this._renderOnlyVisible = t, this._renderer.render()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "virtual", {
                    get: function () {
                        return this._virtualManager
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "autoInit", {
                    get: function () {
                        return this._autoInit
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "autoResize", {
                    get: function () {
                        return this._autoResize
                    },
                    set: function (t) {
                        this._autoResize = t, t ? this._autoResizer.enable() : this._autoResizer.disable()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "useResizeObserver", {
                    get: function () {
                        return this._useResizeObserver
                    },
                    set: function (t) {
                        this._useResizeObserver = t, this._autoResize && this._autoResizer.enable()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "resizeDebounce", {
                    get: function () {
                        return this._resizeDebounce
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "maxResizeDebounce", {
                    get: function () {
                        return this._maxResizeDebounce
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "useFractionalSize", {
                    get: function () {
                        return this._useFractionalSize
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "externalRenderer", {
                    get: function () {
                        return this._externalRenderer
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(n, "renderExternal", {
                    get: function () {
                        return this._renderExternal
                    },
                    enumerable: !1,
                    configurable: !0
                }), n.init = function () {
                    var t = this;
                    if (this._initialized) return Promise.resolve();
                    var e = this._camera,
                        n = this._renderer,
                        i = this._control,
                        r = this._virtualManager,
                        s = this.trigger,
                        o = this._preventEventsBeforeInit;
                    return e.init(), r.init(), n.init(this), i.init(this), o && (this.trigger = function () {
                        return t
                    }), this._initialResize(), this._moveToInitialPanel(), this._autoResize && this._autoResizer.enable(), this._preventClickOnDrag && i.controller.addPreventClickHandler(), this._disableOnInit && this.disableInput(), n.checkPanelContentsReady(n.panels), this._initialized = !0, n.render().then((function () {
                        t._plugins.forEach((function (e) {
                            return e.init(t)
                        })), o && (t.trigger = s), t.trigger(new ob(oM))
                    }))
                }, n.destroy = function () {
                    this.off(), this._autoResizer.disable(), this._control.destroy(), this._camera.destroy(), this._renderer.destroy(), this._plugins.forEach((function (t) {
                        return t.destroy()
                    })), this._initialized = !1
                }, n.prev = function (t) {
                    var e, n, i;
                    return void 0 === t && (t = this._duration), this.moveTo(null !== (i = null === (n = null === (e = this._control.activePanel) || void 0 === e ? void 0 : e.prev()) || void 0 === n ? void 0 : n.index) && void 0 !== i ? i : -1, t, TM)
                }, n.next = function (t) {
                    var e, n, i;
                    return void 0 === t && (t = this._duration), this.moveTo(null !== (i = null === (n = null === (e = this._control.activePanel) || void 0 === e ? void 0 : e.next()) || void 0 === n ? void 0 : n.index) && void 0 !== i ? i : this._renderer.panelCount, t, AM)
                }, n.moveTo = function (t, e, n) {
                    void 0 === e && (e = this._duration), void 0 === n && (n = PM);
                    var i = this._renderer,
                        r = i.panelCount,
                        s = i.getPanel(t);
                    return s ? this._control.animating ? Promise.reject(new nw(iM, WE)) : (this._control.holding && this._control.controller.release(), this._control.moveToPanel(s, {
                        duration: e,
                        direction: n
                    })) : Promise.reject(new nw($E(t, 0, r - 1), zE))
                }, n.updateAnimation = function (t, e, n) {
                    if (this._control.animating) {
                        var i = this._renderer,
                            r = i.panelCount,
                            s = i.getPanel(t);
                        if (!s) throw new nw($E(t, 0, r - 1), zE);
                        this._control.updateAnimation(s, e, n)
                    }
                }, n.stopAnimation = function () {
                    this._control.animating && this._control.stopAnimation()
                }, n.getPanel = function (t) {
                    return this._renderer.getPanel(t)
                }, n.enableInput = function () {
                    return this._control.enable(), this
                }, n.disableInput = function () {
                    return this._control.disable(), this
                }, n.getStatus = function (t) {
                    var e, n, i = void 0 === t ? {} : t,
                        r = i.index,
                        s = void 0 === r || r,
                        o = i.position,
                        a = void 0 === o || o,
                        l = i.includePanelHTML,
                        c = void 0 !== l && l,
                        u = i.visiblePanelsOnly,
                        h = void 0 !== u && u,
                        d = this._camera,
                        f = {
                            panels: (h ? this.visiblePanels : this.panels).map((function (t) {
                                var e = {
                                    index: t.index
                                };
                                return c && (e.html = t.element.outerHTML), e
                            }))
                        };
                    if (s && (f.index = this.index), a) {
                        var p = d.findNearestAnchor(d.position);
                        p && (f.position = {
                            panel: p.panel.index,
                            progressInPanel: d.getProgressInPanel(p.panel)
                        })
                    }
                    if (h) {
                        var m = this.visiblePanels;
                        f.visibleOffset = null !== (n = null === (e = m[0]) || void 0 === e ? void 0 : e.index) && void 0 !== n ? n : 0
                    }
                    return f
                }, n.setStatus = function (t) {
                    var e;
                    if (!this._initialized) throw new nw(sM, XE);
                    var n = t.index,
                        i = t.position,
                        r = t.visibleOffset,
                        s = t.panels,
                        o = this._renderer,
                        a = this._control;
                    if ((null === (e = s[0]) || void 0 === e ? void 0 : e.html) && !this._renderExternal && (o.batchRemove({
                            index: 0,
                            deleteCount: this.panels.length,
                            hasDOMInElements: !0
                        }), o.batchInsert({
                            index: 0,
                            elements: GM(s.map((function (t) {
                                return t.html
                            }))),
                            hasDOMInElements: !0
                        })), null != n) {
                        var l = r ? n - r : n;
                        this.moveTo(l, 0).catch((function () {}))
                    }
                    if (i && this._moveType === CM.FREE_SCROLL) {
                        var c = i.panel,
                            u = i.progressInPanel,
                            h = (l = r ? c - r : c, o.panels[l].range),
                            d = h.min + (h.max - h.min) * u;
                        a.moveToPosition(d, 0).catch((function () {}))
                    }
                }, n.addPlugins = function () {
                    for (var t, e = this, n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
                    return this._initialized && n.forEach((function (t) {
                        return t.init(e)
                    })), (t = this._plugins).push.apply(t, OE(n)), this
                }, n.removePlugins = function () {
                    for (var t = this, e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                    return e.forEach((function (e) {
                        var n = function (t, e) {
                            for (var n = 0; n < t.length; n++)
                                if (e(t[n])) return n;
                            return -1
                        }(t._plugins, (function (t) {
                            return t === e
                        }));
                        n >= 0 && (e.destroy(), t._plugins.splice(n, 1))
                    })), this
                }, n.resize = function () {
                    return PE(this, void 0, void 0, (function () {
                        var t, e, n, i, r, s, o, a, l, c, u;
                        return CE(this, (function (h) {
                            switch (h.label) {
                                case 0:
                                    return t = this._viewport, e = this._renderer, n = this._camera, i = this._control, r = i.activePanel, s = t.width, o = t.height, a = r ? n.getProgressInPanel(r) : 0, this.trigger(new ob(aM, {
                                        width: s,
                                        height: o,
                                        element: t.element
                                    })), t.resize(), [4, e.forceRenderAllPanels()];
                                case 1:
                                    return h.sent(), e.updatePanelSize(), n.updateAlignPos(), n.updateRange(), n.updateAnchors(), n.updateAdaptiveHeight(), n.updatePanelOrder(), n.updateOffset(), [4, e.render()];
                                case 2:
                                    return h.sent(), i.animating || (i.updatePosition(a), i.updateInput()), l = t.width, c = t.height, u = l !== s || c !== o, this.trigger(new ob(lM, {
                                        width: t.width,
                                        height: t.height,
                                        prev: {
                                            width: s,
                                            height: o
                                        },
                                        sizeChanged: u,
                                        element: t.element
                                    })), [2]
                            }
                        }))
                    }))
                }, n.append = function (t) {
                    return this.insert(this._renderer.panelCount, t)
                }, n.prepend = function (t) {
                    return this.insert(0, t)
                }, n.insert = function (t, e) {
                    if (this._renderExternal) throw new nw(rM, jE);
                    return this._renderer.batchInsert({
                        index: t,
                        elements: GM(e),
                        hasDOMInElements: !0
                    })
                }, n.remove = function (t, e) {
                    if (void 0 === e && (e = 1), this._renderExternal) throw new nw(rM, jE);
                    return this._renderer.batchRemove({
                        index: t,
                        deleteCount: e,
                        hasDOMInElements: !0
                    })
                }, n._createControl = function () {
                    var t, e = this._moveType,
                        n = Object.keys(CM).map((function (t) {
                            return CM[t]
                        })),
                        i = Array.isArray(e) ? e[0] : e,
                        r = Array.isArray(e) && null !== (t = e[1]) && void 0 !== t ? t : {};
                    if (!jM(n, i)) throw new nw(JE("moveType", JSON.stringify(e)), FE);
                    switch (i) {
                        case CM.SNAP:
                            return new Sw(r);
                        case CM.FREE_SCROLL:
                            return new Ew(r);
                        case CM.STRICT:
                            return new Mw(r)
                    }
                }, n._createCamera = function () {
                    return this._circular && this._bound, new Cw(this, {
                        align: this._align
                    })
                }, n._createRenderer = function () {
                    var t = this._externalRenderer;
                    return this._virtual && this._panelsPerView, t || (this._renderExternal ? this._createExternalRenderer() : this._createVanillaRenderer())
                }, n._createExternalRenderer = function () {
                    var t = this._renderExternal,
                        e = t.renderer,
                        n = t.rendererOptions;
                    return new e(AE({
                        align: this._align
                    }, n))
                }, n._createVanillaRenderer = function () {
                    var t = this.virtualEnabled;
                    return new Lw({
                        align: this._align,
                        strategy: t ? new Nw : new Iw({
                            providerCtor: sw
                        })
                    })
                }, n._moveToInitialPanel = function () {
                    var t = this._renderer,
                        e = this._control,
                        n = this._camera,
                        i = t.getPanel(this._defaultIndex) || t.getPanel(0);
                    if (i) {
                        var r = n.findNearestAnchor(i.position),
                            s = r && i.index !== r.panel.index ? r.panel : i;
                        if (e.setActive(s, null, !1), !r) throw new nw(QE(s.position), BE);
                        var o = s.position;
                        n.canReach(s) || (o = r.position), n.lookAt(o), e.updateInput(), n.updateOffset()
                    }
                }, n._initialResize = function () {
                    var t = this._viewport,
                        e = this._renderer,
                        n = this._camera,
                        i = this._control;
                    this.trigger(new ob(aM, {
                        width: 0,
                        height: 0,
                        element: t.element
                    })), t.resize(), e.updatePanelSize(), n.updateAlignPos(), n.updateRange(), n.updateAnchors(), n.updateOffset(), i.updateInput();
                    var r = t.width,
                        s = t.height,
                        o = 0 !== r || 0 !== s;
                    this.trigger(new ob(lM, {
                        width: t.width,
                        height: t.height,
                        prev: {
                            width: 0,
                            height: 0
                        },
                        sizeChanged: o,
                        element: t.element
                    }))
                }, e.VERSION = "4.11.2", e
            }(ab);

        function kw(t) {
            return kw = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, kw(t)
        }

        function Fw(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, zw(i.key), i)
            }
        }

        function zw(t) {
            var e = function (t, e) {
                if ("object" != kw(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" != kw(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == kw(e) ? e : String(e)
        }
        var Bw, Hw, Vw, Gw, Ww = !1,
            jw = function () {
                function t(e) {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), hw = this, uw = e, Yi.registerPlugin(ea, tb, Jc), (Bw = Yi.timeline({
                        paused: !0
                    })).set("#nav_wrapper", {
                        display: "block"
                    }, 0), Bw.to("#nav_bg", {
                        opacity: 1,
                        duration: .4
                    }, 0), Bw.to("#nav_bar", {
                        right: 0,
                        duration: 1,
                        ease: "expo.out"
                    }, 0), Bw.from("#nav_bar .col2 li", {
                        opacity: 0,
                        duration: .2,
                        y: 40,
                        stagger: .1
                    }, 0), Bw.from("#nav_bar .col1 .nav-subListWrapper ", {
                        opacity: 0,
                        duration: .6,
                        stagger: .2
                    }, .6), Bw.from("#nav_bar .col_containerImage ", {
                        opacity: 0,
                        duration: .4
                    }, .4), Yi.timeline({
                        paused: !0
                    }).set("#loader", {
                        className: "close"
                    }), (Hw = Yi.timeline({
                        paused: !0
                    })).to(".nav-item", {
                        y: "-300%",
                        duration: .4,
                        stagger: .03
                    }, 0), Hw.set("#header-nav", {
                        display: "none"
                    }, "+=0")
                }
                var e, n, i;
                return e = t, n = [{
                    key: "openLoadingAnimation",
                    value: function () {
                        return Yi.to("#loader", {
                            top: "0",
                            height: "100%",
                            display: "block",
                            ease: "power4.out",
                            skewY: 0,
                            duration: .3
                        })
                    }
                }, {
                    key: "closeNormalLoadingAnimation",
                    value: function () {
                        Yi.to("#loader", {
                            top: "-50%",
                            height: "0",
                            display: "none",
                            skewY: -10,
                            ease: "power4.in",
                            duration: .5
                        }), uw.normalLoaderAnimationIsComplete()
                    }
                }, {
                    key: "mainLoaderUpdate",
                    value: function (t) {
                        ! function (t) {
                            Xw = t;
                            var e = 10;
                            Gw && (clearInterval(Gw), Gw = null), e = 0 === qw || Xw / 2 > qw ? 100 : 50, 100 === Xw && (e = 5), Gw = setInterval(Kw, e)
                        }(t)
                    }
                }, {
                    key: "loaderStartFinished",
                    value: function () {}
                }, {
                    key: "colorScheme",
                    get: function () {
                        return !0
                    }
                }, {
                    key: "openSideNav",
                    value: function () {
                        Bw.timeScale(1).play(), document.body.classList.add("disableScroll"), document.documentElement.classList.add("disableScroll"), uw.stopScrolling(), this.hideTopNav(3)
                    }
                }, {
                    key: "closeSideNav",
                    value: function () {
                        arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? Bw.timeScale(20).reverse() : Bw.timeScale(3).reverse(), document.body.classList.remove("disableScroll"), document.documentElement.classList.remove("disableScroll"), uw.resumeScrolling(), this.showTopNav(1)
                    }
                }, {
                    key: "showTopNav",
                    value: function () {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        Hw && window.scrollY < 70 && (e ? Hw.progress(0, !1) : Hw.timeScale(t).reverse())
                    }
                }, {
                    key: "hideTopNav",
                    value: function () {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                        Hw && (arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? Hw.progress(1, !1) : Hw.timeScale(t).play())
                    }
                }, {
                    key: "showTopHeader",
                    value: function () {
                        Yi.set("#mainheader", {
                            display: "flex"
                        })
                    }
                }, {
                    key: "hideTopHeader",
                    value: function () {
                        Yi.set("#mainheader", {
                            display: "none"
                        })
                    }
                }, {
                    key: "pageAnimationsIn",
                    value: function () {}
                }, {
                    key: "pageAnimationsOut",
                    value: function () {
                        Yi.utils.toArray("main").forEach((function (t, e) {
                            Yi.to(t, {
                                y: "+=400",
                                duration: .75
                            })
                        }))
                    }
                }, {
                    key: "pageInitAllAnimations",
                    value: function () {
                        ! function () {
                            Yi.utils.toArray(".objectMoveLeftPinWrapper").forEach((function (t) {
                                var e = t.querySelector(".objectMoveLeft");

                                function n() {
                                    return -(e.getBoundingClientRect().width - window.innerWidth)
                                }
                                var i = Yi.to(e, {
                                    x: n,
                                    ease: "none"
                                });
                                ea.create({
                                    trigger: t,
                                    pin: t.querySelector(".objectMoveLeftContainer"),
                                    end: "bottom bottom",
                                    scrub: !0,
                                    invalidateOnRefresh: !0,
                                    animation: i
                                })
                            })), Yi.utils.toArray("[data-speed]").forEach((function (t) {
                                var e = t.getAttribute("data-speed"),
                                    n = Yi.timeline();
                                "auto" == e ? n.fromTo(t, {
                                    y: "-5%"
                                }, {
                                    y: "+5%"
                                }) : (e *= 10, n.fromTo(t, {
                                    y: -1 * e - e / 2 + "%"
                                }, {
                                    y: e - e / 2 + "%"
                                })), ea.create({
                                    trigger: t,
                                    start: "top bottom",
                                    end: "bottom top",
                                    scrub: 1,
                                    animation: n
                                })
                            })), Yi.utils.toArray(".travel-headerAnimation").forEach((function (t) {
                                ea.create({
                                    trigger: t.querySelector(".travel-headerTextWrapper"),
                                    start: "top 5%",
                                    endTrigger: t.querySelector(".travel-headerImageWrapper"),
                                    end: "bottom 0%+=500px",
                                    pin: t.querySelector(".travel-headerTextContainer"),
                                    invalidateOnRefresh: !0
                                })
                            })), document.body.classList.remove("backgroundIsDark"), document.body.classList.remove("backgroundIsLight"), Yi.utils.toArray(".backgroundIsDark").forEach((function (t) {
                                ea.create({
                                    trigger: t,
                                    start: "top top+=150px",
                                    end: "bottom top+=150px",
                                    onEnter: function (t) {
                                        return document.body.classList.add("backgroundIsDark")
                                    },
                                    onLeaveBack: function (t) {
                                        return document.body.classList.remove("backgroundIsDark")
                                    },
                                    onLeave: function (t) {
                                        return document.body.classList.remove("backgroundIsDark")
                                    },
                                    onEnterBack: function (t) {
                                        return document.body.classList.add("backgroundIsDark")
                                    }
                                })
                            })), Yi.utils.toArray(".backgroundIsLight").forEach((function (t) {
                                ea.create({
                                    trigger: t,
                                    start: "top top+=150px",
                                    end: "bottom top+=150px",
                                    onEnter: function (t) {
                                        return document.body.classList.add("backgroundIsLight")
                                    },
                                    onLeaveBack: function (t) {
                                        return document.body.classList.remove("backgroundIsLight")
                                    },
                                    onLeave: function (t) {
                                        return document.body.classList.remove("backgroundIsLight")
                                    },
                                    onEnterBack: function (t) {
                                        return document.body.classList.add("backgroundIsLight")
                                    }
                                })
                            })), Yi.utils.toArray(".photoWrapperSwitchBtnContainer").forEach((function (t) {
                                function e() {
                                    var t = document.querySelector("#photoWrapperView");
                                    Yi.to(t, {
                                        opacity: 0,
                                        duration: .25
                                    }), uw.stopScrolling(), Yi.to(window, {
                                        duration: .25,
                                        scrollTo: {
                                            x: 0,
                                            y: t,
                                            offsetY: 50
                                        },
                                        onComplete: function (e) {
                                            t.classList.toggle("photoWrapperTile"), t.classList.toggle("paddingLeftRight"), ea.refresh(), Yi.to(t, {
                                                opacity: 1,
                                                duration: .25
                                            }), uw.resumeScrolling()
                                        }
                                    })
                                }
                                t.addEventListener("click", e), ea.create({
                                    trigger: document.getElementById("photoWrapperView"),
                                    start: "top bottom-=160px",
                                    end: "bottom top",
                                    pin: t
                                })
                            })), Yi.utils.toArray(".photoRevealInteractive").forEach((function (t) {
                                function e() {
                                    t.classList.toggle("secondPhoto")
                                }
                                t.addEventListener("click", e)
                            })), Yi.utils.toArray(".openVideoPlayer").forEach(function (t) {
    t.addEventListener("click", function () {
        // Get the embed URL from the data attribute
        const embedUrl = t.dataset.embedUrl;

        // Create a modal container
        const modal = document.createElement("div");
        modal.classList.add("video-modal");

        // Create the iframe for the embedded video
        const iframe = document.createElement("iframe");
        iframe.src = embedUrl;
        iframe.setAttribute("frameborder", "0");
        iframe.setAttribute("allow", "autoplay; fullscreen");
        iframe.setAttribute("allowfullscreen", "");

        // Append the iframe to the modal
        modal.appendChild(iframe);

        // Add a close button to the modal
        const closeButton = document.createElement("button");
        closeButton.classList.add("close-button");
        closeButton.innerHTML = "&times;"; // "" symbol
        closeButton.addEventListener("click", function () {
            document.body.removeChild(modal);
        });

        modal.appendChild(closeButton);

        // Append the modal to the body
        document.body.appendChild(modal);

        // Add a class to the body to prevent scrolling
        document.body.classList.add("modal-open");
    });
}); Yi.utils.toArray(".photosWrapper").forEach((function (t) {
                                var e = Yi.timeline(),
                                    n = t,
                                    i = t.querySelector(".photo1"),
                                    r = t.querySelector(".photo3");
                                e.to(n, {
                                    left: "50%",
                                    top: "50%",
                                    ease: "power4.out",
                                    duration: .75
                                }, 0), e.to(n, {
                                    x: "-50%",
                                    y: "-50%",
                                    ease: "power4.out",
                                    duration: .75
                                }, 0), e.to(i, {
                                    x: "-100%",
                                    duration: .3
                                }, 0), e.to(r, {
                                    x: "+100%",
                                    duration: .3
                                }, 0)
                            })), Yi.utils.toArray(".photosWrapperView").forEach((function (t) {
                                var e = Yi.timeline(),
                                    n = t,
                                    i = t.querySelector(".photo1"),
                                    r = t.querySelector(".photo3");
                                e.to(n, {
                                    left: "50%",
                                    top: "50%",
                                    ease: "power4.out",
                                    duration: .75
                                }, 0), e.to(n, {
                                    x: "-50%",
                                    y: "-50%",
                                    ease: "power4.out",
                                    duration: .75
                                }, 0), e.to(i, {
                                    x: "-100%",
                                    duration: .3
                                }, 0), e.to(r, {
                                    x: "+130%",
                                    duration: .3
                                }, 0), ea.create({
                                    trigger: t,
                                    start: "top center",
                                    end: "bottom center",
                                    scrub: !0,
                                    animation: e
                                })
                            })), Yi.utils.toArray(".scrollInformer").forEach((function (t) {
                                Yi.to(t, {
                                    opacity: 1,
                                    duration: 1.5,
                                    delay: .5
                                }), t.addEventListener("click", (function () {
                                    window.scrollTo({
                                        top: window.innerHeight,
                                        behavior: "smooth"
                                    })
                                }))
                            })), Ww = !1, Qw(), Yi.registerPlugin(Jc), Yi.utils.toArray("#rect").forEach((function (t) {
                                Yi.to(t, {
                                    duration: 5,
                                    repeat: 12,
                                    repeatDelay: 3,
                                    yoyo: !0,
                                    ease: "power1.inOut",
                                    motionPath: {
                                        path: "#path",
                                        align: "#path",
                                        autoRotate: !0,
                                        alignOrigin: [.5, .5]
                                    }
                                })
                            })), window.innerWidth <= 800 && Yi.utils.toArray(".photoSelectionContainer").forEach((function (t) {
                                ea.create({
                                    trigger: t,
                                    start: "top center",
                                    end: "bottom center",
                                    toggleClass: {
                                        targets: t,
                                        className: "photography-photoAlbum-Animation"
                                    }
                                })
                            })), Yi.utils.toArray(".circle-animation").forEach((function (t) {
                                var e = t.querySelector(".circle-animation-inner");
                                Yi.to(e, {
                                    clipPath: "circle(100% at 50% 50%)",
                                    scrollTrigger: {
                                        trigger: t,
                                        start: "top top",
                                        end: "bottom bottom",
                                        pin: e,
                                        scrub: !0
                                    }
                                })
                            })), Yi.utils.toArray(".cutBetweenArticle").forEach((function (t) {
                                Yi.to(t.querySelector(".bottom"), {
                                    clipPath: "polygon(0% 0%, 100% 80%, 100% 102%, 0% 102%)",
                                    scrollTrigger: {
                                        trigger: t,
                                        scrub: !0
                                    }
                                })
                            })), Yi.utils.toArray(".photoRevealAsap").forEach((function (t) {
                                Yi.to(t, {
                                    clipPath: "polygon(0 0, 100% 0, 100% 100%, 0% 100%)",
                                    duration: 1,
                                    scale: 1,
                                    ease: "power1.inOut"
                                })
                            })), Yi.utils.toArray(".photoReveal").forEach((function (t) {
                                var e = Yi.timeline({
                                    scrollTrigger: {
                                        trigger: t,
                                        start: "top 90%",
                                        end: "bottom 85%",
                                        scrub: !0,
                                        toggleActions: "play resume resume reverse"
                                    }
                                });
                                e.to(t, {
                                    clipPath: "polygon(0 0, 100% 0, 100% 100%, 0% 100%)",
                                    ease: "power1.inOut",
                                    duration: .7
                                }, 0), e.to(t.querySelector(".pictureWrapper"), {
                                    scale: 1,
                                    duration: .7
                                }, 0), Yi.utils.toArray(".carousel").forEach((function (t) {
                                    new Uw(t, {
                                        align: "center",
                                        bound: !0,
                                        autoResize: !0,
                                        autoInit: !0,
                                        preventEventsBeforeInit: !0,
                                        resizeOnContentsReady: !0
                                    })
                                }))
                            })), Yi.utils.toArray(".animation-textRevealChars").forEach((function (t) {
                                var e = new El(t, {
                                    types: "words, chars"
                                }).chars;
                                Yi.set(e, {
                                    y: "115%"
                                }), Yi.set(t, {
                                    opacity: 1
                                }), Yi.to(e, {
                                    y: 0,
                                    stagger: .05,
                                    duration: 1.5,
                                    ease: "power4.out",
                                    delay: .2
                                })
                            })), Yi.utils.toArray(".animation-textRevealWords").forEach((function (t) {
                                var e = new El(t, {
                                        types: "words"
                                    }).words,
                                    n = .05;
                                e.length < 15 && (n = .1), e.length < 5 && (n = .1), Yi.fromTo(e, {
                                    y: "50%",
                                    opacity: 0
                                }, {
                                    y: 0,
                                    opacity: 1,
                                    stagger: n,
                                    duration: 1,
                                    ease: "power2.out",
                                    delay: 1
                                })
                            })), Yi.utils.toArray(".animation-textRevealLines").forEach((function (t) {
                                var e = new El(t, {
                                    types: "lines"
                                }).lines;
                                Yi.fromTo(e, {
                                    y: "50%",
                                    opacity: 0
                                }, {
                                    y: 0,
                                    opacity: 1,
                                    stagger: .5,
                                    duration: 1,
                                    ease: "power2.out",
                                    delay: 1
                                })
                            })), Yi.utils.toArray(".animation-textReveal").forEach((function (t) {
                                var e = new El(t, {
                                    types: "chars"
                                }).chars;
                                Yi.set(e, {
                                    y: "100%"
                                }), Yi.set(t, {
                                    opacity: 1
                                }), Yi.to(e, {
                                    y: 0,
                                    stagger: .05,
                                    duration: 1.5,
                                    ease: "power4.out",
                                    delay: .2
                                })
                            })), Yi.utils.toArray(".animation-moveUp").forEach((function (t) {
                                Yi.from(t, {
                                    y: "200px",
                                    duration: 1.5,
                                    ease: "power4.out"
                                })
                            })), Yi.utils.toArray(".animation-moveUpSlow").forEach((function (t) {
                                Yi.from(t, {
                                    y: "500px",
                                    duration: 3,
                                    ease: "power4.out"
                                })
                            })), Yi.utils.toArray(".animation-moveFromRight").forEach((function (t) {
                                Yi.from(t, {
                                    x: "100%",
                                    rotateZ: -20,
                                    scrollTrigger: {
                                        trigger: t,
                                        start: "top bottom",
                                        end: "bottom bottom",
                                        scrub: !0
                                    }
                                })
                            })), Yi.utils.toArray(".animation-moveFromLeft").forEach((function (t) {
                                Yi.from(t, {
                                    x: "-100%",
                                    rotateZ: 20,
                                    scrollTrigger: {
                                        trigger: t,
                                        start: "top bottom",
                                        end: "bottom bottom",
                                        scrub: !0
                                    }
                                })
                            })), Yi.utils.toArray(".animation-moveUpTrigger").forEach((function (t) {
                                Yi.to(t, {
                                    marginTop: "-8%",
                                    scrollTrigger: {
                                        trigger: t,
                                        start: "top bottom",
                                        end: "bottom top",
                                        scrub: !0
                                    }
                                })
                            })), Yi.utils.toArray(".textWriterAnimationEnd").forEach((function (t) {
                                ea.create({
                                    trigger: t,
                                    start: "top 100%",
                                    end: "bottom 100%",
                                    onUpdate: function (e) {
                                        return Yi.set(t, {
                                            backgroundSize: String(100 * e.progress) + "% 100%"
                                        })
                                    }
                                })
                            })), Yi.utils.toArray(".textWriterAnimation").forEach((function (t) {
                                ea.create({
                                    trigger: t,
                                    start: "top 95%",
                                    end: "center 40%",
                                    onUpdate: function (e) {
                                        return Yi.set(t, {
                                            backgroundSize: String(100 * e.progress) + "% 100%"
                                        })
                                    }
                                })
                            })), Yi.utils.toArray("#s-home-showreel #imageContainer").forEach((function (t) {
                                Yi.to(t, {
                                    width: "80%",
                                    height: "100%",
                                    scrollTrigger: {
                                        trigger: "#s-home-showreel",
                                        end: "top center",
                                        scrub: !0
                                    }
                                })
                            }));
                            var t = Yi.timeline({});
                            Yi.utils.toArray("#s-home-services").forEach((function (e) {
                                ea.create({
                                    animation: t,
                                    trigger: e,
                                    scrub: !0,
                                    pin: !0,
                                    anticipatePin: 1
                                })
                            })), Yi.utils.toArray("#textbigcontainer").forEach((function (t) {
                                Yi.from(t, {
                                    scale: 1.3,
                                    duration: 1,
                                    alpha: 0,
                                    delay: .6
                                })
                            }))
                        }()
                    }
                }, {
                    key: "onScroll",
                    value: function () {
                        ! function () {
                            var t = window.scrollY;
                            $w != t && ($w = t);
                            var e = document.getElementById("mainheader");
                            window.scrollY > 0 ? e.classList.add("scrolled") : e.classList.remove("scrolled"), window.scrollY > 70 ? (hw.hideTopNav(), Ww || (Ww = !0, Yi.utils.toArray(".scrollInformer").forEach((function (t) {
                                Yi.to(t, {
                                    opacity: 0,
                                    duration: .5,
                                    display: "none"
                                })
                            })))) : hw.showTopNav()
                        }()
                    }
                }, {
                    key: "resize",
                    value: function () {
                        Qw()
                    }
                }, {
                    key: "moveMouse",
                    value: function (t) {}
                }], n && Fw(e.prototype, n), i && Fw(e, i), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), t
            }(),
            Xw = 0,
            qw = 0,
            Yw = 0;

        function Kw() {
            if (Yw != Xw) {
                Yw++;
                var t = document.querySelector(".percent"),
                    e = "000";
                e = Yw < 10 ? "00" + Yw : Yw >= 10 && Yw < 100 ? "0" + Yw : Yw, t.innerHTML = String(e), Yi.to("#laoderstart2 .bg1", {
                    width: Yw + "%",
                    right: "unset",
                    duration: 1,
                    ease: "power4.out",
                    onComplete: 100 == Yw ? Zw : null
                }), Yi.to("#laoderstart2 .percent", {
                    "margin-top": 100 - Yw + "px",
                    duration: 1,
                    ease: "power2.out"
                })
            } else Gw && (clearInterval(Gw), Gw = null)
        }

        function Zw() {
            (Vw = Yi.timeline({
                paused: !0
            })).set("#laoderstart2 .bg2", {
                display: "none"
            }, 0), Vw.to("#laoderstart2 .bg1", {
                width: "0",
                x: "100vw",
                duration: 1,
                ease: "power2.in"
            }, 0), Vw.to("#laoderstart2 .percent", {
                opacity: 0,
                x: "+=100",
                duration: 1,
                ease: "power2.in"
            }, 0), Vw.set("#laoderstart2", {
                display: "none"
            }), Vw.play(), uw.mainLoaderAnimationIsComplete()
        }
        var Jw, $w = 0;

        function Qw() {
            Yi.utils.toArray(".objectMoveLeftWrapper").forEach((function (t) {
                var e = t.querySelector(".objectMoveLeftContainer"),
                    n = e.querySelector(".objectMoveLeft"),
                    i = n.getBoundingClientRect().width - window.innerWidth;
                i > 150 ? (t.classList.add("scrollWrapper"), Yi.set(e, {
                    justifyContent: "unset"
                }), Yi.to(n, {
                    x: -i,
                    ease: "power2.out",
                    scrollTrigger: {
                        trigger: e,
                        start: "top top",
                        endTrigger: t,
                        end: "bottom top",
                        scrub: !0
                    }
                })) : (t.classList.remove("scrollWrapper"), Yi.set(e, {
                    textAlign: "center",
                    width: "100%",
                    justifyContent: "center"
                }))
            }))
        }

        function tT(t) {
            return tT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, tT(t)
        }

        function eT(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, nT(i.key), i)
            }
        }

        function nT(t) {
            var e = function (t, e) {
                if ("object" != tT(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" != tT(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == tT(e) ? e : String(e)
        }
        var iT = function () {
                function t() {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), Jw = this
                }
                var e, n, i;
                return e = t, n = [{
                    key: "updateButtons",
                    value: function () {
                        document.querySelectorAll(".btnSwitchDarkMode").forEach((function (t, e) {
                            t.removeEventListener("click", Jw.toggleColorMode), t.addEventListener("click", Jw.toggleColorMode)
                        }))
                    }
                }, {
                    key: "toggleColorMode",
                    value: function () {
                        document.body.classList.contains("dark") ? Jw.switchColorMode(!1) : Jw.switchColorMode(!0)
                    }
                }, {
                    key: "switchColorMode",
                    value: function () {
                        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                            e = document.querySelectorAll(".btnSwitchDarkMode");
                        t ? (document.body.classList.add("dark"), e.forEach((function (t, e) {
                            t.querySelector(".text").innerHTML = t.querySelector(".text").dataset.linktext = "Switch to Light Mode"
                        }))) : (document.body.classList.remove("dark"), e.forEach((function (t, e) {
                            t.querySelector(".text").innerHTML = t.querySelector(".text").dataset.linktext = "Switch to Dark Mode"
                        })))
                    }
                }, {
                    key: "init",
                    value: function () {
                        var t = this;
                        this.updateButtons(),
                            function (t) {
                                if (window.matchMedia) {
                                    var e = window.matchMedia("(prefers-color-scheme: dark)");
                                    t(e.matches), e.addEventListener("change", (function (e) {
                                        return t(e.matches)
                                    }))
                                }
                            }((function (e) {
                                t.switchColorMode(e)
                            }))
                    }
                }], n && eT(e.prototype, n), i && eT(e, i), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), t
            }(),
            rT = function (t) {
                return Promise.all(t.map((function (t) {
                    return function (t) {
                        return new Promise((function (e, n) {
                            var i = new Image,
                                r = new XMLHttpRequest;
                            r.open("GET", t, !0), r.responseType = "blob", r.onload = function () {
                                i.src = URL.createObjectURL(r.response), i.onload = function () {
                                    return e(i)
                                }
                            }, r.onerror = function () {
                                return n()
                            }, r.send()
                        }))
                    }(t)
                })))
            },
            sT = function (t, e) {
                var n, i, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .5,
                    s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5,
                    o = t.canvas.width,
                    a = t.canvas.height,
                    l = e.width / e.height;
                l > o / a ? (n = a, i = a * l) : (i = o, n = o / l), t.drawImage(e, (o - i) * r, (a - n) * s, i, n)
            };

        function oT(t) {
            return oT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, oT(t)
        }

        function aT(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, lT(i.key), i)
            }
        }

        function lT(t) {
            var e = function (t, e) {
                if ("object" != oT(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" != oT(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == oT(e) ? e : String(e)
        }

        function cT(t, e, n) {
            ! function (t, e) {
                if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object")
            }(t, e), e.set(t, n)
        }

        function uT(t, e) {
            return function (t, e) {
                if (e.get) return e.get.call(t);
                return e.value
            }(t, dT(t, e, "get"))
        }

        function hT(t, e, n) {
            return function (t, e, n) {
                if (e.set) e.set.call(t, n);
                else {
                    if (!e.writable) throw new TypeError("attempted to set read only private field");
                    e.value = n
                }
            }(t, dT(t, e, "set"), n), n
        }

        function dT(t, e, n) {
            if (!e.has(t)) throw new TypeError("attempted to " + n + " private field on non-instance");
            return e.get(t)
        }
        var fT = new WeakMap,
            pT = new WeakMap,
            mT = new WeakMap,
            gT = new WeakMap,
            vT = function () {
                function t(e) {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), cT(this, fT, {
                        writable: !0,
                        value: null
                    }), cT(this, pT, {
                        writable: !0,
                        value: null
                    }), cT(this, mT, {
                        writable: !0,
                        value: !1
                    }), cT(this, gT, {
                        writable: !0,
                        value: !1
                    }), hT(this, fT, e), Yi.registerPlugin(tb), this.init(), this.initDemoSeq()
                }
                var e, n, i;
                return e = t, n = [{
                    key: "moveMouse",
                    value: function (t) {}
                }, {
                    key: "onWindowResize",
                    value: function () {}
                }, {
                    key: "onScroll",
                    value: function () {
                        var t;
                        uT(this, mT) ? (Yi.utils.toArray(".sideLeftNavListItem").forEach((function (t) {
                            t.classList.remove("active")
                        })), hT(this, gT, !0), t = document.getElementById("sideLeftNav").querySelector(".sideLeftNavListItem-" + uT(this, mT))) : uT(this, gT) ? hT(this, gT, !1) : (Yi.utils.toArray(".sideLeftNavListItem").forEach((function (t) {
                            t.classList.remove("active")
                        })), ea.isInViewport("#abudhabi") && (t = document.getElementById("sideLeftNav").querySelector(".sideLeftNavListItem-abudhabi")), ea.isInViewport("#india") && (t = document.getElementById("sideLeftNav").querySelector(".sideLeftNavListItem-india")), ea.isInViewport("#barcelona") && (t = document.getElementById("sideLeftNav").querySelector(".sideLeftNavListItem-barcelona")), ea.isInViewport("#capetown") && (t = document.getElementById("sideLeftNav").querySelector(".sideLeftNavListItem-capetown"))), t && t.classList.add("active")
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        hT(this, fT, null)
                    }
                }, {
                    key: "init",
                    value: function () {
                        var t = this,
                            e = document.createElement("ul"),
                            n = ["abudhabi", "india", "barcelona", "capetown"];
                        document.getElementById("sideLeftNav").appendChild(e), ["Abu Dhabi", "India", "Barcelona", "Capetown"].forEach((function (t, i, r) {
                            var s = document.createElement("li");
                            s.setAttribute("class", "sideLeftNavListItem"), s.classList.add("sideLeftNavListItem-" + n[i]), s.setAttribute("data-anchor", n[i]), s.innerHTML = "<div></div><span>" + t + "</span>", e.appendChild(s)
                        })), Yi.utils.toArray(".sideLeftNavListItem").forEach((function (e) {
                            e.addEventListener("click", (function () {
                                var n, i = e.getAttribute("data-anchor");
                                i && (n = document.querySelector("#" + i)), n && (i, hT(t, mT, i), uT(t, fT).stopScrolling(), Yi.to(window, {
                                    duration: .75,
                                    scrollTo: {
                                        y: n
                                    },
                                    onComplete: function (e) {
                                        hT(t, mT, null), uT(t, fT).resumeScrolling()
                                    }
                                }))
                            }))
                        })), Yi.to("#photoContainer .photo-back", {
                            top: "0%",
                            scrollTrigger: {
                                trigger: "#photoContainer",
                                start: "top bottom",
                                end: "bottom top",
                                scrub: 1
                            }
                        }), Yi.to("#photoContainer .photo-front", {
                            top: "30%",
                            scrollTrigger: {
                                trigger: "#photoContainer",
                                start: "top bottom",
                                end: "bottom top",
                                scrub: 1
                            }
                        })
                    }
                }, {
                    key: "initDemoSeq",
                    value: function () {}
                }, {
                    key: "createSeq",
                    value: function () {
                        var t = new Array(36).fill(null).map((function (t, e) {
                                return "/assets/images/imgseq1/".concat(e, "-1200w.webp")
                            })),
                            e = rT(t),
                            n = document.querySelector(".cb-sequence"),
                            i = n.querySelector("canvas").getContext("2d"),
                            r = new Yi.timeline({
                                scrollTrigger: {
                                    trigger: n,
                                    scrub: !0,
                                    start: "top top",
                                    end: "50%",
                                    pin: !0
                                }
                            });
                        window.addEventListener("resize", function t() {
                            return i.canvas.width = document.documentElement.clientWidth, i.canvas.height = document.documentElement.clientHeight, t
                        }()), e.then((function (t) {
                            var e = {
                                i: 0
                            };
                            r.to(e, {
                                i: t.length - 1,
                                roundProps: "i",
                                ease: "none",
                                immediateRender: !0,
                                onUpdate: function () {
                                    return sT(i, t[e.i])
                                }
                            }, 0), window.addEventListener("resize", (function () {
                                return sT(i, t[e.i])
                            }))
                        }))
                    }
                }], n && aT(e.prototype, n), i && aT(e, i), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), t
            }();

        function _T(t) {
            return _T = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, _T(t)
        }

        function yT(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, bT(i.key), i)
            }
        }

        function xT(t, e, n) {
            return (e = bT(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function bT(t) {
            var e = function (t, e) {
                if ("object" != _T(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" != _T(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == _T(e) ? e : String(e)
        }
        var ST = function () {
            function t() {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), xT(this, "userID", void 0), xT(this, "sessionID", void 0), xT(this, "userReferrer", void 0), xT(this, "userLanguage", void 0), this.initialize()
            }
            var e, n, i;
            return e = t, n = [{
                key: "initialize",
                value: function () {
                    this.getReferrer(), this.getLanguage(), this.generateSessionId(), this.getCookie()
                }
            }, {
                key: "getLanguage",
                value: function () {
                    var t = navigator.language || navigator.userLanguage;
                    this.userLanguage = t
                }
            }, {
                key: "generateSessionId",
                value: function () {
                    for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = "", n = 0; n < 20; n++) e += t.charAt(Math.floor(62 * Math.random()));
                    this.sessionID = e
                }
            }, {
                key: "getReferrer",
                value: function () {
                    var t = document.referrer;
                    t || (t = window.top.document.referrer), t || (t = ""), this.userReferrer = t
                }
            }, {
                key: "getCookie",
                value: function () {
                    var t = function () {
                        var t, e, n = (t = "id", (e = document.cookie.match("(^|;)\\s*" + t + "\\s*=\\s*([^;]+)")) ? e.pop() : "");
                        return n || (n = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (t) {
                            var e = 16 * Math.random() | 0;
                            return ("x" == t ? e : 3 & e | 8).toString(16)
                        })), function (t, e, n) {
                            var i = "";
                            if (n) {
                                var r = new Date;
                                r.setTime(r.getTime() + 24 * n * 60 * 60 * 1e3), i = "; expires=" + r.toUTCString()
                            }
                            document.cookie = t + "=" + e + i + "; path=/"
                        }("id", n, 365)), n
                    }();
                    this.userID = t
                }
            }, ], n && yT(e.prototype, n), i && yT(e, i), Object.defineProperty(e, "prototype", {
                writable: !1
            }), t
        }();

        function ET(t) {
            return ET = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ET(t)
        }

        function MT(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, AT(i.key), i)
            }
        }

        function wT(t, e) {
            ! function (t, e) {
                if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object")
            }(t, e), e.add(t)
        }

        function TT(t, e, n) {
            return (e = AT(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function AT(t) {
            var e = function (t, e) {
                if ("object" != ET(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" != ET(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == ET(e) ? e : String(e)
        }

        function PT(t, e, n) {
            if (!e.has(t)) throw new TypeError("attempted to get private field on non-instance");
            return n
        }
        var CT = new WeakSet,
            RT = new WeakSet,
            LT = new WeakSet,
            OT = new WeakSet,
            IT = new WeakSet,
            DT = new WeakSet,
            NT = new WeakSet,
            UT = new WeakSet,
            kT = function () {
                function t() {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), wT(this, UT), wT(this, NT), wT(this, DT), wT(this, IT), wT(this, OT), wT(this, LT), wT(this, RT), wT(this, CT), TT(this, "scrollAnimation", void 0), TT(this, "globalAnimations", void 0), TT(this, "analytics", void 0), TT(this, "darkMode", void 0), TT(this, "currentPage", void 0), TT(this, "navIsOpen", void 0), TT(this, "maxPageHeight", 0), Yi.registerPlugin(ea), this.analytics = new ST(this), this.scrollAnimation = new Sa(this), this.globalAnimations = new jw(this), this.darkMode = new iT, this.init()
                }
                var e, n, i;
                return e = t, n = [{
                    key: "init",
                    value: function () {
                        PT(this, RT, zT).call(this)
                    }
                }, {
                    key: "stopScrolling",
                    value: function () {
                        this.scrollAnimation.stopScrolling()
                    }
                }, {
                    key: "resumeScrolling",
                    value: function () {
                        this.scrollAnimation.resumeScrolling()
                    }
                }, {
                    key: "openOrCloseNav",
                    value: function () {
                        this.navIsOpen ? this.closeNav(this, !1) : this.openNav()
                    }
                }, {
                    key: "openNav",
                    value: function () {
                        this.navIsOpen = !0, this.globalAnimations.openSideNav()
                    }
                }, {
                    key: "closeNav",
                    value: function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        t.navIsOpen = !1, t.globalAnimations.closeSideNav(e)
                    }
                }], n && MT(e.prototype, n), i && MT(e, i), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), t
            }();

        function FT() {
            var t = this;
            t.globalAnimations.hideTopNav(0, !0);
            document.querySelector("#laoderstart2");
            var e = document.querySelector("#laoderstart2 .barWrapper"),
                n = document.querySelector("#laoderstart2 .barWrapper .bar"),
                i = (document.querySelector("#laoderstart2 .bg"), document.querySelector("#laoderstart2 .imgWrapper"), document.querySelector("#laoderstart2 .imgWrapper .img-gif")),
                r = (document.querySelector("#laoderstart2 .imgWrapper .img-jpg"), document.querySelector("#laoderstart2 .barTop")),
                s = document.querySelector("#laoderstart2 .barBottom"),
                o = n.offsetWidth;
            n.style.animationPlayState = "paused", n.classList.remove("animation");
            var a = Yi.timeline({
                    onComplete: function () {
                        return document.body.style.removeProperty("overflow"), document.body.classList.remove("diableBodyScrollAtStart"), !0
                    }
                }),
                l = .75,
                c = .75;
            a.fromTo(n, {
                width: o
            }, {
                width: "100%",
                duration: l,
                ease: "power4.out"
            }, 0), a.to(r, {
                y: "-150%",
                skewY: 8,
                duration: c,
                ease: "expo.inOut"
            }, l), a.to(s, {
                y: "150%",
                skewY: 8,
                duration: c,
                ease: "expo.inOut"
            }, l), a.to(e, {
                opacity: 0,
                display: "none",
                duration: .1875
            }, l), a.set(i, {
                display: "none"
            }, l), a.call((function () {
                t.globalAnimations.showTopNav(1.75, !0)
            }), null, l), a.set("#laoderstart2", {
                display: "none"
            }, 1.5)
        }
        function zT() {
            PT(this, LT, BT).call(this), PT(this, UT, WT).call(this), this.darkMode.init();
            var t = this;

            function n(e) {
                for (var n = ea.getAll(), i = 0; i < n.length; i++) n[i].kill(!0), n[i] = null;
                "home" == e.next.namespace && (t.currentPage = new Ax), "travel" == e.next.namespace && (t.currentPage = new vT(t)), t.globalAnimations.pageInitAllAnimations(), t.globalAnimations.showTopHeader(), t.scrollAnimation.init(), t.analytics.sendPageView(e.next.url.href, e.next.namespace)
            }
            e().hooks.leave((function (e) {
                t.closeNav(t, !0), t.globalAnimations.hideTopHeader()
            })), e().hooks.afterLeave((function (e) {
                t.currentPage && (t.currentPage.destroy(), t.currentPage = null), document.getElementById("sideLeftNav").innerHTML = "", t.scrollAnimation.delete()
            })), e().hooks.afterOnce((function (t) {
                n(t)
            })), e().hooks.after((function (t) {
                n(t)
            })), e().hooks.afterEnter((function (t) {
                document.querySelectorAll("video").forEach((function (t) {
                    var e = t.play();
                    void 0 !== e && e.then((function (t) {})).catch((function (t) {}))
                }))
            })), e().init({
                preventRunning: !0,
                prevent: function (t, n) {
                    if (t.href === e().history.current.url && "click" == t.event.type) return t.event.preventDefault(), void window.scrollTo(0, 0)
                },
                transitions: [{
                    name: "photo-transition",
                    from: {
                        namespace: "photo"
                    },
                    to: {
                        custom: function (t) {
                            return t.next.namespace.includes("photo-")
                        }
                    },
                    once: function (t) {
                        t.data
                    },
                    after: function (t) {
                        t.data;
                        var e = document.querySelector("#fixedPlaceholderPhotoTransition").querySelector(".photosWrapper"),
                            n = document.querySelector("#photo-site-placeholderPhotos");
                        return n.innerHTML = "", n.append(e), !0
                    },
                    afterOnce: function () {
                        startLoaderTimeline.call((function () {
                            return !0
                        }))
                    },
                    enter: function (t) {},
                    beforeLeave: function (t) {
                        var e = document.querySelector("#" + t.next.namespace + " .photos"),
                            n = document.querySelector("#fixedPlaceholderPhotoTransition"),
                            i = document.createElement("div");
                        return i.classList.add("photosWrapper"), Yi.set(i, {
                            x: 0,
                            y: 0,
                            left: e.getBoundingClientRect().left,
                            top: e.getBoundingClientRect().top,
                            width: e.getBoundingClientRect().width,
                            height: e.getBoundingClientRect().height
                        }), i.appendChild(e), n.appendChild(i), Yi.to("#s-photo-1", {
                            alpha: "0",
                            duration: .2
                        })
                    }
                }, {
                    name: "default-transition",
                    once: function (t) {
                        t.data
                    },
                    after: function (t) {
                        t.data;
                        return Yi.to("#loader", {
                            top: "-50%",
                            height: "0",
                            display: "none",
                            skewY: -10,
                            ease: "power4.in",
                            duration: .5
                        })
                    },
                    afterOnce: function () {
                        return PT(t, CT, FT).call(t)
                    },
                    enter: function (t) {},
                    beforeLeave: function (e) {
                        return t.globalAnimations.pageAnimationsOut(), Yi.to("#loader", {
                            top: "0",
                            height: "100%",
                            display: "block",
                            ease: "power4.out",
                            skewY: 0,
                            duration: .3
                        })
                    }
                }]
            })
        }

        function BT() {
            var t = this;
            window.addEventListener("mousemove", (function (e) {
                return PT(t, OT, HT).call(t, t, e)
            })), window.addEventListener("resize", PT(this, DT, VT).bind(this)), window.addEventListener("scroll", PT(this, NT, GT).bind(this))
        }

        function HT(t, e) {
            t.currentPage && t.currentPage.moveMouse(e), t.globalAnimations && t.globalAnimations.moveMouse(e)
        }

        function VT() {
            this.scrollAnimation && this.scrollAnimation.resize(), this.globalAnimations && this.globalAnimations.resize(), this.currentPage && this.currentPage.onWindowResize()
        }

        function GT() {
            this.globalAnimations && this.globalAnimations.onScroll(), this.currentPage && this.currentPage.onScroll()
        }

        function WT() {
            var t = this;
            this.navIsOpen = !1;
            var e = document.getElementById("nav-button");
            e && (e.addEventListener("click", this.openOrCloseNav.bind(this)), document.getElementById("nav_bg").addEventListener("click", (function (e) {
                return t.closeNav(t, !1)
            })))
        }
        new kT
    })()
})();